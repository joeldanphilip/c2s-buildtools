diff -Naur linux-5.4.1/arch/riscv/configs/cdacvega_defconfig linux-5.4.1_modified/arch/riscv/configs/cdacvega_defconfig
--- linux-5.4.1/arch/riscv/configs/cdacvega_defconfig	1970-01-01 05:30:00.000000000 +0530
+++ linux-5.4.1_modified/arch/riscv/configs/cdacvega_defconfig	2025-08-08 10:40:35.252963086 +0530
@@ -0,0 +1,1847 @@
+#
+# Automatically generated file; DO NOT EDIT.
+# Linux/riscv 5.4.0 Kernel Configuration
+#
+
+#
+# Compiler: riscv64-unknown-linux-gnu-gcc (GCC) 9.2.0
+#
+CONFIG_CC_IS_GCC=y
+CONFIG_GCC_VERSION=90200
+CONFIG_CLANG_VERSION=0
+CONFIG_CC_CAN_LINK=y
+CONFIG_CC_HAS_ASM_GOTO=y
+CONFIG_CC_HAS_ASM_INLINE=y
+CONFIG_CC_HAS_WARN_MAYBE_UNINITIALIZED=y
+CONFIG_IRQ_WORK=y
+CONFIG_THREAD_INFO_IN_TASK=y
+
+#
+# General setup
+#
+CONFIG_INIT_ENV_ARG_LIMIT=32
+# CONFIG_COMPILE_TEST is not set
+# CONFIG_HEADER_TEST is not set
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_BUILD_SALT=""
+CONFIG_DEFAULT_HOSTNAME="CDAC_TVM"
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_CROSS_MEMORY_ATTACH is not set
+# CONFIG_USELIB is not set
+# CONFIG_AUDIT is not set
+CONFIG_HAVE_ARCH_AUDITSYSCALL=y
+
+#
+# IRQ subsystem
+#
+CONFIG_GENERIC_IRQ_SHOW=y
+CONFIG_IRQ_DOMAIN=y
+CONFIG_SPARSE_IRQ=y
+# CONFIG_GENERIC_IRQ_DEBUGFS is not set
+# end of IRQ subsystem
+
+CONFIG_GENERIC_IRQ_MULTI_HANDLER=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+
+#
+# Timers subsystem
+#
+CONFIG_TICK_ONESHOT=y
+CONFIG_HZ_PERIODIC=y
+# CONFIG_NO_HZ_IDLE is not set
+# CONFIG_NO_HZ is not set
+CONFIG_HIGH_RES_TIMERS=y
+# end of Timers subsystem
+
+CONFIG_PREEMPT_NONE=y
+# CONFIG_PREEMPT_VOLUNTARY is not set
+# CONFIG_PREEMPT is not set
+
+#
+# CPU/Task time and stats accounting
+#
+CONFIG_TICK_CPU_ACCOUNTING=y
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_PSI is not set
+# end of CPU/Task time and stats accounting
+
+CONFIG_CPU_ISOLATION=y
+
+#
+# RCU Subsystem
+#
+CONFIG_TREE_RCU=y
+# CONFIG_RCU_EXPERT is not set
+CONFIG_SRCU=y
+CONFIG_TREE_SRCU=y
+CONFIG_RCU_STALL_COMMON=y
+CONFIG_RCU_NEED_SEGCBLIST=y
+# end of RCU Subsystem
+
+# CONFIG_IKCONFIG is not set
+# CONFIG_IKHEADERS is not set
+CONFIG_LOG_BUF_SHIFT=17
+CONFIG_LOG_CPU_MAX_BUF_SHIFT=12
+CONFIG_PRINTK_SAFE_LOG_BUF_SHIFT=13
+CONFIG_GENERIC_SCHED_CLOCK=y
+
+#
+# Scheduler features
+#
+# end of Scheduler features
+
+CONFIG_ARCH_SUPPORTS_INT128=y
+# CONFIG_CGROUPS is not set
+CONFIG_NAMESPACES=y
+CONFIG_UTS_NS=y
+CONFIG_IPC_NS=y
+# CONFIG_USER_NS is not set
+CONFIG_PID_NS=y
+CONFIG_NET_NS=y
+# CONFIG_CHECKPOINT_RESTORE is not set
+# CONFIG_SCHED_AUTOGROUP is not set
+# CONFIG_SYSFS_DEPRECATED is not set
+# CONFIG_RELAY is not set
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+# CONFIG_RD_GZIP is not set
+# CONFIG_RD_BZIP2 is not set
+# CONFIG_RD_LZMA is not set
+# CONFIG_RD_XZ is not set
+# CONFIG_RD_LZO is not set
+# CONFIG_RD_LZ4 is not set
+CONFIG_CC_OPTIMIZE_FOR_PERFORMANCE=y
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SYSCTL=y
+CONFIG_SYSCTL_EXCEPTION_TRACE=y
+CONFIG_BPF=y
+CONFIG_EXPERT=y
+CONFIG_MULTIUSER=y
+# CONFIG_SGETMASK_SYSCALL is not set
+CONFIG_SYSFS_SYSCALL=y
+# CONFIG_SYSCTL_SYSCALL is not set
+# CONFIG_FHANDLE is not set
+CONFIG_POSIX_TIMERS=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_FUTEX_PI=y
+CONFIG_HAVE_FUTEX_CMPXCHG=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+CONFIG_IO_URING=y
+CONFIG_ADVISE_SYSCALLS=y
+CONFIG_MEMBARRIER=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_ALL is not set
+CONFIG_KALLSYMS_BASE_RELATIVE=y
+# CONFIG_BPF_SYSCALL is not set
+# CONFIG_USERFAULTFD is not set
+CONFIG_EMBEDDED=y
+CONFIG_HAVE_PERF_EVENTS=y
+# CONFIG_PC104 is not set
+
+#
+# Kernel Performance Events And Counters
+#
+# CONFIG_PERF_EVENTS is not set
+# end of Kernel Performance Events And Counters
+
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_SLUB_DEBUG=y
+CONFIG_COMPAT_BRK=y
+# CONFIG_SLAB is not set
+CONFIG_SLUB=y
+# CONFIG_SLOB is not set
+CONFIG_SLAB_MERGE_DEFAULT=y
+# CONFIG_SLAB_FREELIST_RANDOM is not set
+# CONFIG_SLAB_FREELIST_HARDENED is not set
+# CONFIG_SHUFFLE_PAGE_ALLOCATOR is not set
+CONFIG_SLUB_CPU_PARTIAL=y
+# CONFIG_PROFILING is not set
+# end of General setup
+
+CONFIG_64BIT=y
+CONFIG_RISCV=y
+CONFIG_ARCH_MMAP_RND_BITS_MIN=18
+CONFIG_ARCH_MMAP_RND_BITS_MAX=24
+CONFIG_MMU=y
+CONFIG_ZONE_DMA32=y
+CONFIG_VA_BITS=39
+CONFIG_PA_BITS=56
+CONFIG_PAGE_OFFSET=0xffffffff80000000
+CONFIG_ARCH_FLATMEM_ENABLE=y
+CONFIG_ARCH_SPARSEMEM_ENABLE=y
+CONFIG_ARCH_SELECT_MEMORY_MODEL=y
+CONFIG_ARCH_WANT_GENERAL_HUGETLB=y
+CONFIG_SYS_SUPPORTS_HUGETLBFS=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_GENERIC_BUG=y
+CONFIG_GENERIC_BUG_RELATIVE_POINTERS=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_GENERIC_CSUM=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_FIX_EARLYCON_MEM=y
+CONFIG_PGTABLE_LEVELS=3
+
+#
+# SoC selection
+#
+# CONFIG_SOC_SIFIVE is not set
+# end of SoC selection
+
+#
+# Platform type
+#
+# CONFIG_ARCH_RV32I is not set
+CONFIG_ARCH_RV64I=y
+# CONFIG_CMODEL_MEDLOW is not set
+CONFIG_CMODEL_MEDANY=y
+CONFIG_MODULE_SECTIONS=y
+CONFIG_MAXPHYSMEM_2GB=y
+# CONFIG_MAXPHYSMEM_128GB is not set
+CONFIG_SMP=y
+CONFIG_NR_CPUS=8
+CONFIG_TUNE_GENERIC=y
+# CONFIG_RISCV_ISA_C is not set
+# CONFIG_FPU is not set
+# end of Platform type
+
+#
+# Kernel features
+#
+# CONFIG_HZ_100 is not set
+CONFIG_HZ_250=y
+# CONFIG_HZ_300 is not set
+# CONFIG_HZ_1000 is not set
+CONFIG_HZ=250
+CONFIG_SCHED_HRTICK=y
+# end of Kernel features
+
+#
+# Boot options
+#
+CONFIG_CMDLINE=""
+# end of Boot options
+
+#
+# Power management options
+#
+# CONFIG_PM is not set
+# end of Power management options
+
+#
+# General architecture-dependent options
+#
+CONFIG_HAVE_ARCH_TRACEHOOK=y
+CONFIG_HAVE_DMA_CONTIGUOUS=y
+CONFIG_GENERIC_SMP_IDLE_THREAD=y
+CONFIG_HAVE_ASM_MODVERSIONS=y
+CONFIG_HAVE_CLK=y
+CONFIG_HAVE_PERF_REGS=y
+CONFIG_HAVE_PERF_USER_STACK_DUMP=y
+CONFIG_CC_HAS_STACKPROTECTOR_NONE=y
+CONFIG_HAVE_VIRT_CPU_ACCOUNTING_GEN=y
+CONFIG_ARCH_WANT_HUGE_PMD_SHARE=y
+CONFIG_HAVE_MOD_ARCH_SPECIFIC=y
+CONFIG_MODULES_USE_ELF_RELA=y
+CONFIG_ARCH_HAS_ELF_RANDOMIZE=y
+CONFIG_HAVE_ARCH_MMAP_RND_BITS=y
+CONFIG_ARCH_MMAP_RND_BITS=18
+CONFIG_ARCH_WANT_DEFAULT_TOPDOWN_MMAP_LAYOUT=y
+CONFIG_CLONE_BACKWARDS=y
+CONFIG_64BIT_TIME=y
+# CONFIG_REFCOUNT_FULL is not set
+# CONFIG_LOCK_EVENT_COUNTS is not set
+
+#
+# GCOV-based kernel profiling
+#
+# CONFIG_GCOV_KERNEL is not set
+# end of GCOV-based kernel profiling
+
+CONFIG_PLUGIN_HOSTCC="g++"
+# end of General architecture-dependent options
+
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
+# CONFIG_MODULE_UNLOAD is not set
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+# CONFIG_MODULE_SIG is not set
+# CONFIG_MODULE_COMPRESS is not set
+# CONFIG_MODULE_ALLOW_MISSING_NAMESPACE_IMPORTS is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_TRIM_UNUSED_KSYMS is not set
+CONFIG_BLOCK=y
+# CONFIG_BLK_DEV_BSG is not set
+# CONFIG_BLK_DEV_BSGLIB is not set
+# CONFIG_BLK_DEV_INTEGRITY is not set
+# CONFIG_BLK_DEV_ZONED is not set
+# CONFIG_BLK_CMDLINE_PARSER is not set
+# CONFIG_BLK_WBT is not set
+# CONFIG_BLK_DEBUG_FS is not set
+# CONFIG_BLK_SED_OPAL is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+CONFIG_EFI_PARTITION=y
+# end of Partition Types
+
+#
+# IO Schedulers
+#
+CONFIG_MQ_IOSCHED_DEADLINE=y
+CONFIG_MQ_IOSCHED_KYBER=y
+# CONFIG_IOSCHED_BFQ is not set
+# end of IO Schedulers
+
+CONFIG_ASN1=y
+CONFIG_INLINE_SPIN_UNLOCK_IRQ=y
+CONFIG_INLINE_READ_UNLOCK=y
+CONFIG_INLINE_READ_UNLOCK_IRQ=y
+CONFIG_INLINE_WRITE_UNLOCK=y
+CONFIG_INLINE_WRITE_UNLOCK_IRQ=y
+CONFIG_ARCH_HAS_MMIOWB=y
+CONFIG_MMIOWB=y
+
+#
+# Executable file formats
+#
+CONFIG_BINFMT_ELF=y
+CONFIG_ELFCORE=y
+CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS=y
+CONFIG_BINFMT_SCRIPT=y
+CONFIG_ARCH_HAS_BINFMT_FLAT=y
+# CONFIG_BINFMT_FLAT is not set
+CONFIG_BINFMT_MISC=y
+CONFIG_COREDUMP=y
+# end of Executable file formats
+
+#
+# Memory Management options
+#
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_SPARSEMEM_VMEMMAP_ENABLE=y
+CONFIG_HAVE_MEMBLOCK_NODE_MAP=y
+CONFIG_SPLIT_PTLOCK_CPUS=4
+CONFIG_COMPACTION=y
+CONFIG_MIGRATION=y
+CONFIG_PHYS_ADDR_T_64BIT=y
+# CONFIG_KSM is not set
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+# CONFIG_CLEANCACHE is not set
+# CONFIG_FRONTSWAP is not set
+# CONFIG_CMA is not set
+# CONFIG_ZPOOL is not set
+# CONFIG_ZBUD is not set
+# CONFIG_ZSMALLOC is not set
+# CONFIG_IDLE_PAGE_TRACKING is not set
+# CONFIG_PERCPU_STATS is not set
+# CONFIG_GUP_BENCHMARK is not set
+CONFIG_ARCH_HAS_PTE_SPECIAL=y
+# end of Memory Management options
+
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_PACKET_DIAG=y
+CONFIG_UNIX=y
+CONFIG_UNIX_SCM=y
+# CONFIG_UNIX_DIAG is not set
+# CONFIG_TLS is not set
+# CONFIG_XFRM_USER is not set
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+CONFIG_IP_PNP_RARP=y
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE_DEMUX is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_NET_IPVTI is not set
+# CONFIG_NET_FOU is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+CONFIG_INET_UDP_DIAG=y
+CONFIG_INET_RAW_DIAG=y
+# CONFIG_INET_DIAG_DESTROY is not set
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+# CONFIG_IPV6 is not set
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETWORK_PHY_TIMESTAMPING is not set
+# CONFIG_NETFILTER is not set
+# CONFIG_BPFILTER is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_RDS is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_L2TP is not set
+# CONFIG_BRIDGE is not set
+CONFIG_HAVE_NET_DSA=y
+# CONFIG_NET_DSA is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_PHONET is not set
+# CONFIG_IEEE802154 is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_DCB is not set
+CONFIG_DNS_RESOLVER=y
+# CONFIG_BATMAN_ADV is not set
+# CONFIG_OPENVSWITCH is not set
+# CONFIG_VSOCKETS is not set
+# CONFIG_NETLINK_DIAG is not set
+# CONFIG_MPLS is not set
+# CONFIG_NET_NSH is not set
+# CONFIG_HSR is not set
+# CONFIG_NET_SWITCHDEV is not set
+# CONFIG_NET_L3_MASTER_DEV is not set
+# CONFIG_NET_NCSI is not set
+CONFIG_RPS=y
+CONFIG_RFS_ACCEL=y
+CONFIG_XPS=y
+CONFIG_NET_RX_BUSY_POLL=y
+CONFIG_BQL=y
+# CONFIG_BPF_JIT is not set
+CONFIG_NET_FLOW_LIMIT=y
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# end of Network testing
+# end of Networking options
+
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+# CONFIG_AF_KCM is not set
+# CONFIG_WIRELESS is not set
+# CONFIG_WIMAX is not set
+# CONFIG_RFKILL is not set
+# CONFIG_NET_9P is not set
+# CONFIG_CAIF is not set
+# CONFIG_CEPH_LIB is not set
+# CONFIG_NFC is not set
+# CONFIG_PSAMPLE is not set
+# CONFIG_NET_IFE is not set
+# CONFIG_LWTUNNEL is not set
+# CONFIG_FAILOVER is not set
+CONFIG_HAVE_EBPF_JIT=y
+
+#
+# Device Drivers
+#
+CONFIG_HAVE_PCI=y
+# CONFIG_PCI is not set
+# CONFIG_PCCARD is not set
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER=y
+CONFIG_UEVENT_HELPER_PATH=""
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+
+#
+# Firmware loader
+#
+CONFIG_FW_LOADER=y
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_FW_LOADER_USER_HELPER is not set
+# CONFIG_FW_LOADER_COMPRESS is not set
+# end of Firmware loader
+
+CONFIG_ALLOW_DEV_COREDUMP=y
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_DEBUG_TEST_DRIVER_REMOVE is not set
+# CONFIG_TEST_ASYNC_DRIVER_PROBE is not set
+CONFIG_GENERIC_CPU_DEVICES=y
+CONFIG_GENERIC_ARCH_TOPOLOGY=y
+# end of Generic Driver Options
+
+#
+# Bus devices
+#
+# CONFIG_MOXTET is not set
+# end of Bus devices
+
+# CONFIG_CONNECTOR is not set
+# CONFIG_GNSS is not set
+# CONFIG_MTD is not set
+CONFIG_DTC=y
+CONFIG_OF=y
+# CONFIG_OF_UNITTEST is not set
+CONFIG_OF_FLATTREE=y
+CONFIG_OF_EARLY_FLATTREE=y
+CONFIG_OF_KOBJ=y
+CONFIG_OF_ADDRESS=y
+CONFIG_OF_IRQ=y
+CONFIG_OF_NET=y
+CONFIG_OF_MDIO=y
+CONFIG_OF_RESERVED_MEM=y
+# CONFIG_OF_OVERLAY is not set
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_NULL_BLK is not set
+# CONFIG_BLK_DEV_LOOP is not set
+# CONFIG_BLK_DEV_DRBD is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_RAM is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_BLK_DEV_RBD is not set
+
+#
+# NVME Support
+#
+# CONFIG_NVME_FC is not set
+# CONFIG_NVME_TARGET is not set
+# end of NVME Support
+
+#
+# Misc devices
+#
+# CONFIG_AD525X_DPOT is not set
+# CONFIG_DUMMY_IRQ is not set
+# CONFIG_ICS932S401 is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_APDS9802ALS is not set
+# CONFIG_ISL29003 is not set
+# CONFIG_ISL29020 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_SENSORS_BH1770 is not set
+# CONFIG_SENSORS_APDS990X is not set
+# CONFIG_HMC6352 is not set
+# CONFIG_DS1682 is not set
+# CONFIG_LATTICE_ECP3_CONFIG is not set
+# CONFIG_SRAM is not set
+# CONFIG_XILINX_SDFEC is not set
+# CONFIG_PVPANIC is not set
+# CONFIG_C2PORT is not set
+
+#
+# EEPROM support
+#
+# CONFIG_EEPROM_AT24 is not set
+# CONFIG_EEPROM_AT25 is not set
+# CONFIG_EEPROM_LEGACY is not set
+# CONFIG_EEPROM_MAX6875 is not set
+# CONFIG_EEPROM_93CX6 is not set
+# CONFIG_EEPROM_93XX46 is not set
+# CONFIG_EEPROM_IDT_89HPESX is not set
+# CONFIG_EEPROM_EE1004 is not set
+# end of EEPROM support
+
+#
+# Texas Instruments shared transport line discipline
+#
+# CONFIG_TI_ST is not set
+# end of Texas Instruments shared transport line discipline
+
+# CONFIG_ALTERA_STAPL is not set
+
+#
+# Intel MIC & related support
+#
+
+#
+# Intel MIC Bus Driver
+#
+
+#
+# SCIF Bus Driver
+#
+
+#
+# VOP Bus Driver
+#
+# CONFIG_VOP_BUS is not set
+
+#
+# Intel MIC Host Driver
+#
+
+#
+# Intel MIC Card Driver
+#
+
+#
+# SCIF Driver
+#
+
+#
+# Intel MIC Coprocessor State Management (COSM) Drivers
+#
+
+#
+# VOP Driver
+#
+# end of Intel MIC & related support
+
+# CONFIG_ECHO is not set
+# end of Misc devices
+
+#
+# SCSI device support
+#
+CONFIG_SCSI_MOD=y
+# CONFIG_RAID_ATTRS is not set
+# CONFIG_SCSI is not set
+# end of SCSI device support
+
+# CONFIG_ATA is not set
+# CONFIG_MD is not set
+# CONFIG_TARGET_CORE is not set
+CONFIG_NETDEVICES=y
+CONFIG_NET_CORE=y
+# CONFIG_BONDING is not set
+# CONFIG_DUMMY is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_NET_TEAM is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_IPVLAN is not set
+# CONFIG_VXLAN is not set
+# CONFIG_GENEVE is not set
+# CONFIG_GTP is not set
+# CONFIG_MACSEC is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_TUN is not set
+# CONFIG_TUN_VNET_CROSS_LE is not set
+# CONFIG_VETH is not set
+# CONFIG_NLMON is not set
+
+#
+# CAIF transport drivers
+#
+
+#
+# Distributed Switch Architecture drivers
+#
+# end of Distributed Switch Architecture drivers
+
+CONFIG_ETHERNET=y
+# CONFIG_NET_VENDOR_ALACRITECH is not set
+# CONFIG_ALTERA_TSE is not set
+# CONFIG_NET_VENDOR_AMAZON is not set
+# CONFIG_NET_VENDOR_AQUANTIA is not set
+# CONFIG_NET_VENDOR_ARC is not set
+# CONFIG_NET_VENDOR_AURORA is not set
+# CONFIG_NET_VENDOR_BROADCOM is not set
+# CONFIG_NET_VENDOR_CADENCE is not set
+# CONFIG_NET_VENDOR_CAVIUM is not set
+# CONFIG_NET_VENDOR_CORTINA is not set
+# CONFIG_CDAC_ENET is not set
+CONFIG_NET_CDAC_ERMAC=y
+# CONFIG_DNET is not set
+# CONFIG_NET_VENDOR_EZCHIP is not set
+# CONFIG_NET_VENDOR_GOOGLE is not set
+# CONFIG_NET_VENDOR_HUAWEI is not set
+# CONFIG_NET_VENDOR_INTEL is not set
+CONFIG_NET_VENDOR_MARVELL=y
+# CONFIG_MVMDIO is not set
+CONFIG_NET_VENDOR_MELLANOX=y
+# CONFIG_MLXSW_CORE is not set
+# CONFIG_MLXFW is not set
+# CONFIG_NET_VENDOR_MICREL is not set
+# CONFIG_NET_VENDOR_MICROCHIP is not set
+# CONFIG_NET_VENDOR_MICROSEMI is not set
+# CONFIG_NET_VENDOR_NATSEMI is not set
+# CONFIG_NET_VENDOR_NETRONOME is not set
+# CONFIG_NET_VENDOR_NI is not set
+# CONFIG_ETHOC is not set
+# CONFIG_NET_VENDOR_PENSANDO is not set
+# CONFIG_NET_VENDOR_QUALCOMM is not set
+# CONFIG_NET_VENDOR_RENESAS is not set
+# CONFIG_NET_VENDOR_ROCKER is not set
+# CONFIG_NET_VENDOR_SAMSUNG is not set
+# CONFIG_NET_VENDOR_SEEQ is not set
+# CONFIG_NET_VENDOR_SOLARFLARE is not set
+# CONFIG_NET_VENDOR_SOCIONEXT is not set
+# CONFIG_NET_VENDOR_STMICRO is not set
+# CONFIG_NET_VENDOR_SYNOPSYS is not set
+# CONFIG_NET_VENDOR_VIA is not set
+# CONFIG_NET_VENDOR_WIZNET is not set
+CONFIG_MDIO_DEVICE=y
+CONFIG_MDIO_BUS=y
+# CONFIG_MDIO_BCM_UNIMAC is not set
+# CONFIG_MDIO_BITBANG is not set
+# CONFIG_MDIO_BUS_MUX_GPIO is not set
+# CONFIG_MDIO_BUS_MUX_MMIOREG is not set
+# CONFIG_MDIO_BUS_MUX_MULTIPLEXER is not set
+# CONFIG_MDIO_HISI_FEMAC is not set
+# CONFIG_MDIO_MSCC_MIIM is not set
+# CONFIG_MDIO_OCTEON is not set
+CONFIG_PHYLIB=y
+CONFIG_SWPHY=y
+
+#
+# MII PHY device drivers
+#
+# CONFIG_ADIN_PHY is not set
+# CONFIG_AMD_PHY is not set
+# CONFIG_AQUANTIA_PHY is not set
+# CONFIG_AX88796B_PHY is not set
+# CONFIG_AT803X_PHY is not set
+# CONFIG_BCM7XXX_PHY is not set
+# CONFIG_BCM87XX_PHY is not set
+# CONFIG_BROADCOM_PHY is not set
+# CONFIG_CICADA_PHY is not set
+# CONFIG_CORTINA_PHY is not set
+# CONFIG_DAVICOM_PHY is not set
+# CONFIG_DP83822_PHY is not set
+# CONFIG_DP83TC811_PHY is not set
+CONFIG_DP83848_PHY=y
+CONFIG_DP83867_PHY=y
+CONFIG_FIXED_PHY=y
+# CONFIG_ICPLUS_PHY is not set
+# CONFIG_INTEL_XWAY_PHY is not set
+# CONFIG_LSI_ET1011C_PHY is not set
+# CONFIG_LXT_PHY is not set
+CONFIG_MARVELL_PHY=y
+# CONFIG_MARVELL_10G_PHY is not set
+# CONFIG_MICREL_PHY is not set
+# CONFIG_MICROCHIP_PHY is not set
+# CONFIG_MICROCHIP_T1_PHY is not set
+# CONFIG_MICROSEMI_PHY is not set
+# CONFIG_NATIONAL_PHY is not set
+# CONFIG_QSEMI_PHY is not set
+# CONFIG_REALTEK_PHY is not set
+# CONFIG_RENESAS_PHY is not set
+# CONFIG_ROCKCHIP_PHY is not set
+# CONFIG_SMSC_PHY is not set
+# CONFIG_STE10XP is not set
+# CONFIG_TERANETICS_PHY is not set
+# CONFIG_VITESSE_PHY is not set
+# CONFIG_XILINX_GMII2RGMII is not set
+# CONFIG_MICREL_KS8995MA is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+
+#
+# Host-side USB support is needed for USB Network Adapter support
+#
+# CONFIG_WLAN is not set
+
+#
+# Enable WiMAX (Networking options) to see the WiMAX drivers
+#
+# CONFIG_WAN is not set
+# CONFIG_NETDEVSIM is not set
+# CONFIG_NET_FAILOVER is not set
+# CONFIG_ISDN is not set
+# CONFIG_NVM is not set
+
+#
+# Input device support
+#
+# CONFIG_INPUT is not set
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+# end of Hardware I/O ports
+# end of Input device support
+
+#
+# Character devices
+#
+CONFIG_TTY=y
+# CONFIG_VT is not set
+CONFIG_UNIX98_PTYS=y
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_N_GSM is not set
+# CONFIG_TRACE_SINK is not set
+# CONFIG_NULL_TTY is not set
+CONFIG_LDISC_AUTOLOAD=y
+CONFIG_DEVMEM=y
+CONFIG_DEVKMEM=y
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_8250=y
+# CONFIG_SERIAL_8250_DEPRECATED_OPTIONS is not set
+# CONFIG_SERIAL_8250_FINTEK is not set
+# CONFIG_SERIAL_8250_CONSOLE is not set
+CONFIG_SERIAL_8250_NR_UARTS=4
+CONFIG_SERIAL_8250_RUNTIME_UARTS=4
+# CONFIG_SERIAL_8250_EXTENDED is not set
+# CONFIG_SERIAL_8250_ASPEED_VUART is not set
+# CONFIG_SERIAL_8250_DW is not set
+# CONFIG_SERIAL_8250_RT288X is not set
+# CONFIG_SERIAL_OF_PLATFORM is not set
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_EARLYCON_RISCV_SBI is not set
+# CONFIG_SERIAL_MAX3100 is not set
+# CONFIG_SERIAL_MAX310X is not set
+# CONFIG_SERIAL_UARTLITE is not set
+CONFIG_SERIAL_CORE=y
+# CONFIG_SERIAL_SIFIVE is not set
+# CONFIG_SERIAL_SCCNXP is not set
+# CONFIG_SERIAL_SC16IS7XX is not set
+# CONFIG_SERIAL_ALTERA_JTAGUART is not set
+# CONFIG_SERIAL_ALTERA_UART is not set
+# CONFIG_SERIAL_IFX6X60 is not set
+# CONFIG_SERIAL_XILINX_PS_UART is not set
+# CONFIG_SERIAL_ARC is not set
+# CONFIG_SERIAL_FSL_LPUART is not set
+# CONFIG_SERIAL_FSL_LINFLEXUART is not set
+# CONFIG_SERIAL_CONEXANT_DIGICOLOR is not set
+# end of Serial drivers
+
+CONFIG_SERIAL_MCTRL_GPIO=y
+# CONFIG_SERIAL_DEV_BUS is not set
+# CONFIG_TTY_PRINTK is not set
+CONFIG_HVC_DRIVER=y
+CONFIG_HVC_RISCV_SBI=y
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_HW_RANDOM is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+# CONFIG_XILLYBUS is not set
+# end of Character devices
+
+# CONFIG_RANDOM_TRUST_BOOTLOADER is not set
+
+#
+# I2C support
+#
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_COMPAT=y
+CONFIG_I2C_CHARDEV=y
+# CONFIG_I2C_MUX is not set
+CONFIG_I2C_HELPER_AUTO=y
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+CONFIG_I2C_CDAC=y
+# CONFIG_I2C_CBUS_GPIO is not set
+# CONFIG_I2C_DESIGNWARE_PLATFORM is not set
+# CONFIG_I2C_EMEV2 is not set
+# CONFIG_I2C_GPIO is not set
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_PCA_PLATFORM is not set
+# CONFIG_I2C_RK3X is not set
+# CONFIG_I2C_SIMTEC is not set
+# CONFIG_I2C_XILINX is not set
+
+#
+# External I2C/SMBus adapter drivers
+#
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_TAOS_EVM is not set
+
+#
+# Other I2C/SMBus bus drivers
+#
+# end of I2C Hardware Bus support
+
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_SLAVE is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# end of I2C support
+
+# CONFIG_I3C is not set
+CONFIG_SPI=y
+# CONFIG_SPI_DEBUG is not set
+CONFIG_SPI_MASTER=y
+# CONFIG_SPI_MEM is not set
+
+#
+# SPI Master Controller Drivers
+#
+# CONFIG_SPI_ALTERA is not set
+# CONFIG_SPI_AXI_SPI_ENGINE is not set
+# CONFIG_SPI_BITBANG is not set
+# CONFIG_SPI_CADENCE is not set
+CONFIG_SPI_CDAC=y
+# CONFIG_SPI_DESIGNWARE is not set
+# CONFIG_SPI_NXP_FLEXSPI is not set
+# CONFIG_SPI_GPIO is not set
+# CONFIG_SPI_FSL_SPI is not set
+# CONFIG_SPI_OC_TINY is not set
+# CONFIG_SPI_ROCKCHIP is not set
+# CONFIG_SPI_SC18IS602 is not set
+# CONFIG_SPI_SIFIVE is not set
+# CONFIG_SPI_MXIC is not set
+# CONFIG_SPI_XCOMM is not set
+# CONFIG_SPI_XILINX is not set
+# CONFIG_SPI_ZYNQMP_GQSPI is not set
+
+#
+# SPI Protocol Masters
+#
+CONFIG_SPI_SPIDEV=y
+# CONFIG_SPI_LOOPBACK_TEST is not set
+# CONFIG_SPI_TLE62X0 is not set
+# CONFIG_SPI_SLAVE is not set
+# CONFIG_SPMI is not set
+# CONFIG_HSI is not set
+# CONFIG_PPS is not set
+
+#
+# PTP clock support
+#
+# CONFIG_PTP_1588_CLOCK is not set
+
+#
+# Enable PHYLIB and NETWORK_PHY_TIMESTAMPING to see the additional clocks.
+#
+# end of PTP clock support
+
+# CONFIG_PINCTRL is not set
+CONFIG_GPIOLIB=y
+CONFIG_GPIOLIB_FASTPATH_LIMIT=512
+CONFIG_OF_GPIO=y
+# CONFIG_DEBUG_GPIO is not set
+CONFIG_GPIO_SYSFS=y
+CONFIG_GPIO_GENERIC=y
+
+#
+# Memory mapped GPIO drivers
+#
+# CONFIG_GPIO_74XX_MMIO is not set
+CONFIG_GPIO_CDAC=y
+# CONFIG_GPIO_ALTERA is not set
+# CONFIG_GPIO_CADENCE is not set
+# CONFIG_GPIO_DWAPB is not set
+# CONFIG_GPIO_FTGPIO010 is not set
+# CONFIG_GPIO_GENERIC_PLATFORM is not set
+# CONFIG_GPIO_GRGPIO is not set
+# CONFIG_GPIO_HLWD is not set
+# CONFIG_GPIO_MB86S7X is not set
+# CONFIG_GPIO_XILINX is not set
+# CONFIG_GPIO_AMD_FCH is not set
+# end of Memory mapped GPIO drivers
+
+#
+# I2C GPIO expanders
+#
+# CONFIG_GPIO_ADP5588 is not set
+# CONFIG_GPIO_ADNP is not set
+# CONFIG_GPIO_GW_PLD is not set
+# CONFIG_GPIO_MAX7300 is not set
+# CONFIG_GPIO_MAX732X is not set
+# CONFIG_GPIO_PCA953X is not set
+# CONFIG_GPIO_PCF857X is not set
+# CONFIG_GPIO_TPIC2810 is not set
+# end of I2C GPIO expanders
+
+#
+# MFD GPIO expanders
+#
+# end of MFD GPIO expanders
+
+#
+# SPI GPIO expanders
+#
+# CONFIG_GPIO_74X164 is not set
+# CONFIG_GPIO_MAX3191X is not set
+# CONFIG_GPIO_MAX7301 is not set
+# CONFIG_GPIO_MC33880 is not set
+# CONFIG_GPIO_PISOSR is not set
+# CONFIG_GPIO_XRA1403 is not set
+# end of SPI GPIO expanders
+
+# CONFIG_GPIO_MOCKUP is not set
+# CONFIG_W1 is not set
+# CONFIG_POWER_AVS is not set
+# CONFIG_POWER_RESET is not set
+# CONFIG_POWER_SUPPLY is not set
+# CONFIG_HWMON is not set
+# CONFIG_THERMAL is not set
+# CONFIG_WATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+# CONFIG_SSB is not set
+CONFIG_BCMA_POSSIBLE=y
+# CONFIG_BCMA is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_ACT8945A is not set
+# CONFIG_MFD_AS3711 is not set
+# CONFIG_MFD_AS3722 is not set
+# CONFIG_PMIC_ADP5520 is not set
+# CONFIG_MFD_AAT2870_CORE is not set
+# CONFIG_MFD_ATMEL_FLEXCOM is not set
+# CONFIG_MFD_ATMEL_HLCDC is not set
+# CONFIG_MFD_BCM590XX is not set
+# CONFIG_MFD_BD9571MWV is not set
+# CONFIG_MFD_AXP20X_I2C is not set
+# CONFIG_MFD_MADERA is not set
+# CONFIG_PMIC_DA903X is not set
+# CONFIG_MFD_DA9052_SPI is not set
+# CONFIG_MFD_DA9052_I2C is not set
+# CONFIG_MFD_DA9055 is not set
+# CONFIG_MFD_DA9062 is not set
+# CONFIG_MFD_DA9063 is not set
+# CONFIG_MFD_DA9150 is not set
+# CONFIG_MFD_MC13XXX_SPI is not set
+# CONFIG_MFD_MC13XXX_I2C is not set
+# CONFIG_MFD_HI6421_PMIC is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_HTC_I2CPLD is not set
+# CONFIG_MFD_KEMPLD is not set
+# CONFIG_MFD_88PM800 is not set
+# CONFIG_MFD_88PM805 is not set
+# CONFIG_MFD_88PM860X is not set
+# CONFIG_MFD_MAX14577 is not set
+# CONFIG_MFD_MAX77620 is not set
+# CONFIG_MFD_MAX77650 is not set
+# CONFIG_MFD_MAX77686 is not set
+# CONFIG_MFD_MAX77693 is not set
+# CONFIG_MFD_MAX77843 is not set
+# CONFIG_MFD_MAX8907 is not set
+# CONFIG_MFD_MAX8925 is not set
+# CONFIG_MFD_MAX8997 is not set
+# CONFIG_MFD_MAX8998 is not set
+# CONFIG_MFD_MT6397 is not set
+# CONFIG_MFD_MENF21BMC is not set
+# CONFIG_EZX_PCAP is not set
+# CONFIG_MFD_CPCAP is not set
+# CONFIG_MFD_RETU is not set
+# CONFIG_MFD_PCF50633 is not set
+# CONFIG_MFD_RT5033 is not set
+# CONFIG_MFD_RC5T583 is not set
+# CONFIG_MFD_RK808 is not set
+# CONFIG_MFD_RN5T618 is not set
+# CONFIG_MFD_SEC_CORE is not set
+# CONFIG_MFD_SI476X_CORE is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_MFD_SKY81452 is not set
+# CONFIG_MFD_SMSC is not set
+# CONFIG_ABX500_CORE is not set
+# CONFIG_MFD_STMPE is not set
+# CONFIG_MFD_SYSCON is not set
+# CONFIG_MFD_TI_AM335X_TSCADC is not set
+# CONFIG_MFD_LP3943 is not set
+# CONFIG_MFD_LP8788 is not set
+# CONFIG_MFD_TI_LMU is not set
+# CONFIG_MFD_PALMAS is not set
+# CONFIG_TPS6105X is not set
+# CONFIG_TPS65010 is not set
+# CONFIG_TPS6507X is not set
+# CONFIG_MFD_TPS65086 is not set
+# CONFIG_MFD_TPS65090 is not set
+# CONFIG_MFD_TPS65217 is not set
+# CONFIG_MFD_TI_LP873X is not set
+# CONFIG_MFD_TI_LP87565 is not set
+# CONFIG_MFD_TPS65218 is not set
+# CONFIG_MFD_TPS6586X is not set
+# CONFIG_MFD_TPS65910 is not set
+# CONFIG_MFD_TPS65912_I2C is not set
+# CONFIG_MFD_TPS65912_SPI is not set
+# CONFIG_MFD_TPS80031 is not set
+# CONFIG_TWL4030_CORE is not set
+# CONFIG_TWL6040_CORE is not set
+# CONFIG_MFD_WL1273_CORE is not set
+# CONFIG_MFD_LM3533 is not set
+# CONFIG_MFD_TC3589X is not set
+# CONFIG_MFD_TQMX86 is not set
+# CONFIG_MFD_LOCHNAGAR is not set
+# CONFIG_MFD_ARIZONA_I2C is not set
+# CONFIG_MFD_ARIZONA_SPI is not set
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM831X_I2C is not set
+# CONFIG_MFD_WM831X_SPI is not set
+# CONFIG_MFD_WM8350_I2C is not set
+# CONFIG_MFD_WM8994 is not set
+# CONFIG_MFD_ROHM_BD718XX is not set
+# CONFIG_MFD_ROHM_BD70528 is not set
+# CONFIG_MFD_STPMIC1 is not set
+# CONFIG_MFD_STMFX is not set
+# end of Multifunction device drivers
+
+# CONFIG_REGULATOR is not set
+# CONFIG_MEDIA_SUPPORT is not set
+
+#
+# Graphics support
+#
+# CONFIG_DRM is not set
+# CONFIG_DRM_DP_CEC is not set
+
+#
+# ARM devices
+#
+# end of ARM devices
+
+#
+# ACP (Audio CoProcessor) Configuration
+#
+# end of ACP (Audio CoProcessor) Configuration
+
+#
+# Frame buffer Devices
+#
+# CONFIG_FB is not set
+# end of Frame buffer Devices
+
+#
+# Backlight & LCD device support
+#
+# CONFIG_LCD_CLASS_DEVICE is not set
+# CONFIG_BACKLIGHT_CLASS_DEVICE is not set
+# end of Backlight & LCD device support
+# end of Graphics support
+
+# CONFIG_SOUND is not set
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+# CONFIG_USB_SUPPORT is not set
+# CONFIG_MMC is not set
+# CONFIG_MEMSTICK is not set
+# CONFIG_NEW_LEDS is not set
+# CONFIG_ACCESSIBILITY is not set
+# CONFIG_INFINIBAND is not set
+CONFIG_EDAC_SUPPORT=y
+# CONFIG_RTC_CLASS is not set
+# CONFIG_DMADEVICES is not set
+
+#
+# DMABUF options
+#
+# CONFIG_SYNC_FILE is not set
+# end of DMABUF options
+
+# CONFIG_AUXDISPLAY is not set
+# CONFIG_UIO is not set
+# CONFIG_VIRT_DRIVERS is not set
+# CONFIG_VIRTIO_MENU is not set
+
+#
+# Microsoft Hyper-V guest support
+#
+# end of Microsoft Hyper-V guest support
+
+# CONFIG_GREYBUS is not set
+# CONFIG_STAGING is not set
+CONFIG_CLKDEV_LOOKUP=y
+CONFIG_HAVE_CLK_PREPARE=y
+CONFIG_COMMON_CLK=y
+
+#
+# Common Clock Framework
+#
+# CONFIG_CLK_HSDK is not set
+# CONFIG_COMMON_CLK_MAX9485 is not set
+# CONFIG_COMMON_CLK_SI5341 is not set
+# CONFIG_COMMON_CLK_SI5351 is not set
+# CONFIG_COMMON_CLK_SI514 is not set
+# CONFIG_COMMON_CLK_SI544 is not set
+# CONFIG_COMMON_CLK_SI570 is not set
+# CONFIG_COMMON_CLK_CDCE706 is not set
+# CONFIG_COMMON_CLK_CDCE925 is not set
+# CONFIG_COMMON_CLK_CS2000_CP is not set
+# CONFIG_COMMON_CLK_VC5 is not set
+CONFIG_COMMON_CLK_FIXED_MMIO=y
+# CONFIG_CLK_SIFIVE is not set
+# end of Common Clock Framework
+
+# CONFIG_HWSPINLOCK is not set
+
+#
+# Clock Source drivers
+#
+CONFIG_TIMER_OF=y
+CONFIG_TIMER_PROBE=y
+CONFIG_RISCV_TIMER=y
+# end of Clock Source drivers
+
+# CONFIG_MAILBOX is not set
+# CONFIG_IOMMU_SUPPORT is not set
+
+#
+# Remoteproc drivers
+#
+# CONFIG_REMOTEPROC is not set
+# end of Remoteproc drivers
+
+#
+# Rpmsg drivers
+#
+# CONFIG_RPMSG_VIRTIO is not set
+# end of Rpmsg drivers
+
+# CONFIG_SOUNDWIRE is not set
+
+#
+# SOC (System On Chip) specific Drivers
+#
+
+#
+# Amlogic SoC drivers
+#
+# end of Amlogic SoC drivers
+
+#
+# Aspeed SoC drivers
+#
+# end of Aspeed SoC drivers
+
+#
+# Broadcom SoC drivers
+#
+# end of Broadcom SoC drivers
+
+#
+# NXP/Freescale QorIQ SoC drivers
+#
+# end of NXP/Freescale QorIQ SoC drivers
+
+#
+# i.MX SoC drivers
+#
+# end of i.MX SoC drivers
+
+#
+# Qualcomm SoC drivers
+#
+# end of Qualcomm SoC drivers
+
+# CONFIG_SOC_TI is not set
+
+#
+# Xilinx SoC drivers
+#
+# CONFIG_XILINX_VCU is not set
+# end of Xilinx SoC drivers
+# end of SOC (System On Chip) specific Drivers
+
+# CONFIG_PM_DEVFREQ is not set
+# CONFIG_EXTCON is not set
+# CONFIG_MEMORY is not set
+# CONFIG_IIO is not set
+# CONFIG_PWM is not set
+
+#
+# IRQ chip support
+#
+CONFIG_IRQCHIP=y
+# CONFIG_AL_FIC is not set
+# end of IRQ chip support
+
+# CONFIG_RISCV_INTC is not set
+# CONFIG_SIFIVE_PLIC is not set
+# CONFIG_CDAC_PLIC is not set
+CONFIG_CDAC_SIC=y
+# CONFIG_IPACK_BUS is not set
+# CONFIG_RESET_CONTROLLER is not set
+
+#
+# PHY Subsystem
+#
+# CONFIG_GENERIC_PHY is not set
+# CONFIG_BCM_KONA_USB2_PHY is not set
+# CONFIG_PHY_CADENCE_DP is not set
+# CONFIG_PHY_CADENCE_DPHY is not set
+# CONFIG_PHY_FSL_IMX8MQ_USB is not set
+# CONFIG_PHY_MIXEL_MIPI_DPHY is not set
+# CONFIG_PHY_PXA_28NM_HSIC is not set
+# CONFIG_PHY_PXA_28NM_USB2 is not set
+# end of PHY Subsystem
+
+# CONFIG_POWERCAP is not set
+# CONFIG_MCB is not set
+# CONFIG_RAS is not set
+
+#
+# Android
+#
+# CONFIG_ANDROID is not set
+# end of Android
+
+# CONFIG_LIBNVDIMM is not set
+# CONFIG_DAX is not set
+# CONFIG_NVMEM is not set
+
+#
+# HW tracing support
+#
+# CONFIG_STM is not set
+# CONFIG_INTEL_TH is not set
+# end of HW tracing support
+
+# CONFIG_FPGA is not set
+# CONFIG_FSI is not set
+# CONFIG_SIOX is not set
+# CONFIG_SLIMBUS is not set
+# CONFIG_INTERCONNECT is not set
+# CONFIG_COUNTER is not set
+# end of Device Drivers
+
+#
+# File systems
+#
+# CONFIG_VALIDATE_FS_PARSER is not set
+# CONFIG_EXT2_FS is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_EXT4_FS is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_BTRFS_FS is not set
+# CONFIG_NILFS2_FS is not set
+# CONFIG_F2FS_FS is not set
+# CONFIG_FS_DAX is not set
+CONFIG_FS_POSIX_ACL=y
+# CONFIG_EXPORTFS_BLOCK_OPS is not set
+CONFIG_FILE_LOCKING=y
+CONFIG_MANDATORY_FILE_LOCKING=y
+# CONFIG_FS_ENCRYPTION is not set
+# CONFIG_FS_VERITY is not set
+CONFIG_FSNOTIFY=y
+# CONFIG_DNOTIFY is not set
+CONFIG_INOTIFY_USER=y
+# CONFIG_FANOTIFY is not set
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_FUSE_FS is not set
+# CONFIG_OVERLAY_FS is not set
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+# end of Caches
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+# end of CD-ROM/DVD Filesystems
+
+#
+# DOS/FAT/NT Filesystems
+#
+# CONFIG_MSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_NTFS_FS is not set
+# end of DOS/FAT/NT Filesystems
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+# CONFIG_PROC_KCORE is not set
+CONFIG_PROC_SYSCTL=y
+# CONFIG_PROC_PAGE_MONITOR is not set
+# CONFIG_PROC_CHILDREN is not set
+CONFIG_KERNFS=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_TMPFS_XATTR=y
+# CONFIG_HUGETLBFS is not set
+CONFIG_MEMFD_CREATE=y
+CONFIG_ARCH_HAS_GIGANTIC_PAGE=y
+CONFIG_CONFIGFS_FS=y
+# end of Pseudo filesystems
+
+# CONFIG_MISC_FILESYSTEMS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V2=y
+CONFIG_NFS_V3=y
+CONFIG_NFS_V3_ACL=y
+CONFIG_NFS_V4=y
+CONFIG_NFS_SWAP=y
+# CONFIG_NFS_V4_1 is not set
+CONFIG_ROOT_NFS=y
+# CONFIG_NFS_USE_LEGACY_DNS is not set
+CONFIG_NFS_USE_KERNEL_DNS=y
+# CONFIG_NFSD is not set
+CONFIG_GRACE_PERIOD=y
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_ACL_SUPPORT=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+CONFIG_SUNRPC_GSS=y
+CONFIG_SUNRPC_SWAP=y
+# CONFIG_SUNRPC_DEBUG is not set
+# CONFIG_CEPH_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+# CONFIG_NLS is not set
+# CONFIG_DLM is not set
+# CONFIG_UNICODE is not set
+# end of File systems
+
+#
+# Security options
+#
+CONFIG_KEYS=y
+# CONFIG_KEYS_REQUEST_CACHE is not set
+# CONFIG_PERSISTENT_KEYRINGS is not set
+# CONFIG_BIG_KEYS is not set
+# CONFIG_ENCRYPTED_KEYS is not set
+# CONFIG_KEY_DH_OPERATIONS is not set
+# CONFIG_SECURITY_DMESG_RESTRICT is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+CONFIG_HAVE_HARDENED_USERCOPY_ALLOCATOR=y
+# CONFIG_HARDENED_USERCOPY is not set
+# CONFIG_STATIC_USERMODEHELPER is not set
+CONFIG_DEFAULT_SECURITY_DAC=y
+CONFIG_LSM="lockdown,yama,loadpin,safesetid,integrity"
+
+#
+# Kernel hardening options
+#
+
+#
+# Memory initialization
+#
+CONFIG_INIT_STACK_NONE=y
+# CONFIG_INIT_ON_ALLOC_DEFAULT_ON is not set
+# CONFIG_INIT_ON_FREE_DEFAULT_ON is not set
+# end of Memory initialization
+# end of Kernel hardening options
+# end of Security options
+
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD=y
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG=y
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_RNG_DEFAULT=y
+CONFIG_CRYPTO_AKCIPHER2=y
+CONFIG_CRYPTO_AKCIPHER=y
+CONFIG_CRYPTO_KPP2=y
+CONFIG_CRYPTO_ACOMP2=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
+# CONFIG_CRYPTO_USER is not set
+CONFIG_CRYPTO_MANAGER_DISABLE_TESTS=y
+CONFIG_CRYPTO_NULL=y
+CONFIG_CRYPTO_NULL2=y
+# CONFIG_CRYPTO_PCRYPT is not set
+# CONFIG_CRYPTO_CRYPTD is not set
+# CONFIG_CRYPTO_AUTHENC is not set
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Public-key cryptography
+#
+CONFIG_CRYPTO_RSA=y
+# CONFIG_CRYPTO_DH is not set
+# CONFIG_CRYPTO_ECDH is not set
+# CONFIG_CRYPTO_ECRDSA is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_CHACHA20POLY1305 is not set
+# CONFIG_CRYPTO_AEGIS128 is not set
+CONFIG_CRYPTO_SEQIV=y
+CONFIG_CRYPTO_ECHAINIV=y
+
+#
+# Block modes
+#
+CONFIG_CRYPTO_CBC=y
+# CONFIG_CRYPTO_CFB is not set
+CONFIG_CRYPTO_CTR=y
+CONFIG_CRYPTO_CTS=y
+CONFIG_CRYPTO_ECB=y
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_OFB is not set
+# CONFIG_CRYPTO_PCBC is not set
+CONFIG_CRYPTO_XTS=y
+# CONFIG_CRYPTO_KEYWRAP is not set
+# CONFIG_CRYPTO_ADIANTUM is not set
+# CONFIG_CRYPTO_ESSIV is not set
+
+#
+# Hash modes
+#
+# CONFIG_CRYPTO_CMAC is not set
+CONFIG_CRYPTO_HMAC=y
+# CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_VMAC is not set
+
+#
+# Digest
+#
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_CRC32 is not set
+# CONFIG_CRYPTO_XXHASH is not set
+# CONFIG_CRYPTO_CRCT10DIF is not set
+# CONFIG_CRYPTO_GHASH is not set
+# CONFIG_CRYPTO_POLY1305 is not set
+# CONFIG_CRYPTO_MD4 is not set
+# CONFIG_CRYPTO_MD5 is not set
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+# CONFIG_CRYPTO_SHA1 is not set
+CONFIG_CRYPTO_LIB_SHA256=y
+CONFIG_CRYPTO_SHA256=y
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_SHA3 is not set
+# CONFIG_CRYPTO_SM3 is not set
+# CONFIG_CRYPTO_STREEBOG is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+CONFIG_CRYPTO_LIB_AES=y
+CONFIG_CRYPTO_AES=y
+# CONFIG_CRYPTO_AES_TI is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_DES is not set
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_CHACHA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_SM4 is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+
+#
+# Compression
+#
+# CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_LZO is not set
+# CONFIG_CRYPTO_842 is not set
+# CONFIG_CRYPTO_LZ4 is not set
+# CONFIG_CRYPTO_LZ4HC is not set
+# CONFIG_CRYPTO_ZSTD is not set
+
+#
+# Random Number Generation
+#
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+CONFIG_CRYPTO_DRBG_MENU=y
+CONFIG_CRYPTO_DRBG_HMAC=y
+# CONFIG_CRYPTO_DRBG_HASH is not set
+# CONFIG_CRYPTO_DRBG_CTR is not set
+CONFIG_CRYPTO_DRBG=y
+CONFIG_CRYPTO_JITTERENTROPY=y
+# CONFIG_CRYPTO_USER_API_HASH is not set
+# CONFIG_CRYPTO_USER_API_SKCIPHER is not set
+# CONFIG_CRYPTO_USER_API_RNG is not set
+# CONFIG_CRYPTO_USER_API_AEAD is not set
+# CONFIG_CRYPTO_HW is not set
+CONFIG_ASYMMETRIC_KEY_TYPE=y
+# CONFIG_ASYMMETRIC_PUBLIC_KEY_SUBTYPE is not set
+
+#
+# Certificates for signature checking
+#
+CONFIG_SYSTEM_TRUSTED_KEYRING=y
+CONFIG_SYSTEM_TRUSTED_KEYS=""
+# CONFIG_SYSTEM_EXTRA_CERTIFICATE is not set
+# CONFIG_SECONDARY_TRUSTED_KEYRING is not set
+# CONFIG_SYSTEM_BLACKLIST_KEYRING is not set
+# end of Certificates for signature checking
+
+#
+# Library routines
+#
+# CONFIG_PACKING is not set
+CONFIG_BITREVERSE=y
+CONFIG_GENERIC_STRNCPY_FROM_USER=y
+CONFIG_GENERIC_STRNLEN_USER=y
+CONFIG_GENERIC_NET_UTILS=y
+# CONFIG_CORDIC is not set
+CONFIG_RATIONAL=y
+CONFIG_GENERIC_PCI_IOMAP=y
+# CONFIG_CRC_CCITT is not set
+# CONFIG_CRC16 is not set
+# CONFIG_CRC_T10DIF is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC32_SELFTEST is not set
+CONFIG_CRC32_SLICEBY8=y
+# CONFIG_CRC32_SLICEBY4 is not set
+# CONFIG_CRC32_SARWATE is not set
+# CONFIG_CRC32_BIT is not set
+# CONFIG_CRC64 is not set
+# CONFIG_CRC4 is not set
+# CONFIG_CRC7 is not set
+# CONFIG_LIBCRC32C is not set
+# CONFIG_CRC8 is not set
+# CONFIG_RANDOM32_SELFTEST is not set
+CONFIG_XZ_DEC=y
+CONFIG_XZ_DEC_X86=y
+CONFIG_XZ_DEC_POWERPC=y
+CONFIG_XZ_DEC_IA64=y
+CONFIG_XZ_DEC_ARM=y
+CONFIG_XZ_DEC_ARMTHUMB=y
+CONFIG_XZ_DEC_SPARC=y
+CONFIG_XZ_DEC_BCJ=y
+# CONFIG_XZ_DEC_TEST is not set
+CONFIG_ASSOCIATIVE_ARRAY=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT_MAP=y
+CONFIG_HAS_DMA=y
+CONFIG_NEED_DMA_MAP_STATE=y
+CONFIG_ARCH_DMA_ADDR_T_64BIT=y
+CONFIG_DMA_DECLARE_COHERENT=y
+CONFIG_SWIOTLB=y
+# CONFIG_DMA_API_DEBUG is not set
+CONFIG_SGL_ALLOC=y
+CONFIG_CPU_RMAP=y
+CONFIG_DQL=y
+CONFIG_NLATTR=y
+CONFIG_CLZ_TAB=y
+# CONFIG_IRQ_POLL is not set
+CONFIG_MPILIB=y
+CONFIG_LIBFDT=y
+CONFIG_OID_REGISTRY=y
+CONFIG_SBITMAP=y
+# CONFIG_STRING_SELFTEST is not set
+# end of Library routines
+
+#
+# Kernel hacking
+#
+
+#
+# printk and dmesg options
+#
+CONFIG_PRINTK_TIME=y
+# CONFIG_PRINTK_CALLER is not set
+CONFIG_CONSOLE_LOGLEVEL_DEFAULT=8
+CONFIG_CONSOLE_LOGLEVEL_QUIET=4
+CONFIG_MESSAGE_LOGLEVEL_DEFAULT=4
+# CONFIG_BOOT_PRINTK_DELAY is not set
+# CONFIG_DYNAMIC_DEBUG is not set
+# end of printk and dmesg options
+
+#
+# Compile-time checks and compiler options
+#
+# CONFIG_DEBUG_INFO is not set
+# CONFIG_ENABLE_MUST_CHECK is not set
+CONFIG_FRAME_WARN=2048
+# CONFIG_STRIP_ASM_SYMS is not set
+# CONFIG_READABLE_ASM is not set
+CONFIG_DEBUG_FS=y
+# CONFIG_HEADERS_INSTALL is not set
+CONFIG_OPTIMIZE_INLINING=y
+# CONFIG_DEBUG_SECTION_MISMATCH is not set
+# CONFIG_SECTION_MISMATCH_WARN_ONLY is not set
+CONFIG_ARCH_WANT_FRAME_POINTERS=y
+# CONFIG_FRAME_POINTER is not set
+# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
+# end of Compile-time checks and compiler options
+
+# CONFIG_MAGIC_SYSRQ is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_MISC is not set
+
+#
+# Memory Debugging
+#
+# CONFIG_PAGE_EXTENSION is not set
+# CONFIG_DEBUG_PAGEALLOC is not set
+# CONFIG_PAGE_OWNER is not set
+# CONFIG_PAGE_POISONING is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_SLUB_DEBUG_ON is not set
+# CONFIG_SLUB_STATS is not set
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_DEBUG_VM is not set
+# CONFIG_DEBUG_MEMORY_INIT is not set
+# CONFIG_DEBUG_PER_CPU_MAPS is not set
+CONFIG_CC_HAS_KASAN_GENERIC=y
+CONFIG_KASAN_STACK=1
+# end of Memory Debugging
+
+CONFIG_CC_HAS_SANCOV_TRACE_PC=y
+# CONFIG_DEBUG_SHIRQ is not set
+
+#
+# Debug Lockups and Hangs
+#
+# CONFIG_SOFTLOCKUP_DETECTOR is not set
+# CONFIG_DETECT_HUNG_TASK is not set
+CONFIG_WQ_WATCHDOG=y
+# end of Debug Lockups and Hangs
+
+# CONFIG_PANIC_ON_OOPS is not set
+CONFIG_PANIC_ON_OOPS_VALUE=0
+CONFIG_PANIC_TIMEOUT=0
+# CONFIG_SCHED_DEBUG is not set
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_SCHED_STACK_END_CHECK is not set
+# CONFIG_DEBUG_TIMEKEEPING is not set
+
+#
+# Lock Debugging (spinlocks, mutexes, etc...)
+#
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_RWSEMS is not set
+# CONFIG_DEBUG_ATOMIC_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+# CONFIG_LOCK_TORTURE_TEST is not set
+# CONFIG_WW_MUTEX_SELFTEST is not set
+# end of Lock Debugging (spinlocks, mutexes, etc...)
+
+CONFIG_STACKTRACE=y
+# CONFIG_WARN_ALL_UNSEEDED_RANDOM is not set
+# CONFIG_DEBUG_KOBJECT is not set
+# CONFIG_DEBUG_BUGVERBOSE is not set
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_DEBUG_PLIST is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_DEBUG_NOTIFIERS is not set
+# CONFIG_DEBUG_CREDENTIALS is not set
+
+#
+# RCU Debugging
+#
+# CONFIG_RCU_PERF_TEST is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+CONFIG_RCU_CPU_STALL_TIMEOUT=21
+# CONFIG_RCU_TRACE is not set
+# CONFIG_RCU_EQS_DEBUG is not set
+# end of RCU Debugging
+
+# CONFIG_DEBUG_WQ_FORCE_RR_CPU is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_NOTIFIER_ERROR_INJECTION is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_LATENCYTOP is not set
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
+CONFIG_HAVE_DYNAMIC_FTRACE=y
+CONFIG_HAVE_DYNAMIC_FTRACE_WITH_REGS=y
+CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+CONFIG_HAVE_SYSCALL_TRACEPOINTS=y
+CONFIG_TRACING_SUPPORT=y
+# CONFIG_FTRACE is not set
+CONFIG_RUNTIME_TESTING_MENU=y
+# CONFIG_LKDTM is not set
+# CONFIG_TEST_LIST_SORT is not set
+# CONFIG_TEST_SORT is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_RBTREE_TEST is not set
+# CONFIG_REED_SOLOMON_TEST is not set
+# CONFIG_INTERVAL_TREE_TEST is not set
+# CONFIG_PERCPU_TEST is not set
+# CONFIG_ATOMIC64_SELFTEST is not set
+# CONFIG_TEST_HEXDUMP is not set
+# CONFIG_TEST_STRING_HELPERS is not set
+# CONFIG_TEST_STRSCPY is not set
+# CONFIG_TEST_KSTRTOX is not set
+# CONFIG_TEST_PRINTF is not set
+# CONFIG_TEST_BITMAP is not set
+# CONFIG_TEST_BITFIELD is not set
+# CONFIG_TEST_UUID is not set
+# CONFIG_TEST_XARRAY is not set
+# CONFIG_TEST_OVERFLOW is not set
+# CONFIG_TEST_RHASHTABLE is not set
+# CONFIG_TEST_HASH is not set
+# CONFIG_TEST_IDA is not set
+# CONFIG_TEST_LKM is not set
+# CONFIG_TEST_VMALLOC is not set
+# CONFIG_TEST_USER_COPY is not set
+# CONFIG_TEST_BPF is not set
+# CONFIG_TEST_BLACKHOLE_DEV is not set
+# CONFIG_FIND_BIT_BENCHMARK is not set
+# CONFIG_TEST_FIRMWARE is not set
+# CONFIG_TEST_SYSCTL is not set
+# CONFIG_TEST_UDELAY is not set
+# CONFIG_TEST_STATIC_KEYS is not set
+# CONFIG_TEST_KMOD is not set
+# CONFIG_TEST_MEMCAT_P is not set
+# CONFIG_TEST_STACKINIT is not set
+# CONFIG_TEST_MEMINIT is not set
+# CONFIG_MEMTEST is not set
+# CONFIG_BUG_ON_DATA_CORRUPTION is not set
+# CONFIG_SAMPLES is not set
+# CONFIG_UBSAN is not set
+CONFIG_UBSAN_ALIGNMENT=y
+# end of Kernel hacking
diff -Naur linux-5.4.1/drivers/gpio/gpio-cdac.c linux-5.4.1_modified/drivers/gpio/gpio-cdac.c
--- linux-5.4.1/drivers/gpio/gpio-cdac.c	1970-01-01 05:30:00.000000000 +0530
+++ linux-5.4.1_modified/drivers/gpio/gpio-cdac.c	2025-08-08 10:40:35.254282117 +0530
@@ -0,0 +1,149 @@
+/*
+ * CDAC GPIO driver
+ *
+ *  Copyright (C) 2020 C-DAC Thiruvananthapuram.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <linux/err.h>
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include <linux/gpio/driver.h>
+#include <linux/platform_device.h>
+
+#define NO_OF_GIPO 16
+#define MODULE_NAME "cdac-gpio"
+#define GPIO_OUT 0
+#define GPIO_IN 1
+#define GPIO_HIGH 1
+#define GPIO_LOW 0
+
+struct cdac_gpio_priv {
+	struct gpio_chip	gc;
+	void __iomem		*base;
+	unsigned		flags;
+};
+struct cdac_gpio_priv *priv;
+
+static const struct of_device_id cdac_gpio_ids[] = {
+	{
+		.compatible	= "cdac,cdac-gpio",
+	},
+	{ }
+};
+MODULE_DEVICE_TABLE(of, cdac_gpio_ids);
+
+static int cdac_get_direction(struct gpio_chip *gc, unsigned offset)
+{
+	/*
+			returns direction for signal “offset”, 0=out, 1=in, (same as GPIOF_DIR_XXX), or negative error.
+	*/
+	u16 direction_reg;
+	direction_reg = readw(priv->base + 0x40000);
+
+	if(direction_reg & (1 << (offset))){
+		return GPIO_OUT;
+	}
+	else{
+		return GPIO_IN;
+	}
+}
+
+static int cdac_direction_input(struct gpio_chip *gc, unsigned offset)
+{
+	/*
+			configures signal “offset” as input, or returns error.
+	*/
+	u16 direction_reg;
+	direction_reg = readw(priv->base + 0x40000);
+	direction_reg &= ~(1 << (offset));
+	writew(direction_reg, priv->base + 0x40000);
+	__asm__ __volatile__ ("fence");
+	return 0;
+}
+
+static int cdac_direction_output(struct gpio_chip *gc, unsigned offset, int value)
+{
+	u16 direction_reg;
+
+	direction_reg = readw(priv->base + 0x40000);
+	direction_reg |= (1 << (offset));
+	writew(direction_reg, priv->base + 0x40000);
+	__asm__ __volatile__ ("fence");
+	return 0;
+}
+
+static int cdac_get(struct gpio_chip *gc, unsigned offset)
+{
+	u16 data_reg;
+
+	data_reg = readw((unsigned long *)(((unsigned long)(priv->base))|(1 << (offset+2))));
+	if(data_reg){
+		return GPIO_HIGH;
+	}
+	else{
+		return GPIO_LOW;
+	}
+}
+
+static void cdac_set(struct gpio_chip *gc, unsigned offset, int value)
+{
+	u16 data_reg = 0;
+	if(value){
+		data_reg = 0xFFFF;
+	}
+	writew(data_reg, (unsigned long *)(((unsigned long)(priv->base))|(1 << (offset+2))));
+}
+
+static int cdac_gpio_probe(struct platform_device *pdev)
+{
+	struct resource *res;
+	int base = -1;
+
+	priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+	priv->flags = (uintptr_t)of_device_get_match_data(&pdev->dev);
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	priv->base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(priv->base))
+		return PTR_ERR(priv->base);
+
+	of_property_read_u32(pdev->dev.of_node, "gpio-base",
+				   &base);
+	if (base < 0) {
+		dev_err(&pdev->dev, "Could not read gpio-base property\n");
+		return -ENODEV;
+	}
+	writew(0x00FF, priv->base + 0x40000);
+	__asm__ __volatile__("fence");
+
+	priv->gc.get_direction = cdac_get_direction;
+	priv->gc.direction_input = cdac_direction_input;
+	priv->gc.direction_output = cdac_direction_output;
+	priv->gc.get = cdac_get;
+	priv->gc.set = cdac_set;
+	priv->gc.base = base;
+	priv->gc.ngpio = NO_OF_GIPO;
+	priv->gc.owner = THIS_MODULE;
+	priv->gc.label = MODULE_NAME;
+
+	return devm_gpiochip_add_data(&pdev->dev, &priv->gc, priv);
+}
+
+static struct platform_driver cdac_gpio_driver = {
+	.driver	= {
+		.name		= MODULE_NAME,
+		.of_match_table	= cdac_gpio_ids,
+	},
+	.probe	= cdac_gpio_probe,
+};
+module_platform_driver(cdac_gpio_driver);
+
+MODULE_DESCRIPTION("C-DAC Thiruvananthapuram GPIO driver");
+MODULE_AUTHOR("Anoop Varghese <vanoop@cdac.in>");
+MODULE_LICENSE("GPL v2");
diff -Naur linux-5.4.1/drivers/gpio/Kconfig linux-5.4.1_modified/drivers/gpio/Kconfig
--- linux-5.4.1/drivers/gpio/Kconfig	2019-11-29 14:40:32.000000000 +0530
+++ linux-5.4.1_modified/drivers/gpio/Kconfig	2025-08-08 10:40:35.254476562 +0530
@@ -96,6 +96,13 @@
 	    8 bits:	74244 (Input), 74273 (Output)
 	    16 bits:	741624 (Input), 7416374 (Output)
 
+config GPIO_CDAC
+	tristate "GPIO driver for CDAC GPIO"
+	depends on OF_GPIO
+	select GPIO_GENERIC
+	help
+	  Say yes here to support GPIO functionality for C-DAC GPIO
+
 config GPIO_ALTERA
 	tristate "Altera GPIO"
 	depends on OF_GPIO
diff -Naur linux-5.4.1/drivers/gpio/Makefile linux-5.4.1_modified/drivers/gpio/Makefile
--- linux-5.4.1/drivers/gpio/Makefile	2019-11-29 14:40:32.000000000 +0530
+++ linux-5.4.1_modified/drivers/gpio/Makefile	2025-08-08 10:40:35.439253621 +0530
@@ -22,6 +22,7 @@
 obj-$(CONFIG_GPIO_104_IDIO_16)		+= gpio-104-idio-16.o
 obj-$(CONFIG_GPIO_74X164)		+= gpio-74x164.o
 obj-$(CONFIG_GPIO_74XX_MMIO)		+= gpio-74xx-mmio.o
+obj-$(CONFIG_GPIO_CDAC)			+= gpio-cdac.o
 obj-$(CONFIG_GPIO_ADNP)			+= gpio-adnp.o
 obj-$(CONFIG_GPIO_ADP5520)		+= gpio-adp5520.o
 obj-$(CONFIG_GPIO_ADP5588)		+= gpio-adp5588.o
diff -Naur linux-5.4.1/drivers/i2c/busses/i2c-cdac.c linux-5.4.1_modified/drivers/i2c/busses/i2c-cdac.c
--- linux-5.4.1/drivers/i2c/busses/i2c-cdac.c	1970-01-01 05:30:00.000000000 +0530
+++ linux-5.4.1_modified/drivers/i2c/busses/i2c-cdac.c	2025-08-08 10:40:35.439553433 +0530
@@ -0,0 +1,508 @@
+/*
+ * CDAC master mode driver
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/clk.h>
+#include <linux/completion.h>
+#include <linux/err.h>
+#include <linux/i2c.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+
+#define DBG(f, x...) pr_debug(f, ## x)
+#define DBG1(f, x...) pr_debug(f, ## x)
+#define DBG2(f, x...) pr_debug(f, ## x)
+#define DBG3(f, x...) pr_debug(f, ## x)
+
+/* timeout waiting for the controller to respond */
+#define CDAC_I2C_TIMEOUT (msecs_to_jiffies(1000))
+
+#define CDAC_I2C_C		0x0
+#define CDAC_I2C_S		0x1
+#define CDAC_I2C_S1		0x2
+#define CDAC_I2C_IER		0x3
+#define CDAC_I2C_TXFIFO		0x4
+#define CDAC_I2C_RXFIFO		0x5
+
+#define CDAC_I2C_CHL		0x6
+#define CDAC_I2C_CHH		0x7
+#define CDAC_I2C_CHHL		0x8
+#define CDAC_I2C_CHHH		0x9
+
+#define CDAC_I2C_TXFIFO_CLR	0xa
+
+#define CDAC_I2C_TX_CLEAR	BIT(0)
+
+#define CDAC_I2C_C_ST	BIT(0)
+
+#define CDAC_I2C_IER_INTRX	BIT(2)
+#define CDAC_I2C_IER_INTGL	BIT(0)
+#define CDAC_I2C_IER_INTTX	BIT(1)
+#define CDAC_I2C_S_STOP	BIT(1)
+
+#define CDAC_I2C_S_TXW	BIT(1)
+#define CDAC_I2C_S_RXR	BIT(2)
+
+#define CDAC_I2C_S_RXC  BIT(7)
+
+#define CDAC_I2C_S_TX_FIFO_FULL		BIT(2)
+#define CDAC_I2C_S_RX_FIFO_EMPTY 	BIT(6)
+
+#define CDAC_I2C_S1_NACK BIT(0)
+
+#define CDAC_I2C_S_LEN	BIT(3) /* Fake bit for SW error reporting */
+
+struct cdac_i2c_dev {
+	struct device *dev;
+	void __iomem *regs;
+	u32 clk;
+	int irq;
+	u32 bus_clk_rate;
+	struct i2c_adapter adapter;
+	struct completion completion;
+	struct i2c_msg *curr_msg;
+	int num_msgs;
+	u32 msg_err;
+	u8 *msg_buf;
+	u8 intr_flag;
+	size_t msg_buf_remaining;
+};
+
+static int i2c_data_addr_flag=0;
+
+static inline void cdac_i2c_writeb(struct cdac_i2c_dev *i2c_dev,
+				      u32 reg, u8 val)
+{
+	writeb(val, i2c_dev->regs + reg);
+}
+
+static inline u8 cdac_i2c_readb(struct cdac_i2c_dev *i2c_dev, u32 reg)
+{
+	return readb(i2c_dev->regs + reg);
+}
+
+static int cdac_i2c_set_divider(struct cdac_i2c_dev *i2c_dev)
+{
+	u8 chl,chh,chhl,chhh;
+	u16 chl_chh,chhl_chhh;
+
+
+	chl_chh 	= DIV_ROUND_UP( i2c_dev->clk,(2*i2c_dev->bus_clk_rate)); //Clock Period half register
+	chhl_chhh 	= DIV_ROUND_UP( i2c_dev->clk,(4*i2c_dev->bus_clk_rate)); //Clock Period half half register
+
+	chl = chl_chh & 0xff;
+	chh = chl_chh >> 8;
+
+	chhl = chhl_chhh & 0xff;
+	chhh = chhl_chhh >> 8;
+
+	cdac_i2c_writeb(i2c_dev, CDAC_I2C_CHL, chl);
+	cdac_i2c_writeb(i2c_dev, CDAC_I2C_CHH, chh);
+	cdac_i2c_writeb(i2c_dev, CDAC_I2C_CHHL, chhl);
+	cdac_i2c_writeb(i2c_dev, CDAC_I2C_CHHH, chhh);
+	return 0;
+}
+
+static void cdac_fill_txfifo(struct cdac_i2c_dev *i2c_dev)
+{
+	u8 val;
+	u8 count=0;
+	u8 temp_char=0;
+
+	while (i2c_dev->msg_buf_remaining) {
+
+		val = cdac_i2c_readb(i2c_dev, CDAC_I2C_S);
+		if ((val & CDAC_I2C_S_TX_FIFO_FULL))
+			break; //TX FIFO full
+		cdac_i2c_writeb(i2c_dev, CDAC_I2C_TXFIFO,
+				   *i2c_dev->msg_buf);
+
+		if(i2c_data_addr_flag ==1)
+		{
+		  if(count==0)
+			temp_char=*i2c_dev->msg_buf;
+		  if(count==1){
+		DBG2("T: 0x%02x%02x, ",temp_char,*i2c_dev->msg_buf);
+			i2c_data_addr_flag =0;
+		  }
+		  count++;
+		}
+		i2c_dev->msg_buf++;
+		i2c_dev->msg_buf_remaining--;
+	}
+}
+
+static void cdac_drain_rxfifo(struct cdac_i2c_dev *i2c_dev)
+{
+	u8 val, count=0;
+
+        while (((cdac_i2c_readb(i2c_dev, CDAC_I2C_S))  & CDAC_I2C_S_RXC ) != CDAC_I2C_S_RXC) ; //Wait for stop complete
+
+	while (i2c_dev->msg_buf_remaining) {
+		val = cdac_i2c_readb(i2c_dev, CDAC_I2C_S);
+
+		if ((val & CDAC_I2C_S_RX_FIFO_EMPTY)){
+		  if(count!=16)
+			DBG3("Count %d",count);
+		  break;
+		}
+		*i2c_dev->msg_buf = cdac_i2c_readb(i2c_dev,
+						 CDAC_I2C_RXFIFO);
+		count++;
+		if(*i2c_dev->msg_buf)
+			DBG2("%c ",*i2c_dev->msg_buf);
+		i2c_dev->msg_buf++;
+		i2c_dev->msg_buf_remaining--;
+	}
+}
+
+/*
+ * Repeated Start Condition (Sr)
+
+ */
+
+static void cdac_i2c_start_transfer(struct cdac_i2c_dev *i2c_dev)
+{
+	u8 c = CDAC_I2C_C_ST;
+	u16 temp_addr;
+	struct i2c_msg *msg = i2c_dev->curr_msg;
+//	bool last_msg = (i2c_dev->num_msgs == 1);
+
+	//mdelay(10);
+
+	if (!i2c_dev->num_msgs)
+		return;
+	DBG2("M: %d,L: %d",i2c_dev->num_msgs,msg->len);
+	//DBG2("M");
+	i2c_dev->num_msgs--;
+	i2c_dev->msg_buf = msg->buf;
+	i2c_dev->msg_buf_remaining = msg->len;
+
+	if ((msg->flags & I2C_M_RD) )
+	{
+		if(msg->len > 16) {
+			c |= (16) << 2 ;
+			DBG3("L: 16");
+		}
+		else{
+			c |= (msg->len) << 2 ;
+			DBG3("L: %d",msg->len);
+		}
+		i2c_dev->msg_buf_remaining = msg->len;
+		temp_addr = ((msg->addr << 1) | 0x1); //R/W bit in address
+		cdac_i2c_writeb(i2c_dev, CDAC_I2C_C, c);
+                //check start sequence initiated
+                while (((cdac_i2c_readb(i2c_dev, CDAC_I2C_S))  & 0x01) != 0x01) ;
+
+		cdac_i2c_writeb(i2c_dev, CDAC_I2C_TXFIFO , temp_addr);
+		DBG1("R");
+		i2c_data_addr_flag =1;
+		cdac_i2c_writeb(i2c_dev, CDAC_I2C_IER, (CDAC_I2C_IER_INTRX | CDAC_I2C_IER_INTGL)); //Enable RX interrupt
+		return;
+	}
+	else
+	{
+		temp_addr = ((msg->addr << 1) | 0x0); //R/W bit in address
+		cdac_i2c_writeb(i2c_dev, CDAC_I2C_C, c);
+                //check start sequence initiated
+                while (((cdac_i2c_readb(i2c_dev, CDAC_I2C_S))  & 0x01) != 0x01) ;
+		cdac_i2c_writeb(i2c_dev, CDAC_I2C_TXFIFO , temp_addr);
+
+		DBG1("W");
+		i2c_data_addr_flag =1;
+		cdac_i2c_writeb(i2c_dev, CDAC_I2C_IER, (CDAC_I2C_IER_INTTX | CDAC_I2C_IER_INTGL)); //Enable TX interrupt
+		return;
+	}
+
+
+}
+
+/*
+ * IRQ handling
+ */
+
+static irqreturn_t cdac_i2c_isr(int this_irq, void *data)
+{
+	struct cdac_i2c_dev *i2c_dev = data;
+	u32 val, err;
+	struct i2c_msg *msg = i2c_dev->curr_msg;
+	u8 c = CDAC_I2C_C_ST;
+        u16 temp_addr;
+	 //check for TX complete for avoid unwanted NACK
+        if(((cdac_i2c_readb(i2c_dev, CDAC_I2C_S))  & 0x10) != 0x10)
+	{
+		DBG1("*");
+		return IRQ_HANDLED;
+	}
+
+	val = cdac_i2c_readb(i2c_dev, CDAC_I2C_S1);
+	err = val & (CDAC_I2C_S1_NACK);
+	if (err) {
+			DBG1("#");
+
+		        i2c_dev->num_msgs++;
+
+                        cdac_i2c_writeb(i2c_dev, CDAC_I2C_C, CDAC_I2C_S_STOP);
+                        while (((cdac_i2c_readb(i2c_dev, CDAC_I2C_S))  & 0x02) != 0x02) ; //Wait for stop$
+                        cdac_i2c_start_transfer(i2c_dev);
+		return IRQ_HANDLED;
+	}
+
+
+	if ((val & CDAC_I2C_S_TXW)){ // && (val_ier & CDAC_I2C_IER_INTTX)) { //
+		DBG1("T :%d",i2c_dev->msg_buf_remaining);
+		if (!i2c_dev->msg_buf_remaining) {
+			i2c_dev->msg_err = 0;
+			goto complete;
+		}
+
+		cdac_fill_txfifo(i2c_dev);
+		if (i2c_dev->num_msgs && !i2c_dev->msg_buf_remaining) {
+			i2c_dev->curr_msg++;
+			cdac_i2c_writeb(i2c_dev, CDAC_I2C_C, CDAC_I2C_S_STOP);
+			while (((cdac_i2c_readb(i2c_dev, CDAC_I2C_S))  & 0x02) != 0x02) ; //Wait for stop complete
+			cdac_i2c_start_transfer(i2c_dev);
+		}
+
+		return IRQ_HANDLED;
+	}
+
+	if ((val & CDAC_I2C_S_RXR)){ // && (val_ier & CDAC_I2C_IER_INTRX)) { //
+		DBG1("R");
+		if (!i2c_dev->msg_buf_remaining) {
+			i2c_dev->msg_err = 0;
+			goto complete;
+		}
+
+		cdac_drain_rxfifo(i2c_dev);
+
+		if (!i2c_dev->msg_buf_remaining) {
+                        i2c_dev->msg_err = 0;
+                        goto complete;
+
+                }
+		else
+		{
+			//cdac_i2c_writeb(i2c_dev, CDAC_I2C_C, CDAC_I2C_S_STOP);
+			while (((cdac_i2c_readb(i2c_dev, CDAC_I2C_S))  & 0x02) != 0x02) ; //Wait for stop complete
+
+			if(i2c_dev->msg_buf_remaining > 16) {
+				c |= (16) << 2 ;
+				DBG3("L: 16");
+
+			}
+			else{
+				c |= (i2c_dev->msg_buf_remaining) << 2 ;
+				DBG3("L: %d",i2c_dev->msg_buf_remaining);
+			}
+			temp_addr = ((msg->addr << 1) | 0x1); //R/W bit in address
+			cdac_i2c_writeb(i2c_dev, CDAC_I2C_C, c);
+	                //check start sequence initiated
+	                while (((cdac_i2c_readb(i2c_dev, CDAC_I2C_S))  & 0x01) != 0x01) ;
+			cdac_i2c_writeb(i2c_dev, CDAC_I2C_TXFIFO , temp_addr);
+			DBG("RD: temp_addr %x\n",temp_addr);
+
+		}
+		return IRQ_HANDLED;
+	}
+
+	return IRQ_NONE;
+
+complete:
+	DBG2("C\n");
+	complete(&i2c_dev->completion);
+	cdac_i2c_writeb(i2c_dev, CDAC_I2C_C, CDAC_I2C_S_STOP);
+	while (((cdac_i2c_readb(i2c_dev, CDAC_I2C_S))  & 0x02) != 0x02) ; //Wait for stop complete
+	cdac_i2c_writeb(i2c_dev, CDAC_I2C_IER,  0x0 );
+	return IRQ_HANDLED;
+}
+
+static int cdac_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg msgs[],
+			    int num)
+{
+	struct cdac_i2c_dev *i2c_dev = i2c_get_adapdata(adap);
+	unsigned long time_left;
+	int i, ret;
+
+	DBG1(">");
+	for (i = 0; i < (num - 1); i++)
+		if (msgs[i].flags & I2C_M_RD) {
+			dev_warn_once(i2c_dev->dev,
+				      "only one read message supported, has to be last\n");
+			return -EOPNOTSUPP;
+		}
+
+	ret = cdac_i2c_set_divider(i2c_dev);
+	if (ret)
+		return ret;
+
+	i2c_dev->curr_msg = msgs;
+	i2c_dev->num_msgs = num;
+	reinit_completion(&i2c_dev->completion);
+
+	cdac_i2c_start_transfer(i2c_dev);
+
+	time_left = wait_for_completion_timeout(&i2c_dev->completion,	CDAC_I2C_TIMEOUT );
+	if (!time_left) {
+		cdac_i2c_writeb(i2c_dev, CDAC_I2C_TXFIFO_CLR,  CDAC_I2C_TX_CLEAR);
+		dev_err(i2c_dev->dev, "i2c transfer timed out\n");
+		return -ETIMEDOUT;
+	}
+
+	if (!i2c_dev->msg_err)
+		return num;
+
+	dev_dbg(i2c_dev->dev, "i2c transfer failed: %x\n", i2c_dev->msg_err);
+
+	if (i2c_dev->msg_err & CDAC_I2C_S1_NACK)
+		return -EREMOTEIO;
+
+	return -EIO;
+}
+
+static u32 cdac_i2c_func(struct i2c_adapter *adap)
+{
+	return I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;
+}
+
+static const struct i2c_algorithm cdac_i2c_algo = {
+	.master_xfer	= cdac_i2c_xfer,
+	.functionality	= cdac_i2c_func,
+};
+
+/*
+ * This HW was reported to have problems with clock stretching:
+ * http://www.advamation.com/knowhow/raspberrypi/rpi-i2c-bug.html
+ * https://www.raspberrypi.org/forums/viewtopic.php?p=146272
+ */
+static const struct i2c_adapter_quirks cdac_i2c_quirks = {
+	.flags = I2C_AQ_NO_CLK_STRETCH,
+};
+
+static int cdac_i2c_probe(struct platform_device *pdev)
+{
+	struct cdac_i2c_dev *i2c_dev;
+	struct resource *mem;
+
+	int ret, irq;
+	struct i2c_adapter *adap;
+
+	printk("In cdac i2c_probe\n");
+
+
+	i2c_dev = devm_kzalloc(&pdev->dev, sizeof(*i2c_dev), GFP_KERNEL);
+	if (!i2c_dev)
+		return -ENOMEM;
+	platform_set_drvdata(pdev, i2c_dev);
+	i2c_dev->dev = &pdev->dev;
+	init_completion(&i2c_dev->completion);
+
+	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	i2c_dev->regs = devm_ioremap_resource(&pdev->dev, mem);
+	if (IS_ERR(i2c_dev->regs))
+		return PTR_ERR(i2c_dev->regs);
+
+	/*i2c_dev->clk = devm_clk_get(&pdev->dev, NULL);
+	if (IS_ERR(i2c_dev->clk)) {
+		if (PTR_ERR(i2c_dev->clk) != -EPROBE_DEFER)
+			dev_err(&pdev->dev, "Could not get clock\n");
+		return PTR_ERR(i2c_dev->clk);
+	}*/
+
+	ret = of_property_read_u32(pdev->dev.of_node, "system-frequency",
+				   &i2c_dev->clk);
+	if (ret < 0) {
+		dev_warn(&pdev->dev,
+			 "Could not read system-frequency property\n");
+		i2c_dev->clk = 25000000;
+	}
+
+	ret = of_property_read_u32(pdev->dev.of_node, "clock-frequency",
+				   &i2c_dev->bus_clk_rate);
+	if (ret < 0) {
+		dev_warn(&pdev->dev,
+			 "Could not read clock-frequency property\n");
+		i2c_dev->bus_clk_rate = 100000;
+	}
+
+	irq = platform_get_irq(pdev, 0);
+	//irq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+
+	if (!irq) {
+		dev_err(&pdev->dev, "No IRQ resource\n");
+		return -ENODEV;
+	}
+	i2c_dev->irq = irq;
+
+	ret = request_irq(i2c_dev->irq, cdac_i2c_isr, 0,  dev_name(&pdev->dev), i2c_dev);
+	if (ret) {
+		dev_err(&pdev->dev, "Could not request IRQ\n");
+		return -ENODEV;
+	}
+	dev_info(&pdev->dev,
+		 "C-DAC I2C Controller at 0x%08lx (irq %d)\n",
+		 (unsigned long)i2c_dev->regs, irq);
+	//DBG("request_irq over\n");
+	adap = &i2c_dev->adapter;
+	i2c_set_adapdata(adap, i2c_dev);
+	adap->owner = THIS_MODULE;
+	adap->class = I2C_CLASS_DEPRECATED;
+	strlcpy(adap->name, "cdac I2C adapter", sizeof(adap->name));
+	adap->algo = &cdac_i2c_algo;
+	adap->dev.parent = &pdev->dev;
+	adap->dev.of_node = pdev->dev.of_node;
+	//adap->quirks = &cdac_i2c_quirks;
+
+	cdac_i2c_writeb(i2c_dev, CDAC_I2C_C, 0);
+	ret = i2c_add_adapter(adap);
+	if (ret)
+		free_irq(i2c_dev->irq, i2c_dev);
+
+	printk("In cdac i2c added\n");
+
+	return ret;
+}
+
+static int cdac_i2c_remove(struct platform_device *pdev)
+{
+	struct cdac_i2c_dev *i2c_dev = platform_get_drvdata(pdev);
+
+	free_irq(i2c_dev->irq, i2c_dev);
+	i2c_del_adapter(&i2c_dev->adapter);
+
+	return 0;
+}
+
+static const struct of_device_id cdac_i2c_of_match[] = {
+	{ .compatible = "cdac,mdp-i2c" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, cdac_i2c_of_match);
+
+static struct platform_driver cdac_i2c_driver = {
+	.probe		= cdac_i2c_probe,
+	.remove		= cdac_i2c_remove,
+	.driver		= {
+		.name	= "i2c-cdac",
+		.of_match_table = cdac_i2c_of_match,
+	},
+};
+module_platform_driver(cdac_i2c_driver);
+
+MODULE_AUTHOR("Pemjith A V <premjith@cdac.in>");
+MODULE_DESCRIPTION("CDAC I2C bus adapter");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:i2c-cdac");
diff -Naur linux-5.4.1/drivers/i2c/busses/Kconfig linux-5.4.1_modified/drivers/i2c/busses/Kconfig
--- linux-5.4.1/drivers/i2c/busses/Kconfig	2019-11-29 14:40:32.000000000 +0530
+++ linux-5.4.1_modified/drivers/i2c/busses/Kconfig	2025-08-08 10:40:35.439792191 +0530
@@ -449,6 +449,17 @@
 	  This support is also available as a module.  If so, the module
 	  will be called i2c-bcm2835.
 
+config I2C_CDAC
+	tristate "CDAC I2C controller"
+	help
+	  If you say yes to this option, support will be included for the
+	  CDAC I2C controller.
+
+	  If you don't know what to do here, say N.
+
+	  This support is also available as a module.  If so, the module
+	  will be called i2c-cdac.
+
 config I2C_BCM_IPROC
 	tristate "Broadcom iProc I2C controller"
 	depends on ARCH_BCM_IPROC || COMPILE_TEST
diff -Naur linux-5.4.1/drivers/i2c/busses/Makefile linux-5.4.1_modified/drivers/i2c/busses/Makefile
--- linux-5.4.1/drivers/i2c/busses/Makefile	2019-11-29 14:40:32.000000000 +0530
+++ linux-5.4.1_modified/drivers/i2c/busses/Makefile	2025-08-08 10:40:35.440119775 +0530
@@ -43,6 +43,7 @@
 obj-$(CONFIG_I2C_AU1550)	+= i2c-au1550.o
 obj-$(CONFIG_I2C_AXXIA)		+= i2c-axxia.o
 obj-$(CONFIG_I2C_BCM2835)	+= i2c-bcm2835.o
+obj-$(CONFIG_I2C_CDAC)		+= i2c-cdac.o
 obj-$(CONFIG_I2C_BCM_IPROC)	+= i2c-bcm-iproc.o
 obj-$(CONFIG_I2C_CADENCE)	+= i2c-cadence.o
 obj-$(CONFIG_I2C_CBUS_GPIO)	+= i2c-cbus-gpio.o
diff -Naur linux-5.4.1/drivers/iio/adc/xilinx-xadc-core.c linux-5.4.1_modified/drivers/iio/adc/xilinx-xadc-core.c
--- linux-5.4.1/drivers/iio/adc/xilinx-xadc-core.c	2019-11-29 14:40:32.000000000 +0530
+++ linux-5.4.1_modified/drivers/iio/adc/xilinx-xadc-core.c	2025-08-13 12:18:17.913342339 +0530
@@ -1156,6 +1156,8 @@
 	int ret;
 	int irq;
 	int i;
+	
+	//pr_err("INSIDE xadc_probe:::.>> ");
 
 	if (!pdev->dev.of_node)
 		return -ENODEV;
@@ -1171,7 +1173,7 @@
 	indio_dev = devm_iio_device_alloc(&pdev->dev, sizeof(*xadc));
 	if (!indio_dev)
 		return -ENOMEM;
-
+	//pr_err("INSIDE xadc_probe:::.2>> ");
 	xadc = iio_priv(indio_dev);
 	xadc->ops = id->data;
 	xadc->irq = irq;
diff -Naur linux-5.4.1/drivers/irqchip/irq-cdac-plic.c linux-5.4.1_modified/drivers/irqchip/irq-cdac-plic.c
--- linux-5.4.1/drivers/irqchip/irq-cdac-plic.c	1970-01-01 05:30:00.000000000 +0530
+++ linux-5.4.1_modified/drivers/irqchip/irq-cdac-plic.c	2025-08-08 10:40:35.440371097 +0530
@@ -0,0 +1,353 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2017 SiFive
+ * Copyright (C) 2018 Christoph Hellwig
+ */
+#define pr_fmt(fmt) "plic: " fmt
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/irq.h>
+#include <linux/irqchip.h>
+#include <linux/irqdomain.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+#include <linux/platform_device.h>
+#include <linux/spinlock.h>
+#include <linux/delay.h>
+
+/*
+ * This driver implements a version of the RISC-V PLIC with the actual layout
+ * specified in chapter 8 of the SiFive U5 Coreplex Series Manual:
+ *
+ *     https://static.dev.sifive.com/U54-MC-RVCoreIP.pdf
+ *
+ * The largest number supported by devices marked as 'sifive,plic-1.0.0', is
+ * 1024, of which device 0 is defined as non-existent by the RISC-V Privileged
+ * Spec.
+ */
+
+#define MAX_DEVICES			1024
+#define MAX_CONTEXTS			15872
+
+/*
+ * Each interrupt source has a priority register associated with it.
+ * We always hardwire it to one in Linux.
+ */
+#define     PRIORITY_BASE		0 // HDG : Priority register starts at base address
+#define     PRIORITY_PER_ID		4
+
+/*
+ * Each hart context has a vector of interrupt enable bits associated with it.
+ * There's one bit for each interrupt source.
+ */
+#define 	ENABLE_BASE		0x120 // HDG : CDAC  PLIC ENABLE BASE ADDRESS
+#define     	ENABLE_PER_HART		0x40  // HDG : CDAC PLIC ENABLE BASE ADDRESS of NEXT HART
+
+/*
+ * Each hart context has a set of control registers associated with it.  Right
+ * now there's only two: a source priority threshold over which the hart will
+ * take an interrupt, and a register to claim interrupts.
+ */
+#define     CONTEXT_BASE		0x310  // HDG
+#define     CONTEXT_PER_HART		0x20   // HDG
+#define     CONTEXT_THRESHOLD		0x00
+#define     CONTEXT_CLAIM		0x04
+
+static void __iomem *plic_regs;
+
+struct plic_handler {
+	bool			present;
+	int			ctxid;
+};
+static DEFINE_PER_CPU(struct plic_handler, plic_handlers);
+
+static inline void __iomem *plic_hart_offset(int ctxid)
+{
+	return plic_regs + CONTEXT_BASE + ctxid * CONTEXT_PER_HART;
+}
+
+static inline u32 __iomem *plic_enable_base(int ctxid)
+{
+	return plic_regs + ENABLE_BASE + ctxid * ENABLE_PER_HART;
+}
+
+/*
+ * Protect mask operations on the registers given that we can't assume that
+ * atomic memory operations work on them.
+ */
+static DEFINE_RAW_SPINLOCK(plic_toggle_lock);
+
+static inline void plic_toggle(int ctxid, int hwirq, int enable) // For enabling the plic corresponding to 'hwirq'
+{
+
+	/*
+		old code which can was detecting irq less than 60
+		u32 __iomem *reg = plic_enable_base(ctxid) + ((hwirq / 32) * 4); // HDG
+		u32 hwirq_mask = 1 << (hwirq % 32);
+	*/
+
+	u32 __iomem *reg ; // HDG
+	u64 tmp_addr = (u64) plic_enable_base(ctxid);
+	u32 hwirq_mask = 1 << (hwirq % 32);
+
+	tmp_addr += ((hwirq / 32) * 4);
+	reg = (u32 __iomem *)tmp_addr;
+	//printk("[C-DAC DEBUG] @plic_toggle \n");
+
+	///printk("[C-DAC DEBUG] enable %d, hwirq %d, reg %lx, hwirq_mask %lx \n", enable, hwirq, reg, hwirq_mask);
+
+	//printk("[C-DAC DEBUG] Toggle address : %lx value : %lx  enable : %d \n",reg,(readl(reg) | hwirq_mask),enable);
+	raw_spin_lock(&plic_toggle_lock);
+	if (enable)
+		writel(readl(reg) | hwirq_mask, reg);
+	else
+		writel(readl(reg) & ~hwirq_mask, reg);
+
+	__asm__ volatile ("fence");
+	raw_spin_unlock(&plic_toggle_lock);
+}
+
+static inline void plic_irq_toggle(struct irq_data *d, int enable)
+{
+	int cpu;
+	int priority_bit_pos;
+	int priority_addr =  d->hwirq * PRIORITY_PER_ID;
+	u32 __iomem *reg;
+
+	//printk("[C-DAC DEBUG] @plic_irq_toggle \n");
+
+
+
+	priority_bit_pos = (d->hwirq * PRIORITY_PER_ID) % 32;
+
+	priority_addr =  d->hwirq * PRIORITY_PER_ID;
+	priority_addr = (priority_addr / 32) * 4;
+
+	reg = plic_regs + PRIORITY_BASE + priority_addr;
+
+
+	enable <<= priority_bit_pos; 			// Priority value
+
+	//printk("[C-DAC DEBUG] address : %lx value : %lx \n",reg,(readl(reg) | enable));
+	writel(readl(reg) | enable, reg);
+
+	__asm__ volatile ("fence");
+
+	for_each_cpu(cpu, irq_data_get_affinity_mask(d)) {
+		struct plic_handler *handler = per_cpu_ptr(&plic_handlers, cpu);
+
+		if (handler->present)
+			plic_toggle(handler->ctxid, d->hwirq, enable);
+	}
+}
+
+static void plic_irq_enable(struct irq_data *d)
+{
+	plic_irq_toggle(d, 1);
+}
+
+static void plic_irq_disable(struct irq_data *d)
+{
+	plic_irq_toggle(d, 0);
+}
+
+static struct irq_chip plic_chip = {
+	.name		= "CDAC PLIC",
+	/*
+	 * There is no need to mask/unmask PLIC interrupts.  They are "masked"
+	 * by reading claim and "unmasked" when writing it back.
+	 */
+	.irq_enable	= plic_irq_enable,
+	.irq_disable	= plic_irq_disable,
+};
+
+static int plic_irqdomain_map(struct irq_domain *d, unsigned int irq,
+			      irq_hw_number_t hwirq)
+{
+	irq_set_chip_and_handler(irq, &plic_chip, handle_simple_irq);
+	irq_set_chip_data(irq, NULL);
+	irq_set_noprobe(irq);
+	return 0;
+}
+
+static const struct irq_domain_ops plic_irqdomain_ops = {
+	.map		= plic_irqdomain_map,
+	.xlate		= irq_domain_xlate_onecell,
+};
+
+static struct irq_domain *plic_irqdomain;
+
+/*
+ * Handling an interrupt is a two-step process: first you claim the interrupt
+ * by reading the claim register, then you complete the interrupt by writing
+ * that source ID back to the same claim register.  This automatically enables
+ * and disables the interrupt, so there's nothing else to do.
+ */
+static void plic_handle_irq(struct pt_regs *regs)
+{
+	//printk("[C-DAC DEBUG] @plic_handle_irq \n");
+	struct plic_handler *handler = this_cpu_ptr(&plic_handlers);
+	void __iomem *claim = plic_hart_offset(handler->ctxid) + CONTEXT_CLAIM;
+	irq_hw_number_t hwirq;
+
+	WARN_ON_ONCE(!handler->present);
+
+	csr_clear(sie, SIE_SEIE);
+	while ((hwirq = readl(claim))) {
+
+		///hwirq = readl(claim);
+
+
+		//printk("[C-DAC DEBUG] hw_irq=%d \n", hwirq);
+
+		int irq = irq_find_mapping(plic_irqdomain, hwirq);
+
+		//printk("[C-DAC DEBUG] irq=%d \n", irq);
+
+		if (unlikely(irq <= 0))
+			pr_warn_ratelimited("can't find mapping for hwirq %lu\n",
+					hwirq);
+		else
+			generic_handle_irq(irq);
+			//printk("[C-DAC DEBUG] generic_handle_irq over \n");
+
+		__asm__ volatile ("fence");
+		writel(hwirq, claim); // claim completion
+		__asm__ volatile ("fence");
+	}
+ writel(hwirq, claim); // for acknoldging last read of claim.
+/*
+	printk("[C-DAC DEBUG] delay start \n");
+	mdelay(5000);
+	printk("[C-DAC DEBUG] delay over \n");
+*/
+
+/*
+while (1){
+	hwirq = readl(claim);
+	__asm__ volatile ("fence");
+
+	volatile uint32_t *plic_id = (volatile uint32_t *)(plic_regs + 0x304);
+	volatile uint32_t *plic_prio = (volatile uint32_t *)(plic_regs + 0x8);
+	volatile uint32_t *plic_thresh = (volatile uint32_t *)(plic_regs + 0x300);
+	volatile uint32_t *plic_enable = (volatile uint32_t *)(plic_regs + 0x100);
+
+	//printk(" plic_id     : 0x%x\n\r",*plic_id);
+	//printk(" plic_prio   : 0x%x\n\r",*plic_prio);
+	//printk(" plic_thresh : 0x%x\n\r",*plic_thresh);
+	//printk(" plic_enable : 0x%x\n\r",*plic_enable);
+	//sbi_console_getchar();
+
+	if(hwirq){
+		printk("[DEBUG] hwirq : %d \n",hwirq);
+		volatile uint32_t uart_read = sbi_read_32_periph((0x20030000 + 0x4));
+		printk("[DEBUG] gmac reg : %x \n",uart_read);
+		__asm__ volatile ("fence");
+		writel(hwirq, claim); // claim completion
+		__asm__ volatile ("fence");
+	}
+}
+*/
+
+//hwirq = readl(claim);
+//__asm__ volatile ("fence");
+
+//sbi_clear_seip_set_meie();
+
+	//__asm__ volatile ("fence");
+	__asm__ volatile ("fence");
+	csr_set(sie, SIE_SEIE);
+}
+
+/*
+ * Walk up the DT tree until we find an active RISC-V core (HART) node and
+ * extract the cpuid from it.
+ */
+static int plic_find_hart_id(struct device_node *node)
+{
+	for (; node; node = node->parent) {
+		if (of_device_is_compatible(node, "riscv"))
+			return riscv_of_processor_hartid(node);
+	}
+
+	return -1;
+}
+
+static int __init plic_init(struct device_node *node,
+		struct device_node *parent)
+{
+	int error = 0, nr_handlers, nr_mapped = 0, i;
+	u32 nr_irqs;
+
+	if (plic_regs) {
+		pr_warn("PLIC already present.\n");
+		return -ENXIO;
+	}
+
+	plic_regs = of_iomap(node, 0);
+	if (WARN_ON(!plic_regs))
+		return -EIO;
+
+	error = -EINVAL;
+	of_property_read_u32(node, "riscv,ndev", &nr_irqs);
+	if (WARN_ON(!nr_irqs))
+		goto out_iounmap;
+
+	nr_handlers = of_irq_count(node);
+	if (WARN_ON(!nr_handlers))
+		goto out_iounmap;
+	if (WARN_ON(nr_handlers < num_possible_cpus()))
+		goto out_iounmap;
+
+	error = -ENOMEM;
+	plic_irqdomain = irq_domain_add_linear(node, nr_irqs + 1,
+			&plic_irqdomain_ops, NULL);
+	if (WARN_ON(!plic_irqdomain))
+		goto out_iounmap;
+
+	for (i = 0; i < nr_handlers; i++) {
+		struct of_phandle_args parent;
+		struct plic_handler *handler;
+		irq_hw_number_t hwirq;
+		int cpu;
+
+		if (of_irq_parse_one(node, i, &parent)) {
+			pr_err("failed to parse parent for context %d.\n", i);
+			continue;
+		}
+
+		/* skip context holes */
+		if (parent.args[0] == -1)
+			continue;
+
+		cpu = plic_find_hart_id(parent.np);
+		if (cpu < 0) {
+			pr_warn("failed to parse hart ID for context %d.\n", i);
+			continue;
+		}
+
+		handler = per_cpu_ptr(&plic_handlers, cpu);
+		handler->present = true;
+		handler->ctxid = i;
+
+		/* priority must be > threshold to trigger an interrupt */
+		writel(0, plic_hart_offset(i) + CONTEXT_THRESHOLD);
+		for (hwirq = 1; hwirq <= nr_irqs; hwirq++)
+			plic_toggle(i, hwirq, 0);
+		nr_mapped++;
+	}
+
+	pr_info("mapped %d interrupts to %d (out of %d) handlers.\n",
+		nr_irqs, nr_mapped, nr_handlers);
+	set_handle_irq(plic_handle_irq);
+	return 0;
+
+out_iounmap:
+	iounmap(plic_regs);
+	return error;
+}
+
+IRQCHIP_DECLARE(cdac_plic, "cdac,plic-1.0.0", plic_init);
+IRQCHIP_DECLARE(riscv_plic0, "riscv,plic0", plic_init); /* for legacy systems */
diff -Naur linux-5.4.1/drivers/irqchip/irq-cdac-sic.c linux-5.4.1_modified/drivers/irqchip/irq-cdac-sic.c
--- linux-5.4.1/drivers/irqchip/irq-cdac-sic.c	1970-01-01 05:30:00.000000000 +0530
+++ linux-5.4.1_modified/drivers/irqchip/irq-cdac-sic.c	2025-08-08 11:19:35.419883969 +0530
@@ -0,0 +1,242 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2020 C-DAC
+ */
+#define pr_fmt(fmt) "plic: " fmt
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/irq.h>
+#include <linux/irqchip.h>
+#include <linux/irqdomain.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+#include <linux/platform_device.h>
+#include <linux/spinlock.h>
+#include <linux/delay.h>
+
+/*
+ * This driver implements a version of the RISC-V PLIC with the actual layout
+ * specified in chapter 8 of the SiFive U5 Coreplex Series Manual:
+ *
+ * The largest number supported by devices marked as 'sifive,plic-1.0.0', is
+ * 1024, of which device 0 is defined as non-existent by the RISC-V Privileged
+ * Spec.
+ */
+
+#define MAX_DEVICES			1024
+#define MAX_CONTEXTS		15872
+
+#define RAW_INTR 			0x00
+#define INTR_EN 			0x18
+#define INTR_STATUS 		0x20
+
+
+static void __iomem *plic_regs;
+
+struct plic_handler {
+	bool			present;
+	int			ctxid;
+};
+static DEFINE_PER_CPU(struct plic_handler, plic_handlers);
+
+static DEFINE_RAW_SPINLOCK(plic_toggle_lock);
+
+static inline void plic_toggle(int ctxid, int hwirq, int enable) // For enabling the plic corresponding to 'hwirq'
+{
+	u32 intr_en;
+	intr_en = readl(plic_regs + INTR_EN);
+	//printk("[C-DAC DEBUG] @plic_toggle  : %x \n", enable);
+	if(enable)
+		intr_en |= BIT_ULL(hwirq);
+	else
+		intr_en &= ~(BIT_ULL(hwirq));
+
+	raw_spin_lock(&plic_toggle_lock);
+	writel(intr_en, plic_regs + INTR_EN);
+	__asm__ volatile ("fence");
+	raw_spin_unlock(&plic_toggle_lock);
+}
+static inline void plic_irq_toggle(struct irq_data *d, int enable)
+{
+	u32 intr_en;
+
+	intr_en = readl(plic_regs + INTR_EN);
+	//printk("[C-DAC DEBUG] @plic_irq_toggle : %d --> %x \n", d->hwirq, enable);
+	if(enable)
+		intr_en |= BIT_ULL(d->hwirq);
+	else
+		intr_en &= ~(BIT_ULL(d->hwirq));
+
+	writel(intr_en, plic_regs + INTR_EN);
+	//intr_en = readq(plic_regs + INTR_EN);
+	//printk("[C-DAC DEBUG] @plic_en_reg : %lx \n", intr_en);
+}
+
+static void plic_irq_enable(struct irq_data *d)
+{
+	plic_irq_toggle(d, 1);
+}
+
+static void plic_irq_disable(struct irq_data *d)
+{
+	plic_irq_toggle(d, 0);
+}
+
+static struct irq_chip plic_chip = {
+	.name		= "CDAC PLIC",
+	/*
+	 * There is no need to mask/unmask PLIC interrupts.  They are "masked"
+	 * by reading claim and "unmasked" when writing it back.
+	 */
+	.irq_enable	= plic_irq_enable,
+	.irq_disable	= plic_irq_disable,
+};
+
+static int plic_irqdomain_map(struct irq_domain *d, unsigned int irq,
+			      irq_hw_number_t hwirq)
+{
+	irq_set_chip_and_handler(irq, &plic_chip, handle_simple_irq);
+	irq_set_chip_data(irq, NULL);
+	irq_set_noprobe(irq);
+	return 0;
+}
+
+static const struct irq_domain_ops plic_irqdomain_ops = {
+	.map		= plic_irqdomain_map,
+	.xlate		= irq_domain_xlate_onecell,
+};
+
+static struct irq_domain *plic_irqdomain;
+
+/*
+ * Handling an interrupt is a two-step process: first you claim the interrupt
+ * by reading the claim register, then you complete the interrupt by writing
+ * that source ID back to the same claim register.  This automatically enables
+ * and disables the interrupt, so there's nothing else to do.
+ */
+static void plic_handle_irq(struct pt_regs *regs)
+{
+	//printk("[C-DAC DEBUG] @plic_handle_irq \n");
+	struct plic_handler *handler = this_cpu_ptr(&plic_handlers);
+	irq_hw_number_t hwirq;
+	u32 intr_status;
+	int i, irq;
+
+	WARN_ON_ONCE(!handler->present);
+
+	csr_clear(sie, SIE_SEIE);
+        __asm__ volatile ("fence");
+	intr_status = readl(plic_regs + INTR_STATUS);
+	for(i=0;i<32;i++){
+		if((intr_status >> i) & 1)
+			hwirq = i;
+		else
+			continue;
+
+		//printk("[C-DAC DEBUG] hw_irq=%d \n", hwirq);
+		irq= irq_find_mapping(plic_irqdomain, hwirq);
+		//printk("[C-DAC DEBUG] irq=%d \n", irq);
+		if (unlikely(irq <= 0))
+			pr_warn_ratelimited("can't find mapping for hwirq %lu\n",
+					hwirq);
+		else
+			generic_handle_irq(irq);
+			//printk("[C-DAC DEBUG] generic_handle_irq over \n");
+	}
+
+	__asm__ volatile ("fence");
+	csr_set(sie, SIE_SEIE);
+}
+
+/*
+ * Walk up the DT tree until we find an active RISC-V core (HART) node and
+ * extract the cpuid from it.
+ */
+static int plic_find_hart_id(struct device_node *node)
+{
+	for (; node; node = node->parent) {
+		if (of_device_is_compatible(node, "riscv"))
+			return riscv_of_processor_hartid(node);
+	}
+
+	return -1;
+}
+
+static int __init plic_init(struct device_node *node,
+		struct device_node *parent)
+{
+	int error = 0, nr_handlers, nr_mapped = 0, i;
+	u32 nr_irqs;
+
+	if (plic_regs) {
+		pr_warn("PLIC already present.\n");
+		return -ENXIO;
+	}
+
+	plic_regs = of_iomap(node, 0);
+	if (WARN_ON(!plic_regs))
+		return -EIO;
+
+	error = -EINVAL;
+	of_property_read_u32(node, "riscv,ndev", &nr_irqs);
+	if (WARN_ON(!nr_irqs))
+		goto out_iounmap;
+
+	nr_handlers = of_irq_count(node);
+	if (WARN_ON(!nr_handlers))
+		goto out_iounmap;
+	if (WARN_ON(nr_handlers < num_possible_cpus()))
+		goto out_iounmap;
+
+	error = -ENOMEM;
+	plic_irqdomain = irq_domain_add_linear(node, nr_irqs + 1,
+			&plic_irqdomain_ops, NULL);
+	if (WARN_ON(!plic_irqdomain))
+		goto out_iounmap;
+
+	for (i = 0; i < nr_handlers; i++) {
+		struct of_phandle_args parent;
+		struct plic_handler *handler;
+		irq_hw_number_t hwirq;
+		int cpu;
+
+		if (of_irq_parse_one(node, i, &parent)) {
+			pr_err("failed to parse parent for context %d.\n", i);
+			continue;
+		}
+
+		/* skip context holes */
+		if (parent.args[0] == -1)
+			continue;
+
+		cpu = plic_find_hart_id(parent.np);
+		if (cpu < 0) {
+			pr_warn("failed to parse hart ID for context %d.\n", i);
+			continue;
+		}
+
+		handler = per_cpu_ptr(&plic_handlers, cpu);
+		handler->present = true;
+		handler->ctxid = i;
+
+		/* priority must be > threshold to trigger an interrupt */
+		//writel(0, plic_hart_offset(i) + CONTEXT_THRESHOLD);
+		for (hwirq = 1; hwirq < nr_irqs; hwirq++)
+			plic_toggle(i, hwirq, 0);
+		nr_mapped++;
+	}
+
+	pr_info("mapped %d interrupts to %d (out of %d) handlers.\n",
+		nr_irqs, nr_mapped, nr_handlers);
+	set_handle_irq(plic_handle_irq);
+	return 0;
+
+out_iounmap:
+	iounmap(plic_regs);
+	return error;
+}
+
+IRQCHIP_DECLARE(cdac_plic,"cdac,plic-1.0.0",plic_init);
+IRQCHIP_DECLARE(riscv_plic0, "riscv,plic0", plic_init);	/* for legacy systems	*/
diff -Naur linux-5.4.1/drivers/irqchip/irq-riscv-intc.c linux-5.4.1_modified/drivers/irqchip/irq-riscv-intc.c
--- linux-5.4.1/drivers/irqchip/irq-riscv-intc.c	1970-01-01 05:30:00.000000000 +0530
+++ linux-5.4.1_modified/drivers/irqchip/irq-riscv-intc.c	2025-08-08 10:40:35.440651623 +0530
@@ -0,0 +1,201 @@
+/*
+ * Copyright (C) 2012 Regents of the University of California
+ * Copyright (C) 2017 SiFive
+ *
+ *   This program is free software; you can redistribute it and/or
+ *   modify it under the terms of the GNU General Public License
+ *   as published by the Free Software Foundation, version 2.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ */
+
+#include <linux/irq.h>
+#include <linux/irqchip.h>
+#include <linux/irqdomain.h>
+#include <linux/interrupt.h>
+#include <linux/ftrace.h>
+#include <linux/of.h>
+#include <linux/seq_file.h>
+
+#include <asm/ptrace.h>
+#include <asm/sbi.h>
+#include <asm/smp.h>
+
+#define PTR_BITS (8 * sizeof(uintptr_t))
+
+
+struct riscv_irq_data {
+	struct irq_chip		chip;
+	struct irq_domain	*domain;
+	int			hart;
+	char			name[20];
+};
+DEFINE_PER_CPU(struct riscv_irq_data, riscv_irq_data);
+
+void riscv_intc_irq(struct pt_regs *regs)
+{
+	struct pt_regs *old_regs = set_irq_regs(regs);
+	struct irq_domain *domain;
+	unsigned long cause = csr_read(scause);
+
+	/*
+	 * The high order bit of the trap cause register is always set for
+	 * interrupts, which allows us to differentiate them from exceptions
+	 * quickly.  The INTERRUPT_CAUSE_* macros don't contain that bit, so we
+	 * need to mask it off here.
+	 */
+	WARN_ON((cause & (1UL << (PTR_BITS - 1))) == 0);
+	cause = cause & ~(1UL << (PTR_BITS - 1));
+
+	printk("[INFO] INTR : %ld\n", cause);
+	irq_enter();
+
+	/*
+	 * There are three classes of interrupt: timer, software, and
+	 * external devices.  We dispatch between them here.  External
+	 * device interrupts use the generic IRQ mechanisms.
+	 */
+	switch (cause) {
+	default:
+		domain = per_cpu(riscv_irq_data, smp_processor_id()).domain;
+		generic_handle_irq(irq_find_mapping(domain, cause));
+		break;
+	}
+
+	irq_exit();
+	set_irq_regs(old_regs);
+}
+
+static int riscv_irqdomain_map(struct irq_domain *d, unsigned int irq,
+			       irq_hw_number_t hwirq)
+{
+	struct riscv_irq_data *data = d->host_data;
+
+	irq_set_chip_and_handler(irq, &data->chip, handle_simple_irq);
+	irq_set_chip_data(irq, data);
+	irq_set_noprobe(irq);
+	irq_set_affinity(irq, cpumask_of(data->hart));
+
+	return 0;
+}
+
+static const struct irq_domain_ops riscv_irqdomain_ops = {
+	.map	= riscv_irqdomain_map,
+	.xlate	= irq_domain_xlate_onecell,
+};
+
+/*
+ * On RISC-V systems local interrupts are masked or unmasked by writing the SIE
+ * (Supervisor Interrupt Enable) CSR.  As CSRs can only be written on the local
+ * hart, these functions can only be called on the hart that corresponds to the
+ * IRQ chip.  They are only called internally to this module, so they BUG_ON if
+ * this condition is violated rather than attempting to handle the error by
+ * forwarding to the target hart, as that's already expected to have been done.
+ */
+static void riscv_irq_mask(struct irq_data *d)
+{
+	struct riscv_irq_data *data = irq_data_get_irq_chip_data(d);
+
+	BUG_ON(smp_processor_id() != data->hart);
+	csr_clear(sie, 1 << (long)d->hwirq);
+}
+
+static void riscv_irq_unmask(struct irq_data *d)
+{
+	struct riscv_irq_data *data = irq_data_get_irq_chip_data(d);
+
+	BUG_ON(smp_processor_id() != data->hart);
+	csr_set(sie, 1 << (long)d->hwirq);
+}
+
+/* Callbacks for twiddling SIE on another hart. */
+static void riscv_irq_enable_helper(void *d)
+{
+	riscv_irq_unmask(d);
+}
+
+static void riscv_irq_disable_helper(void *d)
+{
+	riscv_irq_mask(d);
+}
+
+static void riscv_remote_ctrl(unsigned int cpu, void (*fn)(void *d),
+                              struct irq_data *data)
+{
+	smp_call_function_single(cpu, fn, data, true);
+}
+
+static void riscv_irq_enable(struct irq_data *d)
+{
+	struct riscv_irq_data *data = irq_data_get_irq_chip_data(d);
+
+	/*
+	 * It's only possible to write SIE on the current hart.  This jumps
+	 * over to the target hart if it's not the current one.  It's invalid
+	 * to write SIE on a hart that's not currently running.
+	 */
+	if (data->hart == smp_processor_id())
+		riscv_irq_unmask(d);
+	else if (cpu_online(data->hart))
+		riscv_remote_ctrl(data->hart, riscv_irq_enable_helper, d);
+	else
+		WARN_ON_ONCE(1);
+}
+
+static void riscv_irq_disable(struct irq_data *d)
+{
+	struct riscv_irq_data *data = irq_data_get_irq_chip_data(d);
+
+	/*
+	 * It's only possible to write SIE on the current hart.  This jumps
+	 * over to the target hart if it's not the current one.  It's invalid
+	 * to write SIE on a hart that's not currently running.
+	 */
+	if (data->hart == smp_processor_id())
+		riscv_irq_mask(d);
+	else if (cpu_online(data->hart))
+		riscv_remote_ctrl(data->hart, riscv_irq_disable_helper, d);
+	else
+		WARN_ON_ONCE(1);
+}
+
+static int __init riscv_intc_init(struct device_node *node, struct device_node *parent)
+{
+	int hart;
+	struct riscv_irq_data *data;
+
+	if (parent)
+		return 0;
+
+	hart = riscv_of_processor_hartid(node->parent);
+	if (hart < 0)
+		return -EIO;
+
+	data = &per_cpu(riscv_irq_data, hart);
+	snprintf(data->name, sizeof(data->name), "riscv,cpu_intc,%d", hart);
+	data->hart = hart;
+	data->chip.name = data->name;
+	data->chip.irq_mask = riscv_irq_mask;
+	data->chip.irq_unmask = riscv_irq_unmask;
+	data->chip.irq_enable = riscv_irq_enable;
+	data->chip.irq_disable = riscv_irq_disable;
+	data->domain = irq_domain_add_linear(node, PTR_BITS,
+					     &riscv_irqdomain_ops, data);
+	if (!data->domain)
+		goto error_add_linear;
+
+	set_handle_irq(&riscv_intc_irq);
+
+	pr_info("%s: %lu local interrupts mapped\n", data->name, PTR_BITS);
+	return 0;
+
+error_add_linear:
+	pr_warning("%s: unable to add IRQ domain\n",
+		   data->name);
+	return -ENXIO;
+}
+
+IRQCHIP_DECLARE(riscv, "riscv,cpu-intc", riscv_intc_init);
diff -Naur linux-5.4.1/drivers/irqchip/Kconfig linux-5.4.1_modified/drivers/irqchip/Kconfig
--- linux-5.4.1/drivers/irqchip/Kconfig	2019-11-29 14:40:32.000000000 +0530
+++ linux-5.4.1_modified/drivers/irqchip/Kconfig	2025-08-08 10:40:35.440838283 +0530
@@ -485,6 +485,20 @@
 
 endmenu
 
+config RISCV_INTC
+	def_bool y if RISCV
+	bool "RISC-V Interrupt Controller"
+	depends on RISCV
+	default y
+	help
+	   This enables support for the local interrupt controller found in
+	   standard RISC-V systems.  The local interrupt controller handles
+	   timer interrupts, software interrupts, and hardware interrupts.
+	   Without a local interrupt controller the system will be unable to
+	   handle any interrupts, including those passed via the PLIC.
+
+	   If you don't know what to do here, say Y.
+
 config SIFIVE_PLIC
 	bool "SiFive Platform-Level Interrupt Controller"
 	depends on RISCV
@@ -493,6 +507,30 @@
 	   potentially other) RISC-V systems.  The PLIC controls devices
 	   interrupts and connects them to each core's local interrupt
 	   controller.  Aside from timer and software interrupts, all other
+	   interrupt sources are subordinate to the PLIC.
+
+	   If you don't know what to do here, say Y.
+
+config 	CDAC_PLIC
+	bool "CDAC Platform-Level Interrupt Controller"
+	depends on RISCV
+	help
+	   This enables support for the PLIC chip found in CDAC (and
+	   potentially other) RISC-V systems.  The PLIC controls devices
+	   interrupts and connects them to each core's local interrupt
+	   controller.  Aside from timer and software interrupts, all other
+	   interrupt sources are subordinate to the PLIC.
+
+	   If you don't know what to do here, say Y.
+
+config 	CDAC_SIC
+	bool "CDAC Simple Interrupt Controller"
+	depends on RISCV
+	help
+	   This enables support for the PLIC chip found in CDAC (and
+	   potentially other) RISC-V systems.  The PLIC controls devices
+	   interrupts and connects them to each core's local interrupt
+	   controller.  Aside from timer and software interrupts, all other
 	   interrupt sources are subordinate to the PLIC.
 
 	   If you don't know what to do here, say Y.
diff -Naur linux-5.4.1/drivers/irqchip/Makefile linux-5.4.1_modified/drivers/irqchip/Makefile
--- linux-5.4.1/drivers/irqchip/Makefile	2019-11-29 14:40:32.000000000 +0530
+++ linux-5.4.1_modified/drivers/irqchip/Makefile	2025-08-08 10:40:35.440995959 +0530
@@ -103,3 +103,6 @@
 obj-$(CONFIG_LS1X_IRQ)			+= irq-ls1x.o
 obj-$(CONFIG_TI_SCI_INTR_IRQCHIP)	+= irq-ti-sci-intr.o
 obj-$(CONFIG_TI_SCI_INTA_IRQCHIP)	+= irq-ti-sci-inta.o
+obj-$(CONFIG_CDAC_PLIC)			+= irq-cdac-plic.o
+obj-$(CONFIG_CDAC_SIC)			+= irq-cdac-sic.o
+obj-$(CONFIG_RISCV_INTC)		+= irq-riscv-intc.o
diff -Naur linux-5.4.1/drivers/mmc/host/cdac_datatype.h linux-5.4.1_modified/drivers/mmc/host/cdac_datatype.h
--- linux-5.4.1/drivers/mmc/host/cdac_datatype.h	1970-01-01 05:30:00.000000000 +0530
+++ linux-5.4.1_modified/drivers/mmc/host/cdac_datatype.h	2025-08-08 10:40:35.441140470 +0530
@@ -0,0 +1,33 @@
+
+#ifndef __DATATYPE_H
+#define __DATATYPE_H
+
+/***************************************************
+* File Name			: datatype.h
+* Version Number	: 1.00
+* Project Code		: HD 044 0001
+* Project Mnemonic	: EROTG IP Core Design and Development
+* Product Name		: EROTG
+* Module Name		: OTG Firmware
+* Description		: Header file for Datatypes
+* Author			: Sreenadh S., Senior Engineer
+* Revision History & 
+* Date				: First written on 04/08
+* 					: Modified on 6/12  						
+* Modified by whom &
+* Reasons   		: Sreenadh S., Senior Engineer
+***************************************************/
+
+/*  Include section
+*
+*
+***************************************************/
+
+typedef unsigned char UC;	//1 Byte
+typedef unsigned int UI;	//4 Bytes
+typedef unsigned long UL;	//4 Bytes
+typedef unsigned short US;	//2 Bytes
+
+#endif /*__DATATYPE_H */	
+
+
diff -Naur linux-5.4.1/drivers/mmc/host/cdac_dmac.h linux-5.4.1_modified/drivers/mmc/host/cdac_dmac.h
--- linux-5.4.1/drivers/mmc/host/cdac_dmac.h	1970-01-01 05:30:00.000000000 +0530
+++ linux-5.4.1_modified/drivers/mmc/host/cdac_dmac.h	2025-08-08 10:40:35.441223045 +0530
@@ -0,0 +1,388 @@
+/*######################################################################
+#
+#
+File Name:
+#
+########################################################################
+#
+# Project Name
+:
+#
+# Project Code
+:
+#
+# Created
+:
+#
+# Purpose
+:
+#
+# Description
+:
+#
+# Author(s)
+:
+#
+# Version No
+:
+#
+# Revisions
+:
+#
+# Remarks
+:
+#
+# Copyright
+######################################################################*/
+
+#ifndef __DMAC_H
+#define __DMAC_H
+
+#include "cdac_datatype.h"
+
+
+/*  Include section
+*
+***************************************************/
+
+/*  Defines section
+*
+***************************************************/
+
+#define DMAC_ROM_SRAM						1
+#define DMAC_ROM_DDR						2
+#define DMAC_DDR_SRAM					    3
+
+#define DATA_LEN										256
+
+#define DMAC_DISABLE 		0
+#define DMAC_ENABLE 		1
+
+
+#define CHANNEL0 		0
+#define CHANNEL1 		1
+#define CHANNEL2 		2
+#define CHANNEL3 		3
+
+
+#define DMAC_LLI_DISABLED 					0
+#define DMAC_LLI_ENABLED 						1
+
+#define DMAC_CH_INTR_DISABLE 			0
+#define DMAC_CH_INTR_ENABLE 			1
+
+
+#define SRC_DW_8 					0
+#define SRC_DW_16 				1
+#define SRC_DW_32 				2
+#define SRC_DW_64 				3
+#define SRC_DW_128 				4
+#define SRC_DW_256 				5
+
+
+#define DST_DW_8 					0
+#define DST_DW_16 				1
+#define DST_DW_32 				2
+#define DST_DW_64 				3
+#define DST_DW_128 			4
+
+#define DST_CONFIG_ERROR_WIDTH 			5
+
+
+
+#define LM_ACE 				0
+#define LM_AXI 				1
+#define LM_NO_MSEL	2
+
+#define DMA_INACTIVE 	0
+#define DMA_ACTIVE 		1
+
+#define LLI_DISABLE 			0
+#define LLI_ENABLE 			2
+
+
+#define CIE_DISABLE 		    0
+#define CIE_ENABLE 		    1
+
+#define SAI_DISABLE 			0
+#define SAI_ENABLE 		    1
+
+#define DAI_DISABLE 		0
+#define DAI_ENABLE 		    1
+
+#define CBE_DISABLE 		0
+#define CBE_ENABLE 		 1
+
+#define DCE_DISABLE 		0
+#define DCE_ENABLE 		1
+
+#define DMA_INTR_DISABLE 		0
+#define DMA_INTR_ENABLE 			1
+
+#define CMS_ACE2ACE 		0
+#define CMS_AXI2ACE  		1
+#define CMS_ACE2AXI			2
+#define CMS_AXI2AXI 		3
+
+
+#define CTS_1						1
+#define CTS_2						2
+#define CTS_4    					4  // For 512 Bytes transfer
+#define CTS_20    					20 // For 5 packt transfer via DMA
+#define CTS_28    					28
+#define CTS_32    					32 // For 4096 Bytes transfer
+#define CTS_64    					64 // For 4096 Bytes transfer
+
+#define CTS_40    					40
+
+#define CTS_8 						8
+#define CTS_16 						16
+#define CTS_128 					128
+#define CTS_255 					255
+
+#define CTS_256 					256
+#define CTS_512						512
+#define CTS_1024					1024
+#define CTS_2048					2048
+#define CTS_4096					4096
+#define CTS_8191					8191
+
+
+
+#define CBS_DISABLED 		0
+#define CBS_2 						1
+#define CBS_4 						2
+#define CBS_8 						3
+
+#define NO_LLI													0
+#define NO_NEXT_LLI									0
+
+#define DMAC_BASE_ADDR 					0x10000B00UL
+
+#define TABLE_NO_0									0
+#define TABLE_NO_1									1
+#define TABLE_NO_2 								2
+#define TABLE_NO_3									3
+#define TABLE_NO_4									4
+#define TABLE_NO_5 								5
+
+#define CHK_CH0_ENABLED					(1 << 10)
+#define CHK_CH1_ENABLED					(1 << 11)
+#define CHK_CH2_ENABLED					(1 << 12)
+#define CHK_CH3_ENABLED					(1 << 13)
+
+#define CHK_CH0_DTD								(1 << 1)
+#define CHK_CH1_DTD								(1 << 2)
+#define CHK_CH2_DTD								(1 << 3)
+#define CHK_CH3_DTD								(1 << 4)
+
+
+
+#define RESULT_ADDR 								0x91000000
+
+
+
+/*  Defines section
+*
+***************************************************/
+
+#define MEM_ADDR								0x25000UL
+#define CH0_SRC_ADDR							MEM_ADDR
+#define CH1_SRC_ADDR							MEM_ADDR
+#define CH2_SRC_ADDR							MEM_ADDR
+#define CH3_SRC_ADDR							MEM_ADDR
+
+#define LLI_0_ADDRESS								0x2E000UL
+#define LLI_1_ADDRESS								0x2B000UL
+#define LLI_2_ADDRESS								0x2C000UL
+#define LLI_3_ADDRESS								0x2D000UL
+
+
+#define DMAC_CH0_LLI_BASE_ADDR				   LLI_0_ADDRESS
+#define DMAC_CH1_LLI_BASE_ADDR				   LLI_1_ADDRESS
+#define DMAC_CH2_LLI_BASE_ADDR				   LLI_2_ADDRESS
+#define DMAC_CH3_LLI_BASE_ADDR				   LLI_3_ADDRESS
+
+#define DMAC_CH0_LLI_Table(n) 				(*((volatile DMAC_CH0_LLI_TABLE_C *)(DMAC_CH0_LLI_BASE_ADDR + (n * 32))))
+#define DMAC_CH1_LLI_Table(n) 				(*((volatile DMAC_CH1_LLI_TABLE_C *)(DMAC_CH1_LLI_BASE_ADDR + (n * 32))))
+#define DMAC_CH2_LLI_Table(n) 				(*((volatile DMAC_CH2_LLI_TABLE_C *)(DMAC_CH2_LLI_BASE_ADDR + (n * 32))))
+#define DMAC_CH3_LLI_Table(n) 				(*((volatile DMAC_CH3_LLI_TABLE_C *)(DMAC_CH3_LLI_BASE_ADDR + (n * 32))))
+
+
+//unsigned long  Read_DMAC_Global_Status_Reg_sram_to_sram(void);
+
+typedef struct dmac_transfer		//DMA Channel parameters
+{
+	UL SrcAddr;
+	UL DestAddr;
+	union
+	{
+			struct
+			{
+				unsigned long int	DCE 	: 1,			// DMA CHANNEL ENABLE
+					CIE 			: 1, 			// CHANNEL INTERRUPT ENABLE
+					SRC_DW 	: 3, 			//SOURCE DATA WIDTH
+					DST_DW : 3, 			//DESTINATION DATA WIDTH
+					DAI 			: 1,		 	//DESTINATION ADDRESS INCREMENT
+					SAI 			: 1, 			//SOURCE ADDRESS INCREMENT
+					CBE			: 1,			//CHANNEL BURST ENABLE
+					CMS			: 2,     		//CHANNEL MASTER SELECTOR
+					CTS 			: 13,		//CHANNEL TRANSFER SIZE
+					CIC 			: 3, 			//CHANNEL INTERRUPT CAUSE
+					CBS			: 3,			 //CHANNEL BURST SIZE
+					Rsrvd		:32;		// RESERVED
+			}__attribute__((packed)) Bits;
+			UL dword;
+		}Control;
+
+		union
+		{
+			struct
+			{
+				unsigned long int 	LM	: 1, //AHB master select for loading the next LLI
+					LE 			: 1,
+					ZERO	: 1,
+				   NEXT_ADDR		:61;		// RESERVED
+			}__attribute__((packed)) LLIBits;
+			UL dword;
+		}LLI;
+
+
+}DMAtransfer_Type;
+
+typedef	struct dmac_global_reg				//DMA GLOBAL CONTROL REGISTER
+{
+			UL CtrlReg;
+			UL StatusReg;
+}DMAC_GLOBAL_REG_TYPE; // 0x00
+
+
+typedef union
+{
+	struct dmac_global_ctrl_reg				//DMA GLOBAL CONTROL REGISTER
+	{
+				unsigned long int	DE 	: 1,			// DMA ENABLE
+				DIE : 1, 				// DMA INTERRUPT ENABLE
+				Rsrvd :62;		// RESERVED
+	}__attribute__((packed)) Bits;
+	UL  dword;
+}DMAC_GlobalCtrl_Type;
+
+
+
+typedef union
+{
+	struct dmac_global_status_reg			//DMA GLOBAL STATUS REGISTER
+	{
+				unsigned long int	DA 	: 1,			// DMA ACTIVE
+				DTD: 4, 			// DMA TRANSFER DONE
+				Rsrvd0 	: 1, 				//Reserved
+				DCIS :4,			// DMA CHANNEL INTERRUPT STATUS
+				DEC :4,				// DMA ENABLED CHANNELS
+				Rsrvd :50;		// RESERVED
+	}__attribute__((packed)) Bits;
+	UL  dword;
+}DMAC_GlobalStatus_Type;
+
+
+typedef union
+{
+	struct
+	{
+		unsigned long int 	LM	: 1, 	//AHB master select for loading the next LLI
+			LE 			: 1,
+			ZERO	: 1,
+		   NEXT_ADDR		:61;		// RESERVED
+	}__attribute__((packed)) Bits;
+	UL  dword;
+} DMAC_Ch_LLI_REG_Type;
+
+
+typedef struct DMAC_CH0_LLI
+{
+	UL  CH_LLI_SrcAddr;
+	UL  CH_LLI_DstAddr;
+	UL  CH_next_level_LLI;
+	UL  CH_Ctrl_Word;
+}DMAC_CH0_LLI_TABLE_C;
+
+typedef struct DMAC_CH1_LLI
+{
+	UL  CH_LLI_SrcAddr;
+	UL  CH_LLI_DstAddr;
+	UL  CH_next_level_LLI;
+	UL  CH_Ctrl_Word;
+}DMAC_CH1_LLI_TABLE_C;
+
+typedef struct DMAC_CH2_LLI
+{
+	UL  CH_LLI_SrcAddr;
+	UL  CH_LLI_DstAddr;
+	UL  CH_next_level_LLI;
+	UL  CH_Ctrl_Word;
+}DMAC_CH2_LLI_TABLE_C;
+
+typedef struct DMAC_CH3_LLI
+{
+	UL  CH_LLI_SrcAddr;
+	UL  CH_LLI_DstAddr;
+	UL  CH_next_level_LLI;
+	UL  CH_Ctrl_Word;
+}DMAC_CH3_LLI_TABLE_C;
+
+
+typedef struct dmac_channel_regs			//DMA Channel registers
+{
+	UL SrcAddrReg;
+	UL DestAddrReg;
+	UL ChannelLLIReg;
+	UL ChannelCtrlReg;
+}DMAC_CHANNEL_REG_TYPE;
+
+
+#define DMAC_globalReg			 			(*((volatile DMAC_GLOBAL_REG_TYPE *)(DMAC_BASE_ADDR + 0x00)))
+#define DMAC_channelReg(n) 				(*((volatile DMAC_CHANNEL_REG_TYPE *)(DMAC_BASE_ADDR + 0x10 + (n * 0x20))))
+
+void WriteDatatoMemory(void);
+//void Enable_DMAC(UC en_dis_intr);
+//unsigned long Read_DMAC_Global_Status_Reg(void);
+//void  Check_DMAC_transferDone(UC channelNum);
+//UC  Check_DMAC_transferDone_simultaneous(void);
+//void Check_DMAC_transferDone(struct cdac_mmc_host *host,UC channelNum);
+void  Configure_DMAC_Channel(void);
+void Set_DMAC_LLI_Addr(UC channel_num,UL next_lli_addr,UC lli_master_select);
+void Config_Channel_Ctrl_Status_reg(UC channel);
+void  ReadCompareData(UC channel,unsigned long int src_addr ,unsigned long int ch_dst_addr,unsigned long int dataLen );
+void Configure_CH_LLI_Table(UC channel_num,DMAtransfer_Type pTransfer);
+//void Init_DMA_Ch_CtrlReg_params(UC dce, UC cie,UL src_data_width, UL dst_data_width, UC dai, UC sai, UC cbe, UC cms, US cts, UC cbs);
+void create_CH0_LLI_Table(UC table_num, UL lli_src_addr, UL lli_dst_addr, UL next_level_LLIptr,UL cWord,UC msel_LLI);
+void DMAC_testCase(UL test_num,UC dce, UC cie,UL src_data_width, UL dst_data_width, UC dai,UC sai, UC cbe, UC cms, US cts, UC cbs,
+		UC channel,UL ch_source_addr,UL ch_dest_addr,	UC lli_master_select, UL next_lli_addr);
+
+void ReadCompareData_8_new(unsigned long int ch_src_addr ,unsigned long int ch_dst_addr,unsigned long int dataLen,UC dai,UC sai);
+void ReadCompareData_16_new(unsigned long int ch_src_addr ,unsigned long int ch_dst_addr,unsigned long int dataLen,UC dai,UC sai);
+void ReadCompareData_32_new(unsigned long int ch_src_addr ,unsigned long int ch_dst_addr,unsigned long int dataLen,UC dai,UC sai);
+void ReadCompareData_64_new(unsigned long int ch_src_addr ,unsigned long int ch_dst_addr,unsigned long int dataLen,UC dai,UC sai);
+void ReadCompareData_128_new(unsigned long int ch_src_addr ,unsigned long int ch_dst_addr,unsigned long int dataLen,UC dai,UC sai);
+void DMAC_Test(UL src_dw,UL dst_dw,UC master_clk);
+US  Find_new_CTS(UL src_data_width,UL dst_data_width, US cts);
+void TestResult(void);
+void Compare_data_simulataneously(UL src_data_width,UL dst_data_width,US cts, UC cbs,UC dai,UC sai);
+void DMAC_Basic_Test(void);
+void DMAC_Multilevel_LLI_Test(void);
+void DMAC_Normal_Single_LLI(UL test_num,UC dce, UC cie,UL src_data_width, UL dst_data_width, UC dai,UC sai, UC cbe, UC cms, US cts, UC cbs,
+		UC channel,UL ch_source_addr,UL ch_dest_addr,	UC lli_master_select, UL next_lli_addr);
+void DMAC_LLI_All_Channels_test(void);
+void DMAC_Normal_LLI_Normal_Test(void);
+void Compare_data_simulataneously_all(UL src_data_width,UL dst_data_width);
+void disp_LLITable_params(UC channel_no,UC table_num);
+
+
+/*******************************************/
+
+
+void Init_DMA_Ch_CtrlReg_params_sram_to_sram(UC dce, UC cie,UL src_data_width, UL dst_data_width, UC dai, UC sai, UC cbe, UC cms, US cts, UC cbs);
+
+#endif /*__DMAC_H*/
+
+
diff -Naur linux-5.4.1/drivers/mmc/host/cdac_dmac_sram_to_sram.h linux-5.4.1_modified/drivers/mmc/host/cdac_dmac_sram_to_sram.h
--- linux-5.4.1/drivers/mmc/host/cdac_dmac_sram_to_sram.h	1970-01-01 05:30:00.000000000 +0530
+++ linux-5.4.1_modified/drivers/mmc/host/cdac_dmac_sram_to_sram.h	2025-08-08 10:40:35.441385279 +0530
@@ -0,0 +1,51 @@
+/*######################################################################
+#
+#
+File Name:
+#
+########################################################################
+#
+# Project Name
+:
+#
+# Project Code
+:
+#
+# Created
+:
+#
+# Purpose
+:
+#
+# Description
+:
+#
+# Author(s)
+:
+#
+# Version No
+:
+#
+# Revisions
+:
+#
+# Remarks
+:
+#
+# Copyright
+######################################################################*/
+
+#ifndef __DMAC_SRAM_SRAM_H
+#define __DMAC_SRAM_SRAM_H
+
+
+/*  Include section
+*
+***************************************************/
+#include "cdac_dmac.h"	//for datatypes
+
+
+
+#endif /*__DMAC_SRAM_SRAM_H*/
+
+
diff -Naur linux-5.4.1/drivers/mmc/host/cdac_emmc.h linux-5.4.1_modified/drivers/mmc/host/cdac_emmc.h
--- linux-5.4.1/drivers/mmc/host/cdac_emmc.h	1970-01-01 05:30:00.000000000 +0530
+++ linux-5.4.1_modified/drivers/mmc/host/cdac_emmc.h	2025-08-08 10:40:35.441493492 +0530
@@ -0,0 +1,391 @@
+#ifndef EMMC_H_
+#define EMMC_H_
+
+/***************************************************
+* File Name			: emmc.h
+* Version Number	:
+* Project Code		:
+* Project Mnemonic	:
+* Product Name		:
+* Module Name		:
+* Description		:
+* Author			:
+* Revision History & 
+* Date				:
+* 					:
+* Modified by whom &
+* Reasons   		:
+***************************************************/
+
+/*  Include section
+* 
+*
+***************************************************/
+
+#include "cdac_globals.h"
+#include "cdac_datatype.h"
+
+
+/*  Define section
+* 
+*
+***************************************************/
+
+extern volatile UL *ch0GloCtrlReg ;
+extern volatile UL *ch0GloStatReg;
+extern volatile UL *ch0SrcReg;
+extern volatile UL *ch0DstReg;
+extern volatile UL *ch0LLIReg;
+extern volatile UL *ch0CtrlReg;
+
+typedef union
+{
+	struct
+	{
+		UL 	DEV_BUSY				: 1,
+		 	CMD_SENT 				: 1,
+			CMD_RCVD				: 1,
+			RSVD_0					: 2,
+			NR_WR_BLK_TXD			: 8,
+			MUL_BLK_WR_CMPLT		: 1,
+			MUL_BLK_RD_CMPLT		: 1,
+			RD_BLK_RXD				: 8,
+			SIN_BLK_WR_CMPLT		: 1,
+			CRC7_ERR_RESP			: 1,
+			CRC16_ERR_RESP			: 1,
+			CMD_RESP_TOUT_ERR		: 1,
+			WR_TOUT_ERR				: 1,
+			RD_TOUT_ERR				: 1,
+			SIN_BLK_RD_CMPLT		: 1,
+			RSVD_1					: 1,
+			CMD_RESP_TX_BIT_ERR 	: 1,
+			CMD_RESP_END_BIT_ERR	: 1,
+			RD_DATA_BLK_END_BIT_ERR	: 1,
+			RD_DATA_FIFO_FULL		: 1,
+			RD_DATA_FIFO_EMTY		: 1,
+			WR_DATA_FIFO_FULL		: 1,
+			WR_DATA_FIFO_EMTY		: 1,
+			RD_FIFO_FULL_ERR		: 1,
+			BOOT_FIFO_FULL			: 1,
+			BOOT_FIFO_EMTY			: 1,
+			NR_BLK_RXD_IN_BOOT_FIFO : 16,
+			TEST_PATT_SEND			: 1,
+			TEST_PATT_RESP_RXD		: 1,
+			CSD_PGM_BIT_SENT		: 1,
+			WR_PR_STATUS_RXD		: 1,
+			WR_PR_TYPE_RXD			: 1,
+			CMD0_WITH_ARG0_SENT		: 1,
+			ONE_BLK_AVL_BOOT_FIFO	: 1;
+	}Bits;
+	UL Value;
+}eMMCStatusType;
+
+
+
+typedef union
+{
+	struct
+	{
+		UL 	CMD_INDEX			: 6,
+			CMD_ARG 			: 32,
+			CMD_TYPE			: 2,
+			CMD_RESP_TYPE		: 2,
+			RSVD_0				: 22;
+	}Bits;
+	UL  Value;
+}eMMCCmdType;
+
+
+typedef union
+{
+	struct
+	{
+		UL 	DATA_TRSFR_MODE		: 4,
+			DATA_BUS_WIDTH 		: 4,
+			RD_WR_BLK_LEN		: 16,
+			NR_BLK_RD_WR		: 8,
+			DEV_RST				: 1,
+			BOOT_ACK_EN			: 1,
+			CMD_LINE			: 1,
+			CLR_WR_DATA_FIFO	: 1,
+			CLR_RD_DATA_FIFO	: 1,
+			CLR_BOOT_FIFO		: 1,
+			OPEN_END_TRANS		: 1,
+			CMD_LINE_VALID		: 1,
+			ERROR_OVERRIDE		: 1,
+			TOT_FRAMES_TO_INRPT	: 8,
+			STOP_EMMC_CLK		: 1,
+			RSVD_0				: 14;
+
+	}Bits;
+	UL  Value;
+}eMMCOpModeType;
+
+#define HALF_FILL_WR_BLK_NR	5
+#define NO_OF_BLKS_TO_READ 4
+
+#ifdef ENABLE_EMMC_PLIC
+	#define NO_OF_FRAME_READ_BOOTFIFO	2 // for reading data in MB from USER area
+	//#define NO_OF_FRAME_READ_FIFO	8	// For reading data from BOOT area
+#else
+	#define NO_OF_FRAME_READ_BOOTFIFO	1
+	//#define NO_OF_FRAME_READ_FIFO	1
+#endif
+
+#define SET_BLK_LEN_512
+
+#define NO_OF_BLK_READ_IN_DMA_TRSFR_MAX		15 //(No of Blocks)
+#define NO_OF_BLK_READ_IN_DMA_TRSFR		1 //(No of Blocks)
+#define NO_OF_BLK_READ_IN_DMA_TRSFR_BOOTFIFO		NO_OF_FRAME_READ_BOOTFIFO //(No of Blocks)
+#define EMMC_OP_WR_RD_BLK_LEN_512	 512 //(In Bytes)
+#define EMMC_OP_WR_RD_BLK_LEN_4096	 4096 //(In Bytes)
+#define EMMC_BLK_LEN	512 // in bytes
+#define DUT_MAX_BLK_IN_ONE_TRSFR		8
+
+#define ARG_RCA		(0x1000 << 16) // [31:16] RCA [15:0] stuff bits JEDEC Spec 4.5
+#define eMMC_CMD_0 	0
+#define eMMC_CMD_1 	1
+#define eMMC_CMD_2 	2
+#define eMMC_CMD_3 	3
+#define eMMC_CMD_6 	6
+#define eMMC_CMD_7 	7
+#define eMMC_CMD_8 	8
+#define eMMC_CMD_9 	9
+#define eMMC_CMD_10 10
+
+#define eMMC_CMD_12 12 // Stop Transmission
+#define eMMC_CMD_13 13 // Send Status
+
+#define eMMC_CMD_14 14 // Bus Width Test (Read)
+
+#define eMMC_CMD_16 16 // Set Read/write blk len
+#define eMMC_CMD_17 17 // Read single block
+#define eMMC_CMD_18 18 // Read Multiple block
+
+#define eMMC_CMD_19 19 // Bus Width Test (Write)
+
+#define eMMC_CMD_23 23   // SET_BLOCK_COUNT (For multiple read/write)
+#define eMMC_CMD_24 24   // Write block cmd
+#define eMMC_CMD_25 25   // Write Multiple block cmd
+
+#define eMMC_CMD_52 52   // Reserved CMD
+
+#define eMMC_CMD_35 35   // ERASE_GROUP_START cmd
+#define eMMC_CMD_36 36   // ERASE_GROUP_END cmd
+#define eMMC_CMD_38 38   // ERASE cmd
+
+#define eMMC_CMD_42 42   // LOCK_UNLOCK
+
+
+
+
+#define EMMC_DMA_WRITE 	0
+#define EMMC_DMA_READ	1
+#define EMMC_BOOTMODE_READ	2
+
+#define CMD12_BLK_READ	100
+#define CMD12_BLK_WRITE	150
+
+
+#define ARG_STUFF_BITS	 	0x00000000
+#define ARG_IDLE_STATE 		0x00000000
+#define ARG_BOOT_STATE		0xFFFFFFFA
+#define ARG_PRE_IDLE_STATE  0xF0F0F0F0
+#define ARG_CMD1_LT_2GB		0x00FF8080
+#define ARG_CMD1_GT_2GB 	0x40FF8080
+#define ARG_HSPEED_SDR		0x03B90100
+#define ARG_BK_COMP_INT_TIM	0x03B90000
+#define ARG_BUSWIDTH_1		0x03B70000
+#define ARG_BUSWIDTH_8		0x03B70200
+#define ARG_BLK_LEN_512		512 		// Length In Bytes
+#define ARG_BLK_LEN_4096	4096 		// Length In Bytes
+#define ARG_SING_BLK_ADDR	0x00000B00 	// Address
+#define ARG_MUL_BLK_ADDR	0x00000B00 	// Address
+#define ARG_BOOT_1_ACCESS	0x03B34100  // Write and read access for Boot 1 with ACK enabled
+#define ARG_BOOT_2_ACCESS	0x03B34200  // Write and read access for Boot 2 with ACK enabled
+#define ARG_BOOT_USER_AREA	0x03B37800
+#define ARG_BOOT_AREA_1		0x03B34800	//0x03B34800 if ACK is enabled in DUT Bus Width 1
+#define ARG_BOOT_AREA_1_NO_ACK		0x03B30800	//0x03B34800 if ACK is DISABLED in DUT Bus Width 1
+
+#define ARG_BOOT_AREA_2		0x03B35000	//0x03B35000 if ACK is enabled in DUT Bus Width 1
+#define ARG_USER_AREA		0x03B37800	//0x03B34800 if ACK is enabled in DUT
+
+#define ARG_BOOT_BUS_W1		0x03B10000	//0x03B10000 if ACK is enabled in DUT Bus Width 1
+#define ARG_BOOT_BUS_W8		0x03B10200	//0x03B10200 if ACK is enabled in DUT Bus Width 8
+
+
+
+//#define BOOT_1_DATA			(UL)0x0000000075000000
+//#define BOOT_1_DATA			(UL)0xFFFFFFFFFFFFFFFF
+#define BOOT_1_DATA			    (UL)0x0000000075000000
+
+#define BOOT_2_DATA			(UL)0x0000000096000000
+#define WRITE_DATA			(UL)0x1234567812345600
+
+#define ACCESS_AREA_1		1
+#define ACCESS_AREA_2		2
+
+#define FRM_BOOT_AREA_1		1
+#define FRM_BOOT_AREA_2		2
+#define FRM_USER_AREA		3
+
+
+
+#define TEST_PATT_WIDTH_1	0x01
+#define TEST_PATT_WIDTH_8	0xAA55
+
+
+
+#define OP_FREQ_400KHz	0
+#define OP_FREQ_25MHz	1
+#define OP_FREQ_50MHz	2
+
+
+
+#define DBUS_WIDTH_1_BIT	0
+#define DBUS_WIDTH_4_BIT	1
+#define DBUS_WIDTH_8_BIT	2
+
+#define BCAST_CMD		0 //bc
+#define BCAST_CMD_RESP	1 //bcr
+#define ADDRD_CMD		2 //ac
+#define ADDRD_CMD_RESP	3 //adtc
+
+//Command Response types
+#define CMD_NO_RESP						0  // No response
+#define CMD_RESP_LEN_48					1  // R1,R3,R5 (48  BIT RESPONSE)
+#define CMD_RESP_LEN_48_WITH_BUSY		2  // R1b (48  BIT RESPONSE WITH BUSY)
+#define CMD_RESP_LEN_136				3  // R2 (136 BIT)
+
+
+#define 	DEV_BUSY		  			((UL)1 << 0)
+#define 	CMD_SENT 		  			((UL)1 << 1)
+#define 	CMD_RESP_RCVD				((UL)1 << 2)
+#define 	RSVD_0						((UL)1 << 3)
+#define 	NR_WR_BLK_TXD				((UL)1 << 5)
+#define 	MUL_BLK_WR_CMPLT			((UL)1 << 13)
+#define 	MUL_BLK_RD_CMPLT			((UL)1 << 14)
+#define 	RD_BLK_RXD					((UL)1 << 15)
+#define 	SIN_BLK_WR_CMPLT			((UL)1 << 23)
+#define 	CRC7_ERR_RESP				((UL)1 << 24)
+#define 	CRC16_ERR_RESP				((UL)1 << 25)
+#define 	CMD_RESP_TOUT_ERR			((UL)1 << 26)
+#define 	WR_TOUT_ERR					((UL)1 << 27)
+#define 	RD_TOUT_ERR					((UL)1 << 28)
+#define 	SIN_BLK_RD_CMPLT			((UL)1 << 29)
+#define 	BLK_RCVD					((UL)1 << 30)
+#define 	CMD_RESP_TX_BIT_ERR 		((UL)1 << 31)
+#define 	CMD_RESP_END_BIT_ERR		((UL)1 << 32)
+#define 	RD_DATA_BLK_END_BIT_ERR		((UL)1 << 33)
+#define 	RD_DATA_FIFO_FULL			((UL)1 << 34)
+#define 	RD_DATA_FIFO_EMPTY			((UL)1 << 35)
+#define 	WR_DATA_FIFO_FULL			((UL)1 << 36)
+#define 	WR_DATA_FIFO_EMPTY			((UL)1 << 37)
+#define 	RD_FIFO_FULL_ERR			((UL)1 << 38)
+#define 	BOOT_FIFO_FULL				((UL)1 << 39)
+#define 	BOOT_FIFO_EMPTY				((UL)1 << 40)
+#define 	NR_BLK_RXD_IN_BOOT_FIFO		((UL)1 << 41)
+#define 	TEST_PATT_SENT				((UL)1 << 57)
+#define 	TEST_PATT_RESP_RXD			((UL)1 << 58)
+#define 	CSD_PGM_BIT_SENT			((UL)1 << 59)
+#define 	WR_PR_STATUS_RXD			((UL)1 << 60)
+#define 	WR_PR_TYPE_RXD				((UL)1 << 61)
+#define 	CMD0_WITH_ARG0_SENT			((UL)1 << 62)
+#define 	BOOT_1_BLK_AVL				((UL)1 << 63)
+
+//EMMC INTR EN & INTR STATUS BITS
+
+#define 	CMD_CPLT_INTR			((UL)1 << 0)
+#define 	CMD_SENT_INTR			((UL)1 << 1)
+#define 	CMD_RESP_RXD_INTR		((UL)1 << 2)
+#define 	SIN_BLK_WR_CPLT_INTR		((UL)1 << 3)
+#define 	SIN_BLK_RD_CPLT_INTR		((UL)1 << 4)
+#define 	ONE_BLK_AVL_RDFIFO_INTR	((UL)1 << 5) // Read Fifo
+#define 	ONE_BLK_AVL_BTFIFO_INTR	((UL)1 << 6) // Boot Fifo
+#define 	MUL_BLK_RD_CPLT_INTR		((UL)1 << 7)
+#define 	MUL_BLK_WR_CPLT_INTR		((UL)1 << 8)
+#define 	CRC7_ERR_INTR			((UL)1 << 9)
+#define 	CRC16_ERR_INTR			((UL)1 << 10)
+#define 	CMD_RESP_TOUT_ERR_INTR	((UL)1 << 11)
+#define 	WR_TRANS_TOUT_ERR_INTR	((UL)1 << 12)
+#define 	RD_TRANS_TOUT_ERR_INTR	((UL)1 << 13)
+#define 	CMD_RESP_EBIT_ERR_INTR	((UL)1 << 14) // end bit
+#define 	DATA_RESP_EBIT_ERR_INTR	((UL)1 << 15) // end bit
+#define 	RD_DATA_FIFO_FULL_INTR	((UL)1 << 16)
+#define 	WR_DATA_FIFO_FULL_INTR	((UL)1 << 17)
+#define 	BOOT_DATA_FIFO_FULL_INTR	((UL)1 << 18)
+#define 	WR_BLK_TXD_INTR			((UL)1 << 19)
+#define 	RD_BLK_RXD_INTR			((UL)1 << 20)
+#define 	BOOT_BLK_RXD_INTR		((UL)1 << 21)
+#define 	TEST_PATT_SENT_INTR		((UL)1 << 22)
+#define 	TEST_PATT_RXD_INTR		((UL)1 << 23)
+#define 	BOOT_ACK_ERR_INTR		((UL)1 << 24)
+#define 	NO_BLK_AVL_R_FIFO_INTR	((UL)1 << 25) // No of blocks available in Read FIFO
+#define 	NO_BLK_AVL_B_FIFO_INTR	((UL)1 << 26) // No of blocks available in Read FIFO
+#define 	EIGHT_FRAME_SPACE_AVL_INTR		((UL)1 << 27)
+
+
+
+
+
+
+
+#define 	EHC_BASE_ADDRESS			  0x20040000
+
+#define EHC_STATUS_REG                (*(( volatile UL * )(EHC_BASE_ADDRESS + 0x00)))
+#define EHC_LWR_RESP_REG          	  (*(( volatile UL * )(EHC_BASE_ADDRESS + 0x08)))
+#define EHC_UPR_RESP_REG          	  (*(( volatile UL * )(EHC_BASE_ADDRESS + 0x10)))
+#define EHC_CMD_REG                   (*(( volatile UL * )(EHC_BASE_ADDRESS + 0x18)))
+#define EHC_OPR_MODE_REG       		  (*(( volatile UL * )(EHC_BASE_ADDRESS + 0x20)))
+#define EHC_OPR_FREQ_REG			  (*(( volatile UL * )(EHC_BASE_ADDRESS + 0x28)))
+#define EHC_RESP_TOUT_REG             (*(( volatile UL * )(EHC_BASE_ADDRESS + 0x30)))
+#define EHC_WR_TRANS_TOUT_REG         (*(( volatile UL * )(EHC_BASE_ADDRESS + 0x38)))
+#define EHC_RD_TRANS_TOUT_REG         (*(( volatile UL * )(EHC_BASE_ADDRESS + 0x40)))
+
+#define EHC_RSVD_REG 		          (*(( volatile UL * )(EHC_BASE_ADDRESS + 0x48)))
+
+#define EHC_LWR_CSD_REG          	  (*(( volatile UL * )(EHC_BASE_ADDRESS + 0x50)))
+#define EHC_UPR_CSD_REG          	  (*(( volatile UL * )(EHC_BASE_ADDRESS + 0x58)))
+#define EHC_WR_TEST_REG          	  (*(( volatile UL * )(EHC_BASE_ADDRESS + 0x60)))
+#define EHC_RD_TEST_REG          	  (*(( volatile UL * )(EHC_BASE_ADDRESS + 0x68)))
+#define EHC_WR_PROT_REG          	  (*(( volatile UL * )(EHC_BASE_ADDRESS + 0x70)))
+#define EHC_WR_PROT_TYPE_REG          (*(( volatile UL * )(EHC_BASE_ADDRESS + 0x78)))
+
+#define EHC_INTR_EN_REG          	  (*(( volatile UL * )(EHC_BASE_ADDRESS + 0x80)))
+#define EHC_INTR_STATUS_REG           (*(( volatile UL * )(EHC_BASE_ADDRESS + 0x88)))
+
+#define EHC_BOOT_FIFO          		  (*(( volatile UL * )(EHC_BASE_ADDRESS + 0xD0)))
+//#define EHC_RD_DATA_FIFO          	  (*(( volatile UL * )(EHC_BASE_ADDRESS + 0xD0))) // Boot fifo and Read Data fifo are same.
+#define EHC_WR_DATA_FIFO          	  (*(( volatile UL * )(EHC_BASE_ADDRESS + 0xF0)))
+
+// EMMC Function Declarations
+
+void eMMC_Reset_Global_Var(void);
+UL eMMC_Chk_Status_Reg(UL bChkStatus);
+UL eMMC_Read_Response(UC bCommand);
+void eMMC_Validate_Command_Response(UC bCommand);
+void eMMC_Primary_Init_HostController(void);
+void eMMC_Secondary_Init_HostController(void);
+void eMMC_Send_Command(UC bCommand,UI wCmdArg, UC bCmdType, UC bCmdResp);
+void eMMC_BusWidthTest(UL testval);
+void eMMC_ReadBootData(void);
+void eMMC_AlternateReadBootData(void);
+void eMMC_Initialize_Device(void);
+void eMMC_Set_Operating_Frequency(UL wFreq);
+UC eMMC_Nr_WriteBlocks_Txd(void);
+UC eMMC_Nr_ReadBlocks_Rxd(void);
+void eMMC_DisplayReadData(UI noOfBlks);
+void eMMC_DisplayExtCSDdata(UI noOfBlks);
+UC eMMC_Read_Single_Block(UI noOfBlks);
+UC eMMC_Read_Multi_Block(UI noOfBlks);
+UC eMMC_Write_Single_Block(UI noOfBlks);
+void eMMC_ChkReadDataErr(void);
+void eMMC_Chk_Data_Transfer_Error(void);
+UC eMMC_Write_Multi_Block(UI noOfBlks);
+UC eMMC_Write_Multi_Block_modified(void);
+UC eMMC_Read_Multi_Block_modified(void);
+void eMMC_ReadEXTCSD_data(void);
+UC eMMC_EraseBlockData(void);
+void eMMC_Read_EXTCSDReg(void);
+
+#endif /*EMMC_H_*/
diff -Naur linux-5.4.1/drivers/mmc/host/cdac_globals.h linux-5.4.1_modified/drivers/mmc/host/cdac_globals.h
--- linux-5.4.1/drivers/mmc/host/cdac_globals.h	1970-01-01 05:30:00.000000000 +0530
+++ linux-5.4.1_modified/drivers/mmc/host/cdac_globals.h	2025-08-08 10:40:35.441661247 +0530
@@ -0,0 +1,90 @@
+/*
+ * globals.h
+ *
+ *  Created on: 10-Mar-2020
+ *      Author: hdg
+ */
+
+#ifndef INCLUDE_GLOBALS_H_
+#define INCLUDE_GLOBALS_H_
+
+#include "cdac_dmac.h"
+#include "cdac_datatype.h"
+
+
+//#define SINGLE_CORE_EMMC
+
+#define DUAL_CORE_EMMC
+
+#define ENABLE_EMMC_PLIC
+
+
+//#define DISP_EMMC_LOG
+
+
+//DMAC_PERIPH_GBL_VAR_BEGINS
+//DMAC-SRAM-SRAM
+extern volatile UC gReadCompareFlag,gCMD12ReadDone;
+extern  DMAtransfer_Type gDMAtransfer;
+extern volatile UL gDMATestNumber,gDataWidth,gDst_addr,gSrc_addr, gxFactor;
+extern volatile UC g_sdw, g_ddw,g_adj,gReadStatusOnce,gNormalTest;
+//extern volatile ch0_trans_done,ch1_trans_done,ch2_trans_done,ch3_trans_done;
+extern volatile int gTransferDone;
+extern volatile UL gSImulDestAddr1,gSImulDestAddr2,gSImulDestAddr3,gSImulDestAddr4,gSImulDestAddr5,gSImulDestAddr6,gSImulDestAddr7,gSImulDestAddr8;
+extern volatile UC gLLI_dataCompare,gN_LLI_N_flag;
+extern volatile UL gLLIDestAddr;
+extern volatile UC gch0_test5,gch0_test6,gch0_test7,gch0_test8;
+extern volatile UL glli0_address,glli1_address,glli2_address,glli3_address;
+extern volatile UC gDMAC_Intr_generated;
+extern volatile UC d8_flg,d9_flg,d10_flg,d11_flg,d12_flg,d13_flg,d14_flg,d15_flg,d16_flg,d17_flg,d18_flg;
+extern volatile UC gAddrMisalignErr,gSlaveResponseErr,gConfigErr,gSRC_SlaveErr_test,gDST_SlaveErr_test,gSimulCase,gNormalCase;
+//DMAC-SRAM-SRAM
+//DMAC_PERIPH_GBL_VAR_ENDS
+
+
+
+
+//#define SIMULATE
+
+//#define   EMMC_ALTERNATE_BOOT_MODE  // Makes cmd line to ZERO
+
+//#define EMMC_READ_EXT_CSD_REG // using command 8
+
+
+#define WRITE_DATA 0x11
+#define READ_DATA 	WRITE_DATA
+#define MUL_BLK_NUM 0xFFFF
+
+
+
+#define write_csr(reg, val) ({ \
+  asm volatile ("csrw " #reg ", %0" :: "rK"(val)); })
+
+extern volatile UL gread_cycle_start, ginst_retired_start;
+extern volatile UL gread_cycle_end, ginst_retired_end;
+extern volatile UL gEmmcIntrEnReg,gEmmcIntrStatusReg,gwTempCtrlRegVal,gWrData,gEmmcIntrBits;
+extern volatile UL greadcyc_diff, ginst_retired_diff,gips,gTempCount;
+extern volatile UC gSDHC_Plic_Mode;
+
+
+extern volatile UC gIntr_id,gCMD_1_sent,gCRC7_err;
+
+
+extern volatile UC gBusWidthTest_1,gBusWidthTest_8,gTestBootAccess,\
+gTestAlternateBootMode,gWriteSingleBlk,gReadSingleBlk,gReadMultiBlk,gWriteMultiBlk,gReadExtCSDReg,gErrResp,\
+gSetBusWidth_8,gSetBusWidth_1,gEmmcEraseBlkData,gIssueCMD12,gCMD12Sent,gExtCSDRegRead,gOCRdisplay,gCIDdisplay,gCSDdisplay,\
+gBootBusWidth_1,gBootBusWidth_8,gErrRecover,gMuLBlkReadIntr,gSetPassWord,gUnlockDevice,gPassLen,gPassword[16],g8FrameSpaceAvlIntrEn,gTransfer8Frames,gEmmcStopClkEn;
+
+
+extern volatile UI gNoBootBlk,gWriteSinBlkAddr,gReadSinBlkAddr,gWriteMulBlkAddr,gReadMulBlkAddr,gDMAFrameCount,gTTempCount,gNoOfBlkToRead,wgNoOfBlks;
+extern volatile UC gCmdLineLowBoot,gBootData,gDMASingleBlkRead,gDispDevReg,gCmdCheck,gBootBlkReadErr,gCMD25sentFlg;
+extern volatile US gDMA_cts;
+
+extern volatile UC gBootData_400khz,gBootData_50Mhz,CmdLineLowBoot,gSkip,gTest,gtrsfrComplete;
+
+
+
+
+
+
+#endif /* INCLUDE_GLOBALS_H_ */
diff -Naur linux-5.4.1/drivers/mmc/host/cdac_mmc.c linux-5.4.1_modified/drivers/mmc/host/cdac_mmc.c
--- linux-5.4.1/drivers/mmc/host/cdac_mmc.c	1970-01-01 05:30:00.000000000 +0530
+++ linux-5.4.1_modified/drivers/mmc/host/cdac_mmc.c	2025-08-08 10:40:35.441785540 +0530
@@ -0,0 +1,3127 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * linux/drivers/mmc/host/cdac_mmc.c - cdac_X0 MMC driver
+ *
+ *  Copyright (c) 2005, Advanced Micro Devices, Inc.
+ *
+ *  Developed with help from the 2.4.30 MMC cdac_XX controller including
+ *  the following copyright notices:
+ *     Copyright (c) 2003-2004 Embedded Edge, LLC.
+ *     Portions Copyright (C) 2002 Embedix, Inc
+ *     Copyright 2002 Hewlett-Packard Company
+
+ *  2.6 version of this driver inspired by:
+ *     (drivers/mmc/wbsd.c) Copyright (C) 2004-2005 Pierre Ossman,
+ *     All Rights Reserved.
+ *     (drivers/mmc/pxa.c) Copyright (C) 2003 Russell King,
+ *     All Rights Reserved.
+ *
+
+ */
+
+/* Why don't we use the SD controllers' carddetect feature?
+ *
+ * From the AU1100 MMC application guide:
+ * If the Au1100-based design is intended to support both MultiMediaCards
+ * and 1- or 4-data bit SecureDigital cards, then the solution is to
+ * connect a weak (560KOhm) pull-up resistor to connector pin 1.
+ * In doing so, a MMC card never enters SPI-mode communications,
+ * but now the SecureDigital card-detect feature of CD/DAT3 is ineffective
+ * (the low to high transition will not occur).
+ */
+
+#include <linux/clk.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/mm.h>
+#include <linux/interrupt.h>
+#include <linux/dma-mapping.h>
+#include <linux/scatterlist.h>
+#include <linux/highmem.h>
+#include <linux/leds.h>
+#include <linux/mmc/host.h>
+#include <linux/slab.h>
+#include <linux/of.h>
+#include <linux/spinlock.h>
+#include <linux/linkage.h>
+#include <linux/delay.h>
+
+#include "cdac_emmc.h"
+#include "cdac_dmac.h"
+#include "cdac_datatype.h"
+#include "cdac_globals.h"
+
+//#define SINGLE_CORE_EMMC
+
+//#define DUAL_CORE_EMMC
+
+#define cdac_pr_info(...) //pr_info(__VA_ARGS__)
+#define cdac_printk(...) //printk(__VA_ARGS__)
+
+
+volatile unsigned char gTx_memory[512];
+volatile unsigned char gRx_memory[512];
+
+
+
+/*
+typedef unsigned char UC; //1 Byte
+typedef unsigned short US; //2 Bytes
+typedef unsigned int UI; //4 Bytes
+typedef unsigned long UL; //8 Bytes
+*/
+
+/****************** DMA *******************/
+
+	volatile UL *ch0SrcReg  = (UL*)(0x10000B10);
+	volatile UL *ch0DstReg  = (UL*)(0x10000B18);
+	volatile UL *ch0LLIReg  = (UL*)(0x10000B20);
+	volatile UL *ch0CtrlReg = (UL*)(0x10000B28);
+	
+	volatile UL gDst_addr,gSrc_addr;
+	DMAtransfer_Type gDMAtransfer;
+
+
+
+
+/*****************************************/
+
+
+//#include <asm/io.h>
+//#include <asm/mach-au1x00/au1000.h>
+//#//include <asm/mach-au1x00/au1x00_xx_dbdma.h>
+//#include <asm/mach-au1x00/au1100_mmc.h>
+
+volatile UL gHostIEReg_val,command_complete_flag;
+
+	//Command Response types
+#define CMD_NO_RESP						0  // No response
+#define CMD_RESP_LEN_48					1  // R1,R3,R5 (48  BIT RESPONSE)
+#define CMD_RESP_LEN_48_WITH_BUSY		2  // R1b (48  BIT RESPONSE WITH BUSY)
+#define CMD_RESP_LEN_136				3  // R2 (136 BIT)
+
+#define DRIVER_NAME "cdac_emmc"
+
+/* Set this to enable special debugging macros */
+/* #define DEBUG */
+
+#ifdef DEBUG
+#define DBG(fmt, idx, args...)	\
+		pr_debug("cdac_mmc(%d): DEBUG: " fmt, idx, ##args)
+#else
+#define DBG(fmt, idx, args...) do {} while (0)
+#endif
+
+/* Hardware definitions */
+#define CDAC_MMC_DESCRIPTOR_COUNT 1
+
+/* max DMA seg size: 64KB on Au1100, 4MB on Au1200 */
+#define AU1100_MMC_DESCRIPTOR_SIZE 0x0000ffff
+#define AU1200_MMC_DESCRIPTOR_SIZE 0x003fffff
+
+#define CDAC_MMC_OCR (MMC_VDD_27_28 | MMC_VDD_28_29 | MMC_VDD_29_30 | \
+		MMC_VDD_30_31 | MMC_VDD_31_32 | MMC_VDD_32_33 | \
+		MMC_VDD_33_34 | MMC_VDD_34_35 | MMC_VDD_35_36)
+
+/* This gives us a hard value for the stop command that we can write directly
+ * to the command register.
+ */
+//#define STOP_CMD	\
+		(SD_CMD_RT_1B | SD_CMD_CT_7 | (0xC << SD_CMD_CI_SHIFT) | SD_CMD_GO)
+/* This is the set of interrupts that we configure by default. */
+#define CDAC_MMC_INTERRUPTS 				\
+		(SD_CONFIG_SC | SD_CONFIG_DT | SD_CONFIG_RAT |	\
+				SD_CONFIG_CR | SD_CONFIG_I)
+
+/* The poll event (looking for insert/remove events runs twice a second. */
+#define CDAC_MMC_DETECT_TIMEOUT (HZ/2)
+
+struct cdac_mmc_host {
+	struct mmc_host *mmc;
+	struct mmc_request *mrq;
+
+	UI flags;
+	void __iomem *iobase;
+	void __iomem *dmabase;
+	UI clock;
+	UI bus_width;
+	UI power_mode;
+
+	int status;
+
+	struct {
+		int len;
+		int dir;
+	} dma;
+
+	struct {
+		int index;
+		int offset;
+		int len;
+	} pio;
+
+	UI tx_chan;
+	UI rx_chan;
+
+	int irq;
+	
+	spinlock_t chip_lock;
+
+	struct tasklet_struct finish_task;
+	struct tasklet_struct data_task;
+	struct cdac_mmc_platform_data *platdata;
+	struct platform_device *pdev;
+	struct resource *ioarea;
+	struct clk *clk;
+};
+
+/* Status flags used by the host structure */
+#define HOST_F_XMIT	0x0001
+#define HOST_F_RECV	0x0002
+#define HOST_F_DMA	0x0010
+#define HOST_F_DBDMA	0x0020
+#define HOST_F_ACTIVE	0x0100
+#define HOST_F_STOP	0x1000
+
+#define HOST_S_IDLE	0x0001
+#define HOST_S_CMD	0x0002
+#define HOST_S_DATA	0x0003
+#define HOST_S_STOP	0x0004
+
+/************CDAC EMMC REGISTERS **********/
+#define STATUS 0x00
+#define LWR_RSP 0x08
+#define UPR_RSP 0x10
+#define CMD 0x18
+#define OP_MODE 0x20
+#define OP_FREQ 0x28
+#define RSP_TIMEOUT 0x30
+#define WR_TRANS_TIMEOUT 0x38
+#define RD_TRANS_TIMEOUT 0x40
+#define LWR_CSD 0x50
+#define UPR_CSD 0x58
+#define WR_TST 0x60
+#define RD_TST 0x68
+#define WR_PROT 0x70
+#define WR_PROT_TYPE 0x78
+#define INTERRUPT_ENABLE 0x80
+#define INTERRUPT_STATUS 0x88
+#define STATUS_REG_2 0x90
+#define BOOT_FIFO 0xD0
+#define RD_DATA_FIFO 0xD0
+#define WR_DATA_FIFO 0xF0
+
+/* Easy access macros */
+
+#define HOST_STATUS(h)	((h)->iobase + STATUS)
+#define HOST_LWR_RSP(h)	((h)->iobase + LWR_RSP)
+#define HOST_UPR_RSP(h)	((h)->iobase + UPR_RSP)
+#define HOST_CMD(h)	((h)->iobase + CMD)
+#define HOST_OP_MODE(h)	((h)->iobase + OP_MODE)
+#define HOST_OP_FREQ(h)	((h)->iobase + OP_FREQ)
+#define HOST_RSP_TIMEOUT(h)	((h)->iobase + RSP_TIMEOUT)
+#define HOST_WR_TRANS_TIMEOUT(h)	((h)->iobase + WR_TRANS_TIMEOUT)
+#define HOST_RD_TRANS_TIMEOUT(h)	((h)->iobase + RD_TRANS_TIMEOUT)
+#define HOST_LWR_CSD(h)	((h)->iobase + LWR_CSD)
+#define HOST_UPR_CSD(h)	((h)->iobase + UPR_CSD)
+#define HOST_WR_TST(h)	((h)->iobase + WR_TST)
+#define HOST_RD_TST(h)	((h)->iobase + RD_TST)
+#define HOST_WR_PROT(h)	((h)->iobase + WR_PROT)
+#define HOST_WR_PROT_TYPE(h)	((h)->iobase + WR_PROT_TYPE)
+#define HOST_IE(h)	((h)->iobase + INTERRUPT_ENABLE)
+#define HOST_INTERRUPT_STATUS(h)	((h)->iobase + INTERRUPT_STATUS)
+#define HOST_BOOT_FIFO(h)	((h)->iobase + BOOT_FIFO)
+#define HOST_RD_DATA_FIFO(h)	((h)->iobase + RD_DATA_FIFO)
+#define HOST_WR_DATA_FIFO(h)	((h)->iobase + WR_DATA_FIFO)
+/************CDAC EMMC REGISTERS **********/
+
+
+/**********CDAC DMA REGISTERS ***************/
+
+#define DMA_GLOBAL_CTRLREG 	0x00
+#define DMA_GLOBAL_STATUSREG 	0x08
+
+#define DMA_CH0_SRC_ADDRREG 	0x10
+#define DMA_CH0_DST_ADDRREG 	0x18
+#define DMA_CH0_LLIREG 		0x20
+#define DMA_CH0_CTRL_STATUSREG 	0x28
+
+#define DMA_CH1_SRC_ADDRREG 	0x30
+#define DMA_CH1_DST_ADDRREG 	0x38
+#define DMA_CH1_LLIREG 		0x40
+#define DMA_CH1_CTRL_STATUSREG 	0x48
+
+#define DMA_CH2_SRC_ADDRREG 	0x50
+#define DMA_CH2_DST_ADDRREG 	0x58
+#define DMA_CH2_LLIREG 		0x60
+#define DMA_CH2_CTRLSTATUS_REG 	0x68
+
+#define DMA_CH3_SRC_ADDRREG 	0x70
+#define DMA_CH3_DST_ADDRREG 	0x78
+#define DMA_CH3_LLIREG 		0x80
+#define DMA_CH3_CTRL_STATUSREG 	0x88
+
+
+
+
+/* Easy access macros */
+
+#define DMA_GLOBAL_CTRL_REG(h)	((h)->dmabase + DMA_GLOBAL_CTRLREG)
+#define DMA_GLOBAL_STATUS_REG(h)	((h)->dmabase + DMA_GLOBAL_STATUSREG)
+
+#define DMA_CH0_SRC_ADDR_REG(h)	((h)->dmabase + DMA_CH0_SRC_ADDRREG)
+#define DMA_CH0_DST_ADDR_REG(h)	((h)->dmabase + DMA_CH0_DST_ADDRREG)
+#define DMA_CH0_LLI_REG(h)		((h)->dmabase + DMA_CH0_LLIREG)
+#define DMA_CH0_CTRL_STATUS_REG(h)	((h)->dmabase + DMA_CH0_CTRL_STATUSREG)
+
+#define DMA_CH1_SRC_ADDR_REG(h)	((h)->dmabase + DMA_CH1_SRC_ADDRREG)
+#define DMA_CH1_DST_ADDR_REG(h)	((h)->dmabase + DMA_CH1_DST_ADDRREG)
+#define DMA_CH1_LLI_REG(h)		((h)->dmabase + DMA_CH1_LLIREG)
+#define DMA_CH1_CTRL_STATUS_REG(h)	((h)->dmabase + DMA_CH1_CTRL_STATUSREG)
+
+#define DMA_CH2_SRC_ADDR_REG(h)	((h)->dmabase + DMA_CH2_SRC_ADDRREG)
+#define DMA_CH2_DST_ADDR_REG(h)	((h)->dmabase + DMA_CH2_DST_ADDRREG)
+#define DMA_CH2_LLI_REG(h)		((h)->dmabase + DMA_CH2_LLIREG)
+#define DMA_CH3_CTRL_STATUS_REG(h)	((h)->dmabase + DMA_CH2_CTRL_STATUSREG)
+
+#define DMA_CH3_SRC_ADDR_REG(h)	((h)->dmabase + DMA_CH3_SRC_ADDRREG)
+#define DMA_CH3_DST_ADDR_REG(h)	((h)->dmabase + DMA_CH3_DST_ADDRREG)
+#define DMA_CH3_LLI_REG(h)		((h)->dmabase + DMA_CH3_LLIREG)
+#define DMA_CH3_CTRL_STATUS_REG(h)	((h)->dmabase + DMA_CH3_CTRL_STATUSREG)
+
+
+/**********CDAC DMA REGISTERS ***************/
+
+
+
+
+#define OP_FREQ_400KHz	0
+#define OP_FREQ_25MHz	1
+#define OP_FREQ_50MHz	2
+
+#define RSP_TIMEOUT_MAX 0x40
+#define RSP_TIMEOUT_MIN 0x02
+
+//#define WR_TRANS_TIMEOUT_MAX 0xA
+#define WR_TRANS_TIMEOUT_MAX 0xFFFFFFFF
+#define RD_TRANS_TIMEOUT_MAX 0x17bf1A0
+
+
+#define ALL_INTERRUPTS_SET (0x202 | (1<<11) | (1<<12) | (1<<13))
+
+#define CDAC_MMC_OP_MODE_NUM_BLOCK(n) (n << 45) /*Number of blocks Bits 45 to 60*/
+#define CDAC_MMC_OP_MODE_STOP_EMMC_CLK(x) (x << 44) /*Stop EMMC Clock - Old was 49 */
+#define CDAC_MMC_OP_MODE_TOT_FRAMES_TO_INRPT(x) (x << 41) /*Total number of frames in FIFO to be interrupted */
+#define CDAC_MMC_OP_MODE_ERR_OVERRIDE(x) (x << 40) /*Error override */
+#define CDAC_MMC_OP_MODE_CMD_LINE_VALID(x) (x << 39) /*Command line low/high bit is Valid. [34th bit is valid] */
+#define CDAC_MMC_OP_MODE_OPEN_ENDED_TRANSN(x) (x << 38) /*Open ended transaction */
+#define CDAC_MMC_OP_MODE_CLR_BOOT_FIFO(x) (x << 37) /*Clear boot FIFO */
+#define CDAC_MMC_OP_MODE_CLR_RDDATA_FIFO(x) (x << 36) /*Clear read data FIFO */
+#define CDAC_MMC_OP_MODE_CLR_WRDATA_FIFO(x) (x << 35) /*Clear write data FIFO */
+#define CDAC_MMC_OP_MODE_CMD_LINE(x) (x << 34) /*command line high */
+#define CDAC_MMC_OP_MODE_BOOT_ACK_EN(x) (x << 33) /*Boot acknowledgment enabled */
+#define CDAC_MMC_OP_MODE_DEV_RESET(x) (x << 32) /*Active low device reset */
+#define CDAC_MMC_OP_MODE_LEN_BLOCK(n) (n << 8) /*Length of each block*/
+#define CDAC_MMC_OP_MODE_DATA_BUS_WIDTH(n) (n << 4) /*Data bus width*/
+#define CDAC_MMC_OP_MODE_DATA_TSFR(n) (n << 0) /* Data transfer mode*/
+
+#define CDAC_MMC_RSP_TYPE(x) (x << 40) /* Type of Response to the command */
+#define CDAC_MMC_CMD_TYPE(x) (x << 38) /* Type of the command */
+#define CDAC_MMC_CMD_ARG(x) (x << 6) /* Command argument/data address*/
+#define CDAC_MMC_CMD_INDEX(x) (x << 0) /* Command index*/
+
+#define CDAC_MMC_RSP_NONE 0x00
+#define CDAC_MMC_RSP_48 0x01
+#define CDAC_MMC_RSP_48_BUSY 0x02
+#define CDAC_MMC_RSP_136 0x03
+
+
+#define CDAC_MMC_STATUS_BOOT_FIFO_EMP ((UL)1<<40) // 40 bit
+#define CDAC_MMC_STATUS_WDATA_FIFO_EMP  ((UL)1<<37) // 37 bit
+#define CDAC_MMC_STATUS_WDATA_FIFO_FULL ((UL)1<<36) // 36 bit
+#define CDAC_MMC_STATUS_RDATA_END_BIT_ERR  ((UL)1<<33) // 33 bit
+#define CDAC_MMC_STATUS_CMD_RSP_END_ERR ((UL)1<<32) // 32 bit
+#define CDAC_MMC_STATUS_CMD_RSP_TXN_ERR ((UL)1<<31) // 31 bit
+#define CDAC_MMC_STATUS_SIN_BLK_RD_CPLT ((UL)1<<29)
+#define CDAC_MMC_STATUS_RD_TRANSN_TIMEOUT_ERR ((UL)1<<28) // 28 bit
+#define CDAC_MMC_STATUS_WTRANS_TMOUT_ERR ((UL)1<<27)
+#define CDAC_MMC_STATUS_CMD_RSP_TO_ERR ((UL)1<<26)
+#define CDAC_MMC_STATUS_SIN_BLK_WR_CPLT ((UL)1<<23)
+#define CDAC_MMC_STATUS_RX_CRC_ERR  ((UL)1<<25) // 25 bit
+#define CDAC_MMC_STATUS_MUL_BLK_RD_CPLT ((UL)1<<14)
+#define CDAC_MMC_STATUS_MUL_BLK_WR_CPLT ((UL)1<<13)
+
+
+
+#define CDAC_MMC_STATUS_RSP_RXD ((UL)1<<2)
+#define CDAC_MMC_STATUS_CMD_SENT ((UL)1<<1)
+#define CDAC_MMC_STATUS_DEV_BUSY ((UL)1<<0)
+
+
+
+
+#define CDAC_MMC_INTR_STATUS_SIN_BLK_RD_CPLT_INTR ((UL)1<<4)
+#define CDAC_MMC_INTR_STATUS_SIN_BLK_WR_CPLT_INTR ((UL)1<<3)
+#define CDAC_MMC_INT_STATUS_CMD_SENT 	 ((UL)1<<1)
+#define CDAC_MMC_INT_STATUS_CMD_COMPLETE  ((UL)1<<0)
+
+#define CDAC_MMC_INTR_STATUS_RSP_TMOUT ((UL)1<<11)
+#define CDAC_MMC_INTR_STATUS_WRT_TMOUT ((UL)1<<12)
+#define CDAC_MMC_INTR_STATUS_RRT_TMOUT ((UL)1<<13)
+
+
+
+#define CDAC_MMC_INTR_STATUS_NO_BLK_AVL_B_FIFO_INTR ((UL)1<<26)
+#define CDAC_MMC_INTR_STATUS_WR_DATA_FIFO_EMPTY_INTR ((UL)1<<28)
+
+
+
+
+
+//#define CDAC_MMC_INTR_EN_NUM_BLK_AVL_R_FIFO_INTR ((UL)1 << 25)
+#define CDAC_MMC_INTR_EN_NUM_BLK_AVL_BOOT_FIFO_INTR ((UL)1 << 26)
+#define CDAC_MMC_INTR_EN_WR_DATA_FIFO_EMPTY_INTR ((UL)1 << 28)
+/* Easy access macros */
+/*
+ #define HOST_STATUS(h)	((h)->iobase + SD_STATUS)
+ #define HOST_CONFIG(h)	((h)->iobase + SD_CONFIG)
+ #define HOST_ENABLE(h)	((h)->iobase + SD_ENABLE)
+ #define HOST_TXPORT(h)	((h)->iobase + SD_TXPORT)
+ #define HOST_RXPORT(h)	((h)->iobase + SD_RXPORT)
+ #define HOST_CMDARG(h)	((h)->iobase + SD_CMDARG)
+ #define HOST_BLKSIZE(h)	((h)->iobase + SD_BLKSIZE)
+ #define HOST_CMD(h)	((h)->iobase + SD_CMD)
+ #define HOST_CONFIG2(h)	((h)->iobase + SD_CONFIG2)
+ #define HOST_TIMEOUT(h)	((h)->iobase + SD_TIMEOUT)
+ #define HOST_DEBUG(h)	((h)->iobase + SD_DEBUG)
+ */
+
+#define DMA_GBLCTRL 0x00
+#define DMA_GBLSTATUS 0x08
+#define SRC_ADDR 0x10
+#define DST_ADDR 0x18
+#define DMA_CNLCSR 0x20
+#define DMA_CNLLLI 0x28
+
+//#define DMA_ACTIVE 0x01
+
+#define SRC_DW_8 					0
+#define SRC_DW_16 				1
+#define SRC_DW_32 				2
+#define SRC_DW_64 				3
+#define SRC_DW_128 				4
+#define SRC_DW_256 				5
+
+#define DST_DW_8 					0
+#define DST_DW_16 				1
+#define DST_DW_32 				2
+#define DST_DW_64 				3
+#define DST_DW_128 			4
+
+#define DST_CONFIG_ERROR_WIDTH 			5
+
+#define LM_ACE 				0
+#define LM_AXI 				1
+#define LM_NO_MSEL	2
+
+#define CHK_CH0_DTD								(1 << 1)
+#define CHK_CH1_DTD								(1 << 2)
+#define CHK_CH2_DTD								(1 << 3)
+#define CHK_CH3_DTD								(1 << 4)
+
+#define DMA_INACTIVE 	0
+#define DMA_ACTIVE 		1
+
+#define LLI_DISABLE 			0
+#define LLI_ENABLE 			2
+
+#define CIE_DISABLE 		    0
+#define CIE_ENABLE 		    1
+
+#define SAI_DISABLE 			0
+#define SAI_ENABLE 		    1
+
+#define DAI_DISABLE 		0
+#define DAI_ENABLE 		    1
+
+#define CBE_DISABLE 		0
+#define CBE_ENABLE 		 1
+
+#define DCE_DISABLE 		0
+#define DCE_ENABLE 		1
+
+#define DMA_INTR_DISABLE 		0
+#define DMA_INTR_ENABLE 			1
+
+#define CMS_ACE2ACE 		0
+#define CMS_AXI2ACE 		1
+#define CMS_ACE2AXI 		2
+#define CMS_AXI2AXI 		3
+
+#define CTS_1						1
+#define CTS_2						2
+#define CTS_4    					4  // For 512 Bytes transfer
+#define CTS_32    					32 // For 4096 Bytes transfer
+#define CTS_40    					40
+
+#define CTS_8 						8
+#define CTS_16 						16
+#define CTS_128 					128
+#define CTS_255 					255
+
+#define CTS_256 					256
+#define CTS_512						512
+#define CTS_1024					1024
+#define CTS_2048					2048
+#define CTS_4096					4096
+#define CTS_8191					8191
+
+#define CBS_DISABLED 		0
+#define CBS_2 						1
+#define CBS_4 						2
+#define CBS_8 						3
+
+#define NO_LLI													0
+#define NO_NEXT_LLI									0
+#define DMA_CHANNEL(h)	\
+		(((h)->flags & HOST_F_XMIT) ? (h)->tx_chan : (h)->rx_chan)
+//#ifdef DMA
+/*
+#define DMA_GBL_CTRL(h) ((h)->dmabase + DMA_GBLCTRL)
+#define DMA_GBL_STATUS(h) ((h)->dmabase + DMA_GBLSTATUS)
+#define DMA_SRC_ADDR(h) ((h)->dmabase + SRC_ADDR)
+#define DMA_DST_ADDR(h) ((h)->dmabase + DST_ADDR)
+#define DMA_CNL_CSR(h)	((h)->dmabase + DMA_CNLCSR)
+#define DMA_CNL_LLI(h)	((h)->dmabase + DMA_CNLLLI)
+
+#define DMA_CNL_CSR_CBS(x) (x << 29)
+#define DMA_CNL_CSR_CIC(x) (x << 26)
+#define DMA_CNL_CSR_CTS(x) (x << 13)
+#define DMA_CNL_CSR_CMS(x) (x << 11)
+#define DMA_CNL_CSR_CBE(x) (x << 10)
+#define DMA_CNL_CSR_SAI(x) (x << 9)
+#define DMA_CNL_CSR_DAI(x) (x << 8)
+#define DMA_CNL_CSR_DDW(x) (x << 5)
+#define DMA_CNL_CSR_SDW(x) (x << 2)
+#define DMA_CNL_CSR_CIE(x) (x << 1)
+#define DMA_CNL_CSR_DCE(x) (x << 0)
+
+#define DMA_GBL_CTRL_DMA_ENABLE(x) (x << 0) //DMA ENABLE 
+#define DMA_GBL_CTRL_DMA__INTR_ENABLE(x) (x << 1) /* DMA INTERRUPT ENABLE 
+*/
+
+void cdac_mmc_cmd_complete(struct cdac_mmc_host *host);
+void Enable_DMAC(struct cdac_mmc_host *host);
+unsigned long  Read_DMAC_Global_Status_Reg(struct cdac_mmc_host *host);
+void Check_DMAC_transferDone(struct cdac_mmc_host *host,UC channelNum);
+
+/*
+static int cdac_dma_drv_probe(struct platform_device *pdev) {
+	struct resource *r;
+	struct device_node *np = pdev->dev.of_node;
+	struct cdac_mmc_host *host;	
+	
+	
+	cdac_printk("\n\r cdac_dma_drv_probe.............\n\r");
+	
+	r = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!r) {
+		dev_err(&pdev->dev, "no DMAio defined\n");
+		
+		release_resource(host->ioarea);
+		return;
+	}
+	
+	cdac_pr_info(DRIVER_NAME ": r->start %lx pdev->name %s\n", r->start, pdev->name);
+	
+
+	host->dmabase = ioremap(r->start, resource_size(r));
+	
+	
+	cdac_pr_info(DRIVER_NAME " host->dmabase %lx \n", host->dmabase);
+
+	if (!host->dmabase) {
+		dev_err(&pdev->dev, "cannot remap mmio\n");
+		
+		 iounmap((void*) host->dmabase);
+
+		return;
+	}
+	
+	
+	
+
+	Enable_DMAC(host);	// Enabling DMAC.
+
+	return 0;
+}
+
+static int cdac_dma_drv_remove(struct platform_device *pdev) {
+
+//	iounmap((volatile void*) (gDma_base));
+	return 0;
+}
+
+static const struct of_device_id cdac_dma_match[] = { { .type = "dma",
+		.compatible = "cdac,cdac_dma" }, { } };
+		
+MODULE_DEVICE_TABLE( of, cdac_dma_match);
+
+
+static struct platform_driver cdac_dma_driver = {
+
+
+	.probe = cdac_dma_drv_probe,
+	.remove = cdac_dma_drv_remove,
+	.driver = {
+		.name = "cdac_dma",
+                .owner = THIS_MODULE,
+		.of_match_table = of_match_ptr(cdac_dma_match),
+	},
+#ifdef CONFIG_PM
+	//.suspend = cdac_mmc_suspend,
+	//.resume = cdac_mmc_resume,
+#endif
+};*/
+
+/*
+static void DMA_initialisation(struct cdac_mmc_host *host) {
+
+	unsigned long reg_value = 0;
+	unsigned long status = 0;
+	reg_value = DMA_GBL_CTRL_DMA__INTR_ENABLE(1) | DMA_GBL_CTRL_DMA_ENABLE(1); // DMA INTERRUPT ENABLE & DMA ENABLE
+	__raw_writeq(reg_value, DMA_GBL_CTRL(host)); //writing Global control register
+
+	do {
+		status = __raw_readq(DMA_GBL_STATUS(host));
+	} while (((status & DMA_ACTIVE) != DMA_ACTIVE)); // Check if channel is active or not
+
+}*/
+/*
+void DMA_config_channel(struct cdac_mmc_host *host, UC channel,
+		UI ch_source_addr, UI ch_dest_addr, UC DAI, UC SAI) {
+	int channel_num = channel, test = 0;
+
+	//int test = 0;
+	unsigned long reg_value = 0;
+	__raw_writeq(ch_source_addr, DMA_SRC_ADDR(host)); // Set channel  SRC Addr
+
+	//Transmit_uart("\n\r SrcAddrReg : 0x");
+	//disp_Rx_data_UL(DMAC_channelReg(channel).SrcAddrReg);
+
+	__raw_writeq(ch_dest_addr, DMA_DST_ADDR(host)); // Set channel DEST Addr
+
+	reg_value =
+			DMA_CNL_CSR_CBS(
+					CBS_8)| DMA_CNL_CSR_CTS(CTS_4) | DMA_CNL_CSR_CMS(CMS_AXI2AXI) | DMA_CNL_CSR_CBE(CBE_ENABLE) | DMA_CNL_CSR_SAI(SAI)| DMA_CNL_CSR_DAI(DAI)| DMA_CNL_CSR_DDW(DST_DW_128)| DMA_CNL_CSR_SDW(SRC_DW_128)| DMA_CNL_CSR_CIE(CIE_ENABLE)|DMA_CNL_CSR_DCE(DCE_ENABLE);
+
+	__raw_writeq(reg_value, DMA_CNL_CSR(host));
+
+}*/
+
+//#endif
+static inline int has_dbdma(void) {
+
+	return 1;
+	
+}
+
+static inline void IRQ_ON(struct cdac_mmc_host *host, UI mask) {
+	
+	unsigned long val,reg_value,data;
+	
+	//printk(DRIVER_NAME "***************************:IRQ_ON\n");
+	//return;
+	
+	//val = gHostIEReg_val;//__raw_readq(HOST_IE(host));
+	val = __raw_readq(HOST_IE(host));
+	val |= mask;
+	gHostIEReg_val = val;
+	__raw_writeq(val, HOST_IE(host));
+	//val = 0x7C02198;
+	//cdac_pr_info(DRIVER_NAME "*****************:IRQ_ooonnnn %x\n", val);
+	//__raw_writeq(val, HOST_IE(host)); // hdg: delete if not reqd, value as per firmware
+	
+	
+	data = __raw_readq(HOST_IE(host));
+	reg_value = __raw_readq(HOST_OP_MODE(host));
+	
+	cdac_pr_info(DRIVER_NAME "IE Reg data  0x %lx \n",data);
+	//cdac_pr_info(DRIVER_NAME "Op Mode Reg data  0x %lx \n",reg_value);
+	
+	//cdac_pr_info(DRIVER_NAME "*****************:IRQ_ON %x\n", val);
+	
+	wmb(); /* drain writebuffer */
+}
+//#ifdef UNUSED
+//static inline void FLUSH_FIFO(struct cdac_mmc_host *host) {
+//UI val = __raw_readq(HOST_CONFIG2(host));
+
+//__raw_writeq(val | SD_CONFIG2_FF, HOST_CONFIG2(host));//karthika edited
+//	wmb(); /* drain writebuffer */
+//	mdelay(1);
+
+/* SEND_STOP will turn off clock control - this re-enables it */
+//val &= ~SD_CONFIG2_DF;//karthika edited
+//	__raw_writeq(val, HOST_CONFIG2(host));
+//	wmb(); /* drain writebuffer */
+//}
+//#endif
+//static inline
+ void IRQ_OFF(struct cdac_mmc_host *host, UI mask) {
+
+	UI val;
+	cdac_pr_info(DRIVER_NAME "***************************:IRQ_OFF\n");
+
+	// val = gHostIEReg_val;//__raw_readq(HOST_IE(host)); //write irq enable register
+	 val = __raw_readq(HOST_IE(host)); //write irq enable register
+	 cdac_pr_info(DRIVER_NAME "***************:IRQ_OFF before masking %x\n", val);
+	val &= ~mask;
+	__raw_writeq(val, HOST_IE(host));
+	
+	//cdac_pr_info(DRIVER_NAME "gHostIEReg_val  0x %lx \n",gHostIEReg_val);
+	
+	cdac_pr_info(DRIVER_NAME "***************:IRQ_OFF after mask %x\n", val);
+		
+	wmb(); /* drain writebuffer */
+}
+
+//static inline 
+void SEND_STOP(struct cdac_mmc_host *host) {
+	UI config2;
+	unsigned long  reg_val = 0;
+	cdac_pr_info(DRIVER_NAME ":SEND_STOPp\n");
+	//printk(":SEND_STOP\n");
+	//WARN_ON(host->status != HOST_S_DATA);
+	host->status = HOST_S_STOP;
+	//reg_val = __raw_readq(HOST_OP_MODE(host));
+	//reg_val |= ((UL)1 << 37); // Clears Boot FIFO
+	//__raw_writeq(reg_val, HOST_OP_MODE(host));
+	//reg_val = __raw_readq(HOST_OP_MODE(host));
+	//cdac_printk("*****Boot FIFO : Opmode Reg Val:0x %lx",reg_val);
+	//cdac_printk("EMMC : Boot FIFO Cleared");	
+	
+	
+
+	//config2 = __raw_readq(HOST_CONFIG2(host));
+//		__raw_writeq(config2 | SD_CONFIG2_DF, HOST_CONFIG2(host));
+	wmb(); /* drain writebuffer */
+
+
+	/*if (!(host->flags & HOST_F_XMIT))
+	{
+		IRQ_OFF(host,ALL_INTERRUPTS_SET);
+
+		/* Send the stop command */
+		/*reg_val = 0x000002800000000C; // STOP Command arg using CMD 12 with HPI bit set (6th bit : Refer JEDEC spec for emmc)
+		__raw_writeq(reg_val, HOST_CMD(host));
+		
+		//pr_info(DRIVER_NAME ":reg_value %lx \n",reg_val);
+		while (!(__raw_readq(HOST_STATUS(host)) & (CDAC_MMC_STATUS_CMD_SENT))); //waiting for command to be sent
+		cdac_pr_info(DRIVER_NAME ": ***** AF OPMODE REG VAL %lx \n",__raw_readq(HOST_OP_MODE(host)));
+		wmb(); /* drain writebuffer */
+	
+		//IRQ_ON(host,ALL_INTERRUPTS_SET);
+		
+	//}
+
+}
+
+static void cdac_mmc_set_power(struct cdac_mmc_host *host, int state) {
+	cdac_pr_info(DRIVER_NAME ":cdac_mmc_set_power\n");
+	//if (host->platdata && host->platdata->set_power)
+	//	host->platdata->set_power(host->mmc, state);
+	
+	
+}
+
+static void cdac_mmc_finish_request(struct cdac_mmc_host *host) {
+
+	struct mmc_request *mrq = host->mrq;
+	cdac_pr_info(DRIVER_NAME ":cdac_mmc_finish_request\n");
+	host->mrq = NULL;
+	host->flags =0; //&= HOST_F_ACTIVE | HOST_F_DMA;
+	host->dma.len = 0;
+	host->dma.dir = 0;
+	host->pio.index = 0;
+	host->pio.offset = 0;
+	host->pio.len = 0;
+	host->status = HOST_S_IDLE;
+	mmc_request_done(host->mmc, mrq);
+
+}
+
+static void cdac_mmc_tasklet_finish(unsigned long param) {
+	struct cdac_mmc_host *host = (struct cdac_mmc_host*) param;
+	//cdac_pr_info(DRIVER_NAME ":cdac_mmc_tasklet_finish\n");
+	cdac_mmc_finish_request(host);
+}
+
+static int cdac_mmc_send_command(struct cdac_mmc_host *host, int wait,
+		struct mmc_command *cmd, struct mmc_data *data) {
+		
+		//printk(":SC_START");
+		
+		static int bus_width_1_flag=0;
+		static int bus_width_4_flag=0;
+		static int bus_width_8_flag=0;
+		UL status_reg_value = 0;
+		
+		do
+		{
+			status_reg_value = __raw_readq(HOST_STATUS(host));
+		}
+		while(!(status_reg_value & CDAC_MMC_STATUS_DEV_BUSY)); // Wait until device is IDLE : 0: Busy, 1: IDLE
+		
+		
+	
+	UL command, argument, resp_type, cmd_type,cmd_type1;
+	UL opmodereg_value = 0,reg_value = 0,int_status = 0;
+
+	UL flag = 0;
+	UL temp = 0;
+	
+	
+		
+
+	command = cmd->opcode;
+	argument = cmd->arg;
+	resp_type = mmc_resp_type(cmd);
+	cmd_type = (mmc_cmd_type(cmd));
+	
+		
+
+	if(cmd_type == MMC_CMD_AC)
+		cmd_type = 0x00;
+	else if(cmd_type == MMC_CMD_ADTC)
+		cmd_type = 0x03;
+	else if(cmd_type == MMC_CMD_BC)
+		cmd_type = 0x00;
+	else if(cmd_type == MMC_CMD_BCR)
+		cmd_type = 0x01;	
+		
+		
+		
+		
+	//cmd_type1 = (mmc_cmd_type(cmd));
+	flag =  cmd->flags;
+	
+
+	
+	if(resp_type == MMC_RSP_NONE)
+		resp_type = CMD_NO_RESP;// No response
+	else if((resp_type) == MMC_RSP_R1)
+		resp_type = CMD_RESP_LEN_48; // R1 (48  BIT RESPONSE)
+	else if((resp_type ) == 1)	
+		resp_type = CMD_RESP_LEN_48_WITH_BUSY; // R1b 
+	else if((resp_type) == MMC_RSP_R5)	
+		resp_type = CMD_RESP_LEN_48; // R5,R6,R7 (48  BIT RESPONSE) THESE RESPONSES ARE SAME AS PER "core.h" file.
+	else if((resp_type) == MMC_RSP_R1B)
+		resp_type = CMD_RESP_LEN_48_WITH_BUSY; // R1b (48  BIT RESPONSE WITH BUSY)
+	else if((resp_type ) == MMC_RSP_R2)
+		resp_type = CMD_RESP_LEN_136; // R2 (136 BIT)
+		
+	if(command == 1)
+	{
+		resp_type = CMD_RESP_LEN_48; // R3
+	}
+		
+	//cdac_pr_info(DRIVER_NAME ": @####HDG Test :: variable resp_type:  %lx \n",resp_type);
+	//cdac_pr_info(DRIVER_NAME ": ####HDG Test :: variable flag:  %lx \n",flag);
+//#ifdef DEBUG	
+	// cdac_pr_info(DRIVER_NAME ": HDG Test :: variable command:  %lx \n",command);
+	// cdac_pr_info(DRIVER_NAME ": HDG Test :: variable argument:  %lx \n",argument);
+	 cdac_pr_info(DRIVER_NAME ": HDG Test :: After change cmd_type:  %lx \n",cmd_type);
+	// //cdac_pr_info(DRIVER_NAME ": HDG Test :: variable cmd_type1:  %lx \n",cmd_type1);
+	 cdac_pr_info(DRIVER_NAME ": HDG Test :: Afher change resp_type:  %lx \n",resp_type);
+	// cdac_pr_info(DRIVER_NAME ": HDG Test :: variable resp_type-driver:  %lx \n",mmc_resp_type(cmd));
+	// cdac_pr_info(DRIVER_NAME ": HDG Test :: variable flag:  %lx \n",flag);
+//#endif
+	//cdac_pr_info(DRIVER_NAME ": \n\r\n\r\n\r"); 
+
+	reg_value = CDAC_MMC_CMD_INDEX(command) | CDAC_MMC_CMD_ARG(argument) | CDAC_MMC_CMD_TYPE(cmd_type) | CDAC_MMC_RSP_TYPE(resp_type);
+
+	temp = (reg_value & 0x3FFFFFFFC0) >>6;
+	//printk("\n C");
+	
+	//printk("\n\n\n Command:   %ld \n",command); //cdac1
+	
+	//printk("\n argument:   %lx \n",temp); //cdac1
+	
+	// cdac_pr_info(DRIVER_NAME ": HDG Test :: CDAC_MMC_CMD command:  %lx \n",CDAC_MMC_CMD_INDEX(command));
+	// cdac_pr_info(DRIVER_NAME ": HDG Test :: CDAC_MMC_CMD argument:  %lx \n",CDAC_MMC_CMD_ARG(argument));
+	// cdac_pr_info(DRIVER_NAME ": HDG Test :: CDAC_MMC_CMD resp_type:  %lx \n",CDAC_MMC_RSP_TYPE(resp_type));
+	// cdac_pr_info(DRIVER_NAME ": HDG Test :: CDAC_MMC_CMD ccmd_type:  %lx \n",CDAC_MMC_CMD_TYPE(cmd_type));
+
+	//cdac_pr_info(DRIVER_NAME "IE %lx \n",__raw_readq(HOST_IE(host)));
+
+
+	if(reg_value == 0x200EDC00040) // Checking if CMD=6 and Bus width = 1, Right shift value in () by 6 times to chec command.
+	{
+		//printk("BUS_WIDTH 1-------------------");
+		bus_width_1_flag = 1;
+	}
+	else if(reg_value == 0x200EDC04040) // Checking if CMD=6 and Bus width = 4
+	{
+		//printk("BUS_WIDTH 4-----NOT SUPPORTED--------------");
+		bus_width_4_flag = 1; // Currently unsupported by CDAC EMMC DUT
+	}
+	else if(reg_value == 0x200edc08046) // Checking if CMD=6 and Bus width = 8
+	{
+		//printk("BUS_WIDTH 8-------------------");
+		bus_width_8_flag = 1;
+	}
+	
+	if(command == 23){
+
+	//printk("\nCMD 23 ************ "); //cdac1
+	
+		opmodereg_value = __raw_readq(HOST_OP_MODE(host));	
+		//printk("Opmode Val BF %lx \n",opmodereg_value);
+		opmodereg_value &= ~((UL)1<<38); //Clear OpenEnded transaction bit in EMMC : HDG
+		/*if(data){
+		    printk("data->blocks %lx \n",data->blocks);
+		    opmodereg_value |=((UL)data->blocks << 45);
+		}
+		else{
+		        printk("error- \n");
+		        opmodereg_value |=((UL)0);
+		    }*/
+		    opmodereg_value |=((UL)argument << 45);
+
+		//printk("Opmode Val AF %lx \n",opmodereg_value);
+		__raw_writeq(opmodereg_value, HOST_OP_MODE(host));	
+	}
+	
+	if(command == 24){
+	// This may be deleted as no of blocks to write for single blk transaction will be updated in H/w.
+		opmodereg_value = __raw_readq(HOST_OP_MODE(host));
+		opmodereg_value &= 0xE0001FFFFFFFFFFF; // Clears bit from 45 to 60. 
+		opmodereg_value = opmodereg_value | (CDAC_MMC_OP_MODE_NUM_BLOCK(1UL))
+				| (CDAC_MMC_OP_MODE_LEN_BLOCK(512UL));
+		
+		
+		__raw_writeq(opmodereg_value, HOST_OP_MODE(host));
+		//printk("\n24 OPMODE VAL: 0x %lx ",opmodereg_value);
+	
+	}
+		
+	/*
+	else if(command == 3){
+
+	cdac_pr_info(DRIVER_NAME ":waiting intr %lx \n",reg_value);
+		__raw_writeq(0x0000018400000003, HOST_CMD(host)); //writing command and parameters
+
+	}
+	
+	else if(command == 5){
+
+	cdac_pr_info(DRIVER_NAME ":waiting intr %lx \n",reg_value);
+		__raw_writeq(0x0000018400000005, HOST_CMD(host)); //writing command and parameters
+
+	}
+	
+	else if(command == 7){
+
+	cdac_pr_info(DRIVER_NAME ":waiting intr %lx \n",reg_value);
+		__raw_writeq(0x0000028400000007, HOST_CMD(host)); //writing command and parameters
+
+	}
+	
+	else if(command == 8){
+
+	cdac_pr_info(DRIVER_NAME ":waiting intr %lx \n",reg_value);
+		__raw_writeq(0x000001C000000008, HOST_CMD(host)); //writing command and parameters
+
+	}
+	
+	
+		
+	else if(command == 9){
+
+	cdac_pr_info(DRIVER_NAME ":waiting intr %lx \n",reg_value);
+		__raw_writeq(0x0000038400000009, HOST_CMD(host)); //writing command and parameters
+
+	}*/
+	//else{
+		__raw_writeq(reg_value, HOST_CMD(host)); //writing command and parameters
+	//}
+	
+	cdac_pr_info(DRIVER_NAME ":reg_value %lx \n",reg_value);
+	
+	
+
+		
+	//cdac_pr_info(DRIVER_NAME ": cmd_reg %lx \n",__raw_readq(HOST_CMD(host)));
+	//status_reg_value = __raw_readq(HOST_STATUS(host));
+	//cdac_pr_info(DRIVER_NAME ":status_reg_value %lx \n",status_reg_value);
+	///while (!(__raw_readq(HOST_STATUS(host)) & (CDAC_MMC_STATUS_CMD_SENT))); //waiting for command to be sent
+	
+	
+	// reg_value = HOST_LWR_CSD(host);
+	
+	// cdac_pr_info(DRIVER_NAME ":Low Resp Reg %lx \n",reg_value);
+	
+	// reg_value = HOST_UPR_CSD(host);
+	
+	// cdac_pr_info(DRIVER_NAME ":Upp Resp Reg %lx \n",reg_value);
+	
+	
+	//cdac_pr_info(DRIVER_NAME ":cdac_mmc_CMD_SENT\n");
+//cdac_pr_info(DRIVER_NAME ":cdac_mmc_send_command end\n");cdac_mmc_send_command
+
+//int_status = __raw_readq(HOST_INTERRUPT_STATUS(host));
+//	cdac_pr_info(DRIVER_NAME ": Interrupt Status %lx \n",int_status);
+	//Transmit_uart("\n\r  CMD SENT !!! ");
+//status_reg_value = __raw_readq(HOST_STATUS(host));
+//cdac_mmc_cmd_complete(host, status_reg_value);
+
+	cdac_pr_info(DRIVER_NAME ": ***** AF OPMODE REG VAL %lx \n",__raw_readq(HOST_OP_MODE(host)));
+			//printk(":SC_END");
+	return 0;
+
+}
+
+static void cdac_mmc_data_complete(struct cdac_mmc_host *host, UI status) {
+	struct mmc_request *mrq = host->mrq;
+	struct mmc_data *data;
+	UI crc;
+	cdac_pr_info(DRIVER_NAME ":cdac_mmc_data_complete\n");
+	//WARN_ON((host->status != HOST_S_DATA) && (host->status != HOST_S_STOP));
+
+	if (host->mrq == NULL)
+		return;
+
+	data = mrq->cmd->data;
+
+	//if (status == 0)
+	//	status = __raw_readq(HOST_STATUS(host));
+		
+	cdac_printk("***** aaa *********");
+
+	/* The transaction is really over when the SD_STATUS_DB bit is clear */
+	//	while ((host->flags & HOST_F_XMIT) && (status & SD_STATUS_DB))
+	//status = __raw_readq(HOST_STATUS(host));
+	
+	cdac_printk("***** BBB *********");
+
+	data->error = 0;
+	//dma_unmap_sg(mmc_dev(host->mmc), data->sg, data->sg_len, host->dma.dir);
+
+	/* Process any errors */
+	//crc = (status & (SD_STATUS_WC | SD_STATUS_RC));
+	/*if (host->flags & HOST_F_XMIT)
+		crc |= ((status & 0x07) == 0x02) ? 0 : 1;
+
+	if (crc){
+		printk("CRC :error%d\n",crc);
+		data->error = -EILSEQ;
+		}
+		
+	cdac_printk("CRC :%d",crc);*/
+		
+	cdac_printk("***** CCC *********");
+
+	/* Clear the CRC bits */
+	//__raw_writeq(SD_STATUS_WC | SD_STATUS_RC, HOST_STATUS(host));
+	//data->bytes_xfered = 0;
+
+	if (!data->error) {
+	
+		//data->bytes_xfered = (data->blocks * data->blksz) - host->pio.len;
+		//printk("data->bytes_xfered :%d",data->bytes_xfered);
+	}
+	
+	cdac_printk("***** DDD *********");
+
+	cdac_mmc_finish_request(host);
+	
+	cdac_printk("***** EEE *********");
+}
+
+static void cdac_mmc_tasklet_data(unsigned long param) {
+	struct cdac_mmc_host *host = (struct cdac_mmc_host*) param;
+	cdac_pr_info(DRIVER_NAME ":cdac_mmc_tasklet_data\n");
+	UI status;
+	cdac_mmc_data_complete(host, status);
+}
+
+#define CDAC_MMC_MAX_TRANSFER 64
+
+
+
+static void cdac_emmc_push_data(struct cdac_mmc_host *host, void *buf, int cnt){
+
+	UL tx_mem_phy_addr;
+	UL wTempCtrlVal = 0;
+	volatile unsigned long *tx_memory;
+	tx_memory = (unsigned long *)kmalloc(cnt, GFP_KERNEL);
+	tx_mem_phy_addr = virt_to_phys(tx_memory);
+	UI status;
+	UI i;
+	
+	//printk("*******tx_mem_phy_addr %lx",tx_mem_phy_addr);
+	
+	/*printk("*******TX DATA");
+	for(i=0;i<64;i++)
+	{
+	 printk("\n %lx",tx_memory[i*8]);
+	}*/
+	
+	memcpy(tx_memory,buf,cnt);
+	//memcpy(gTx_memory,tx_memory,host->pio.len);
+#ifdef SINGLE_CORE_EMMC	
+	write_csr(0x5c8,1); // flush data
+
+	
+#endif	
+	/************DMA ROUTINE**************/
+
+	__raw_writeq(tx_mem_phy_addr, DMA_CH0_SRC_ADDR_REG(host));
+	__asm__ __volatile__ ("fence");
+	
+	__raw_writeq((EHC_BASE_ADDRESS + WR_DATA_FIFO), DMA_CH0_DST_ADDR_REG(host));
+	__asm__ __volatile__ ("fence");
+
+	__raw_writeq(0, DMA_CH0_LLI_REG(host));
+	__asm__ __volatile__ ("fence");
+	
+#ifdef SINGLE_CORE_EMMC
+
+	Init_DMA_Ch_CtrlReg_params_sram_to_sram
+		(DCE_ENABLE, CIE_ENABLE, SRC_DW_128, DST_DW_128,DAI_DISABLE,\
+				SAI_ENABLE, CBE_ENABLE, CMS_AXI2AXI, CTS_16, CBS_2);
+	wTempCtrlVal = gDMAtransfer.Control.dword;
+
+#endif
+#ifdef DUAL_CORE_EMMC
+	wTempCtrlVal = 0;
+	/*Init_DMA_Ch_CtrlReg_params_sram_to_sram
+	(DCE_ENABLE, CIE_ENABLE, SRC_DW_128, DST_DW_128,DAI_DISABLE,\
+			SAI_ENABLE, CBE_ENABLE, CMS_AXI2ACE, CTS_16, CBS_2);*/
+			
+	Init_DMA_Ch_CtrlReg_params_sram_to_sram
+	(DCE_ENABLE, CIE_ENABLE, SRC_DW_128, DST_DW_128,DAI_DISABLE,\
+			SAI_ENABLE, CBE_ENABLE, CMS_ACE2AXI, CTS_16, CBS_2);
+			
+			
+	wTempCtrlVal = gDMAtransfer.Control.dword;
+	
+#endif
+	__raw_writeq(wTempCtrlVal, DMA_CH0_CTRL_STATUS_REG(host));
+
+	
+	//pr_info(DRIVER_NAME ": DMA Transfer Completed\n");
+
+	/************DMA ROUTINE END**************/
+	
+	Check_DMAC_transferDone(host,0);
+	kfree(tx_memory);
+			//printk("Check_DMAC_transferDone *******  \n");
+	status = __raw_readq(HOST_STATUS(host));
+	if (status & CDAC_MMC_STATUS_WTRANS_TMOUT_ERR) {
+		DBG("Write transaction timeout error [%d + %d]\n", host->pdev->id, host->pio.len,
+				count);
+		return;
+	}
+
+}
+
+
+void cdac_mmc_send_pio(struct cdac_mmc_host *host) {
+	int i;
+	struct mmc_data *data;
+	int sg_len, max, count;
+	unsigned char  val;
+	volatile unsigned char *sg_ptr = NULL;
+	UL status;
+	unsigned long reg_val = 0;
+	struct scatterlist *sg;
+	
+	static volatile void *buf;
+	unsigned int offset;
+	unsigned int len;
+	//unsigned int fifo_depth = host->fifo_depth;
+	unsigned int remain, fcnt;
+
+	
+	//pr_info(DRIVER_NAME ":cdac_mmc_send_pio\n");//cdac
+	
+	
+	
+	if (!(host->flags & HOST_F_XMIT))
+		return;
+		
+			//pr_info(DRIVER_NAME ":cdac_mmc_send_pio 2\n");//cdac
+		
+	
+	//printk("\n\r host->mrq->data 0x%lx\n",&host->mrq->data);	
+	data = host->mrq->data;	
+		
+		/* This is the pointer to the data buffer */
+	//sg = data->sg;
+	//sg_ptr = kmap_atomic(sg_page(sg));
+
+	cdac_printk("data->sg[host->pio.index].length %lx",data->sg[host->pio.index].length);
+	cdac_printk("host->pio.offset %lx:", host->pio.offset);
+	cdac_printk("sg_len %lx",sg_len);
+	cdac_printk("host->pio.len %lx",host->pio.len);
+
+		//pr_info(DRIVER_NAME ":cdac_mmc_send_pio 1\n");//cdac
+	
+	/*#######################################*/
+	
+	UI no_of_blks = 0;
+
+	//memcpy(gTx_memory,tx_memory,host->pio.len);
+	
+
+
+	remain = host->pio.len;
+	offset = 0;
+	
+	//sg = &data->sg[host->pio.index];
+	sg = data->sg;
+	sg_ptr = kmap_atomic(sg_page(sg)) + sg->offset;
+	buf = sg_ptr;
+	
+		//printk("sg->offset %lx\n",sg->offset);
+
+	do {
+		fcnt = 512;
+		len = min(remain, fcnt);
+		if (!len)
+			break;
+		//while((__raw_readq(HOST_STATUS(host)) & CDAC_MMC_STATUS_WDATA_FIFO_FULL) == 1);
+		
+	
+			
+		cdac_emmc_push_data(host, (void *)(buf + offset), len);
+		data->bytes_xfered += len;
+		offset += len;
+		remain -= len;
+		//printk("Send Remain******* %d \n",remain);
+		if(remain)
+			while((__raw_readq(HOST_STATUS(host)) & CDAC_MMC_STATUS_WDATA_FIFO_EMP) == 0);
+			
+		//printk("Send Remain dddd******* %d \n",remain);
+
+
+	} while (remain);
+		
+	//kfree(tx_memory);
+	kunmap_atomic(sg_ptr);
+	//IRQ_OFF(host, SD_CONFIG_TH); //Disable FIFO empty interrupt
+	IRQ_OFF(host,CDAC_MMC_INTR_EN_WR_DATA_FIFO_EMPTY_INTR);
+
+	if (host->flags & HOST_F_STOP)
+		SEND_STOP(host); //FIXME
+
+	//printk("\n\rafter send stop%lx\n");	
+
+	tasklet_schedule(&host->data_task);
+
+}
+/*
+void cdac_mmc_send_pio_sgr(struct cdac_mmc_host *host) {
+	struct mmc_data *data;
+	int sg_len, max, count;
+	unsigned char  val;
+	unsigned char *sg_ptr = NULL;
+	UL status;
+	unsigned long reg_val = 0;
+	struct scatterlist *sg;
+	
+	cdac_pr_info(DRIVER_NAME ":cdac_mmc_send_pio_sgr\n");
+	
+	if (!(host->flags & HOST_F_XMIT))
+		return;
+		
+			
+	data = host->mrq->data;	
+		
+		/* This is the pointer to the data buffer */
+/*	sg = &data->sg[host->pio.index];
+	sg_ptr = kmap_atomic(sg_page(sg)) + sg->offset + host->pio.offset;
+	cdac_printk("sg->offset %lx",sg->offset);
+	cdac_printk("data->sg[host->pio.index].length %lx",data->sg[host->pio.index].length);
+	cdac_printk("host->pio.offset %lx:", host->pio.offset);
+	cdac_printk("sg_len %lx",sg_len);
+	cdac_printk("host->pio.len %lx",host->pio.len);
+
+	
+	
+	/*#######################################*/
+	
+/*	UI no_of_blks = 0;
+	UL tx_mem_phy_addr;
+	volatile unsigned long *tx_memory;
+	tx_memory=(unsigned long *)kmalloc((host->pio.len), GFP_KERNEL);
+	tx_mem_phy_addr = virt_to_phys(tx_memory);
+	
+	memcpy(tx_memory,sg_ptr,host->pio.len);
+#ifdef SINGLE_CORE_EMMC	
+	write_csr(0x5c8,1); // flush data
+#endif	
+	/************DMA ROUTINE**************/
+/*	UL wTempCtrlVal = 0;
+
+	__raw_writeq(tx_mem_phy_addr, DMA_CH0_SRC_ADDR_REG(host));
+	__asm__ __volatile__ ("fence");
+	
+	__raw_writeq((EHC_BASE_ADDRESS + WR_DATA_FIFO), DMA_CH0_DST_ADDR_REG(host));
+	__asm__ __volatile__ ("fence");
+
+	__raw_writeq(0, DMA_CH0_LLI_REG(host));
+	__asm__ __volatile__ ("fence");
+	
+#ifdef SINGLE_CORE_EMMC
+
+	Init_DMA_Ch_CtrlReg_params_sram_to_sram
+		(DCE_ENABLE, CIE_ENABLE, SRC_DW_128, DST_DW_128,DAI_DISABLE,\
+				SAI_ENABLE, CBE_ENABLE, CMS_AXI2AXI, CTS_16, CBS_2);
+	wTempCtrlVal = gDMAtransfer.Control.dword;
+
+#endif
+#ifdef DUAL_CORE_EMMC
+	wTempCtrlVal = 0;
+	Init_DMA_Ch_CtrlReg_params_sram_to_sram
+	(DCE_ENABLE, CIE_ENABLE, SRC_DW_128, DST_DW_128,DAI_DISABLE,\
+			SAI_ENABLE, CBE_ENABLE, CMS_AXI2ACE, CTS_16, CBS_2);
+	wTempCtrlVal = gDMAtransfer.Control.dword;
+	//Transmit_uart("\n\r DMA wTempCtrlVal : 0x ");disp_Rx_data_UL(wTempCtrlVal);
+	cdac_pr_info(DRIVER_NAME "SR_DMA wTempCtrlVal : 0x  0x %lx \n",wTempCtrlVal);
+
+#endif
+	__raw_writeq(wTempCtrlVal, DMA_CH0_CTRL_STATUS_REG(host));
+
+	
+	cdac_pr_info(DRIVER_NAME ": DMA Transfer Completed\n");
+
+	/************DMA ROUTINE END**************/
+	/*#######################################*/
+	
+	
+/*	if (status & CDAC_MMC_STATUS_WDATA_FIFO_FULL)
+		return; // Write data FIFO is FULL
+
+
+	if (status & CDAC_MMC_STATUS_WTRANS_TMOUT_ERR) {
+		DBG("Write transaction timeout error [%d + %d]\n", host->pdev->id, host->pio.len,
+				count);
+		return;
+	}
+	
+	Check_DMAC_transferDone(host,0);
+	__asm__ __volatile__ ("fence");
+
+
+
+
+	/* This is the space left inside the buffer */
+/*	sg_len = data->sg[host->pio.index].length - host->pio.offset;
+	cdac_printk("AFTER TRASFER");
+	cdac_printk("data->sg[host->pio.index].length %lx",data->sg[host->pio.index].length);
+	cdac_printk("host->pio.offset %lx:", host->pio.offset);
+	cdac_printk("sg_len %lx",sg_len);
+	cdac_printk("host->pio.len %lx",host->pio.len);
+	reg_val = __raw_readq(HOST_STATUS(host));
+	cdac_printk("HOST_STATUS VAL: 0x %lx bytes",reg_val);
+
+	/* Check if we need less than the size of the sg_buffer */
+	//max = (sg_len > host->pio.len) ? host->pio.len : sg_len;
+	//if (max > CDAC_MMC_MAX_TRANSFER)
+	//	max = CDAC_MMC_MAX_TRANSFER;
+		
+	//cdac_printk(" host->pio.len %lx:",  host->pio.len);
+	//cdac_printk(" max %lx:",  max);
+	
+/*	kfree(tx_memory);
+
+/*
+	for (count = 0; count < max; count++) {
+	
+		cdac_printk("count %lx",count);
+		status = __raw_readq(HOST_STATUS(host));
+		cdac_printk("status %lx",status);
+		
+
+		if ((status & CDAC_MMC_STATUS_WFIFO_FULL)) //checks whether WFIFO is full
+			break;
+
+		val = sg_ptr[count];
+		
+		cdac_printk("val %lx",val);
+
+		__raw_writeq((unsigned long) val, HOST_WR_DATA_FIFO(host));
+		wmb(); /* drain writebuffer */
+	//}
+	
+/*	kunmap_atomic(sg_ptr);
+
+	//host->pio.len -= count;
+	//host->pio.offset += count;
+	
+	host->pio.len -= 512;
+	host->pio.offset += 512;
+	
+	
+	
+	//host->pio.offset += host->pio.len;
+	//host->pio.len = 0;
+
+	/*if (count == sg_len) {
+		host->pio.index++;
+		host->pio.offset = 0;
+	}*/
+	
+/*	if (host->pio.len == 0) {
+		IRQ_OFF(host,CDAC_MMC_INTR_EN_WR_DATA_FIFO_EMPTY_INTR);
+
+		if (host->flags & HOST_F_STOP)
+			SEND_STOP(host); //FIXME
+
+		tasklet_schedule(&host->data_task);
+		cdac_printk("Tx Complete Set*******");
+		return;
+	}	
+
+
+}*/
+
+/*
+static void cdac_mmc_send_pio_old(struct cdac_mmc_host *host) {
+	struct mmc_data *data;
+	int sg_len, max, count;
+	unsigned char *sg_ptr, val;
+	UL status;
+	struct scatterlist *sg;
+	cdac_pr_info(DRIVER_NAME ":cdac_mmc_send_pio\n");
+	data = host->mrq->data;
+	
+	if (!(host->flags & HOST_F_XMIT))
+		return;
+	
+	/* This is the pointer to the data buffer */
+/*	sg = &data->sg[host->pio.index];
+	sg_ptr = kmap_atomic(sg_page(sg)) + sg->offset + host->pio.offset;
+	
+	
+	
+	cdac_printk("sg->offset %lx",sg->offset);
+	
+
+
+	/* This is the space left inside the buffer */
+/*	sg_len = data->sg[host->pio.index].length - host->pio.offset;
+	cdac_printk("data->sg[host->pio.index].length %lx",data->sg[host->pio.index].length);
+	cdac_printk("host->pio.offset %lx:", host->pio.offset);
+	cdac_printk("sg_len %lx",sg_len);
+	cdac_printk("host->pio.len %lx",host->pio.len);
+
+	/* Check if we need less than the size of the sg_buffer */
+/*	max = (sg_len > host->pio.len) ? host->pio.len : sg_len;
+	if (max > CDAC_MMC_MAX_TRANSFER)
+		max = CDAC_MMC_MAX_TRANSFER;
+		
+	cdac_printk(" host->pio.len %lx:",  host->pio.len);
+	cdac_printk(" max %lx:",  max);
+
+	for (count = 0; count < max; count++) {
+	
+		cdac_printk("count %lx",count);
+		status = __raw_readq(HOST_STATUS(host));
+		cdac_printk("status %lx",status);
+		
+
+		if ((status & CDAC_MMC_STATUS_WFIFO_FULL)) //checks whether WFIFO is full
+			break;
+
+		val = sg_ptr[count];
+		
+		cdac_printk("val %lx",val);
+
+		__raw_writeq((unsigned long) val, HOST_WR_DATA_FIFO(host));
+		wmb(); /* drain writebuffer */
+/*	}
+	kunmap_atomic(sg_ptr);
+
+	host->pio.len -= count;
+	host->pio.offset += count;
+
+/*	if (count == sg_len) {
+		host->pio.index++;
+		host->pio.offset = 0;
+	}
+
+	if (host->pio.len == 0) {
+		//IRQ_OFF(host, SD_CONFIG_TH); //Disable FIFO empty interrupt
+		IRQ_OFF(host,CDAC_MMC_INTR_EN_WR_DATA_FIFO_EMPTY_INTR);
+
+		if (host->flags & HOST_F_STOP)
+			SEND_STOP(host); //FIXME
+
+		tasklet_schedule(&host->data_task);
+	}
+}*/
+
+
+
+static void cdac_emmc_pull_data(struct cdac_mmc_host *host, void *buf, int cnt){
+
+	volatile unsigned long *rx_memory;
+	u64 rx_mem_phy_addr;
+	u64 wTempCtrlVal = 0;
+
+	rx_memory = (unsigned long *)kmalloc(cnt, GFP_KERNEL);
+	rx_mem_phy_addr = virt_to_phys(rx_memory);
+
+	/************DMA ROUTINE**************/
+
+	__raw_writeq((EHC_BASE_ADDRESS + 0xD0), DMA_CH0_SRC_ADDR_REG(host));
+	__asm__ __volatile__ ("fence");
+	
+	__raw_writeq(rx_mem_phy_addr, DMA_CH0_DST_ADDR_REG(host));
+	__asm__ __volatile__ ("fence");
+
+	__raw_writeq(0, DMA_CH0_LLI_REG(host));
+	__asm__ __volatile__ ("fence");
+	
+#ifdef SINGLE_CORE_EMMC
+	Init_DMA_Ch_CtrlReg_params_sram_to_sram
+		(DCE_ENABLE, CIE_ENABLE, SRC_DW_128, DST_DW_128,DAI_ENABLE,\
+				SAI_DISABLE, CBE_ENABLE, CMS_AXI2AXI, CTS_16, CBS_2);
+	wTempCtrlVal = gDMAtransfer.Control.dword;
+
+#endif
+#ifdef DUAL_CORE_EMMC
+	wTempCtrlVal = 0;
+	/*Init_DMA_Ch_CtrlReg_params_sram_to_sram
+	(DCE_ENABLE, CIE_ENABLE, SRC_DW_128, DST_DW_128,DAI_ENABLE,\
+			SAI_DISABLE, CBE_ENABLE, CMS_AXI2ACE, CTS_16, CBS_2);*/
+			
+			
+	Init_DMA_Ch_CtrlReg_params_sram_to_sram
+	(DCE_ENABLE, CIE_ENABLE, SRC_DW_128, DST_DW_128,DAI_ENABLE,\
+			SAI_DISABLE, CBE_ENABLE, CMS_AXI2ACE, CTS_16, CBS_2);
+			
+	wTempCtrlVal = gDMAtransfer.Control.dword;
+	//Transmit_uart("\n\r DMA wTempCtrlVal : 0x ");disp_Rx_data_UL(wTempCtrlVal);
+	cdac_pr_info(DRIVER_NAME "SR_DMA wTempCtrlVal : 0x  0x %lx \n",wTempCtrlVal);
+
+#endif
+	__raw_writeq(wTempCtrlVal, DMA_CH0_CTRL_STATUS_REG(host));
+
+	Check_DMAC_transferDone(host,0);
+	__asm__ __volatile__ ("fence");
+
+	//printk("RR: DMA Transfer Completed\n");
+
+	/************DMA ROUTINE END**************/
+	
+#ifdef SINGLE_CORE_EMMC	
+	write_csr(0x5c8,1); // flush data
+
+#endif
+
+	memcpy(buf, rx_memory, cnt);
+	//printk("RR: DMA Transfer Completed 11\n");
+//	memcpy(gRx_memory, rx_memory, host->pio.len);
+	
+	kfree(rx_memory);
+		//printk("RR: DMA Transfer Completed 22\n");
+
+}
+
+
+void cdac_mmc_receive_pio(struct cdac_mmc_host *host) {
+
+	int i;
+	struct mmc_data *data;
+	int max,rx_len, count, sg_len = 0;
+	volatile unsigned char *sg_ptr = NULL;
+	UI status, val,no_of_blks = 0;
+	UL reg_value,rx_mem_phy_addr;
+	struct scatterlist *sg;
+	//pr_info(DRIVER_NAME ":cdac_mmc_receive_pio\n");
+	data = host->mrq->data;
+	unsigned int len;
+	static volatile void *buf;
+	unsigned int remain, fcnt;
+	unsigned int offset;
+
+
+	
+	no_of_blks = data->blocks;
+	//printk("No of Blks:%d %d\n",no_of_blks, data->blksz);
+	
+
+	// sg = data->sg;
+	 
+	remain = host->pio.len;
+	offset = 0;
+	
+	//sg = &data->sg[host->pio.index];
+	sg = data->sg;
+	sg_ptr = kmap_atomic(sg_page(sg)) + sg->offset;
+	buf = sg_ptr;	
+
+	//printk("\n pull sg->offset %lx",sg->offset);
+	do {
+			fcnt = 512;
+			len = min(remain, fcnt);
+			if (!len)
+				break;
+			//while((__raw_readq(HOST_STATUS(host)) & CDAC_MMC_STATUS_BLK_RX_AVILABLE) == 0);
+
+
+			status = __raw_readq(HOST_STATUS(host));
+			
+			//if (status & CDAC_MMC_STATUS_BOOT_FIFO_EMP)
+			//	return; ///Stop copying Rx data if Rx FIFO is empty
+
+			if (status & CDAC_MMC_STATUS_RX_CRC_ERR) {
+				DBG("RX CRC Error [%d + %d].\n", host->pdev->id, host->pio.len, count);
+				return;
+			}
+
+			if (status & CDAC_MMC_STATUS_RDATA_END_BIT_ERR) {
+				DBG("Rd data end bit error [%d + %d]\n", host->pdev->id, host->pio.len,
+						count);
+				return;
+			}
+
+			if (status & CDAC_MMC_STATUS_RD_TRANSN_TIMEOUT_ERR) {
+				DBG("RD transaction TIMEOUT [%d + %d]\n", host->pdev->id, host->pio.len,
+						count);
+				return;
+			}
+
+
+	
+			cdac_emmc_pull_data(host, (void *)(buf + offset), len);
+			data->bytes_xfered += len;
+			offset += len;
+			remain -= len;
+			//printk("Receive remain****** \n");
+			if(remain)
+				while((__raw_readq(HOST_STATUS(host)) & CDAC_MMC_STATUS_BOOT_FIFO_EMP));
+			//printk("Receive remain dddd******\n");
+
+
+		} while (remain);
+
+	
+	
+
+	if (!(host->flags & HOST_F_RECV))
+		return;
+
+
+	kunmap_atomic(sg_ptr);
+
+	
+
+	//memcpy(gRx_memory, rx_memory, host->pio.len);
+	
+	//printk("RX DATA*******");
+	for(i=0;i<64;i++)
+	{
+	// printk("\n %lx",rx_memory[i*8]);
+	}
+	
+	//printk("\n NEXT READ " );
+	
+	/*for (count = 0; count < rx_len; count++) 
+	{
+ 		cdac_printk("%02x",sg_ptr[count]); // HDG: Prints value to UART 
+
+ 		if((count % 8) == 0)
+ 			cdac_pr_info("\n");
+
+	}*/
+	
+	//kfree(rx_memory);
+		
+	/*if (sg_ptr)
+	{
+		kunmap_atomic(sg_ptr);
+	}*/
+
+	host->pio.index = 0;
+
+	//pr_info(DRIVER_NAME "II********\n");
+	IRQ_OFF(host, CDAC_MMC_INTR_EN_NUM_BLK_AVL_BOOT_FIFO_INTR); 
+	if (host->flags & HOST_F_STOP)
+		SEND_STOP(host);
+
+	tasklet_schedule(&host->data_task);
+	
+}
+
+/*
+static void cdac_mmc_receive_pio(struct cdac_mmc_host *host) {
+	struct mmc_data *data;
+	int rx_len, count, sg_len = 0;
+	unsigned char *sg_ptr = NULL;
+	UI status, val;
+	UL reg_value;
+	struct scatterlist *sg;
+	cdac_pr_info(DRIVER_NAME ":cdac_mmc_receive_pio\n");
+	data = host->mrq->data;
+
+	if (!(host->flags & HOST_F_RECV))
+		return;
+
+	///max = host->pio.len;
+
+	/*if (host->pio.index < host->dma.len) {
+	 sg = &data->sg[host->pio.index];
+	 sg_ptr = kmap_atomic(sg_page(sg)) + sg->offset + host->pio.offset;
+
+	 /// This is the space left inside the buffer
+	 sg_len = sg_dma_len(&data->sg[host->pio.index]) - host->pio.offset;
+
+	 /// Check if we need less than the size of the sg_buffer
+	 if (sg_len < max)
+	 max = sg_len;
+	 }
+
+	 if (max > CDAC_MMC_MAX_TRANSFER)
+	 max = CDAC_MMC_MAX_TRANSFER;*/
+
+/*	status = __raw_readq(HOST_STATUS(host));
+	
+	reg_value = __raw_readq(HOST_STATUS(host));
+	
+	cdac_pr_info(DRIVER_NAME "HOST STATUS data  0x %lx \n",reg_value);
+
+	if (status & CDAC_MMC_STATUS_BOOT_FIFO_EMP)
+		return; ///Stop copying Rx data if Rx FIFO is empty
+
+	if (status & CDAC_MMC_STATUS_RX_CRC_ERR) {
+		DBG("RX CRC Error [%d + %d].\n", host->pdev->id, host->pio.len, count);
+		return;
+	}
+
+	if (status & CDAC_MMC_STATUS_RDATA_END_BIT_ERR) {
+		DBG("Rd data end bit error [%d + %d]\n", host->pdev->id, host->pio.len,
+				count);
+		return;
+	}
+
+	if (status & CDAC_MMC_STATUS_RD_TRANSN_TIMEOUT_ERR) {
+		DBG("RD transaction TIMEOUT [%d + %d]\n", host->pdev->id, host->pio.len,
+				count);
+		return;
+	}
+
+	///rx_len = read from ststus register * 512;
+
+	//Call DMA function to copy rx_len bytes of data
+
+	/*for (count = 0; count < max; count++) {
+
+	 val = __raw_readq(HOST_RD_DATA_FIFO(host));
+
+	 if (sg_ptr)
+	 sg_ptr[count] = (unsigned char) (val & 0xFF);
+	 }*/
+	 
+/*	if (sg_ptr)
+		kunmap_atomic(sg_ptr);
+
+	host->pio.len -= count;
+	host->pio.offset += count;
+
+	if (sg_len && count == sg_len) {
+		host->pio.index++;
+		host->pio.offset = 0;
+	}
+
+	if (host->pio.len == 0) {
+		/* IRQ_OFF(host, SD_CONFIG_RA | SD_CONFIG_RF); */
+		//		IRQ_OFF(host, SD_CONFIG_NE); //Disable Rx FIFO not empt bit in Interrupt enable register
+/*		IRQ_OFF(host, CDAC_MMC_INTR_EN_NUM_BLK_AVL_BOOT_FIFO_INTR); 
+		if (host->flags & HOST_F_STOP)
+			SEND_STOP(host);
+
+		tasklet_schedule(&host->data_task);
+	}
+}*/
+
+/* This is called when a command has been completed - grab the response
+ * and check for errors.  Then start the data transfer if it is indicated.
+ */
+void cdac_mmc_cmd_complete(struct cdac_mmc_host *host) {
+
+	struct mmc_request *mrq = host->mrq;
+	struct mmc_command *cmd;
+	UL r[4],dUpper_resp = 0,dLower_resp = 0,status = 0;
+	int i, trans;
+	unsigned long response = 0;
+	
+	//printk("\n t");
+		
+	if (!host->mrq)
+		return;
+
+	cmd = mrq->cmd;
+	
+	
+
+	UL cmd_reg_value = __raw_readq(HOST_CMD(host));
+
+
+	if (((cmd_reg_value >> 40) & 0x03) != CDAC_MMC_RSP_NONE) {
+	
+
+
+	while(1)
+	{	
+		//cdac_printk("I");
+		status = __raw_readq(HOST_STATUS(host));
+		if(status & CDAC_MMC_STATUS_CMD_RSP_TO_ERR){
+		printk("CMD: %d\n",cmd->opcode);
+			pr_info(DRIVER_NAME "####Resp Timeout Occured");
+			host->status = HOST_S_DATA;
+			cmd->error = -1;
+			break;
+		}
+		if (status & CDAC_MMC_STATUS_RSP_RXD)
+		{
+			//response =  (__raw_readq(HOST_LWR_RSP(host)));
+			//printk("\n LResp 0x: %lx\n",response);
+			//response =  (__raw_readq(HOST_UPR_RSP(host)));
+			//printk("\n UResp 0x: %lx\n",response);
+			break;
+		}
+
+	}
+	
+			
+		if (status & CDAC_MMC_STATUS_RSP_RXD) {
+			cdac_pr_info(DRIVER_NAME ":BBB \n" );
+			 if (((cmd_reg_value >> 40) & 0x03) == CDAC_MMC_RSP_136){
+				//cdac_pr_info(DRIVER_NAME ":DDD \n" );
+				/* original code
+				cmd->resp[0] = (__raw_readq(HOST_LWR_RSP(host))& 0xFFFFFFFF);
+				cmd->resp[1] = (__raw_readq(HOST_LWR_RSP(host)) >>32);
+				cmd->resp[2] = (__raw_readq(HOST_UPR_RSP(host))& 0xFFFFFFFF); 
+				cmd->resp[3] = (__raw_readq(HOST_UPR_RSP(host)) >>32); 
+				*/	
+
+				dLower_resp =  (__raw_readq(HOST_LWR_RSP(host)));
+				// Below code used for testing: HDG
+				r[3] = (UI)(dLower_resp& 0xFFFFFFFF);
+				r[2] = (UI)(dLower_resp >>32);
+				
+				//cdac_pr_info(DRIVER_NAME "####dUpper_resp  %lx \n",dUpper_resp );
+				
+		
+				dUpper_resp  = (__raw_readq(HOST_UPR_RSP(host)));			
+				//cdac_pr_info(DRIVER_NAME "####as such dUpper_resp %lx \n",dUpper_resp );
+				
+				//dUpper_resp  = (dUpper_resp << 8);				
+				//cdac_pr_info(DRIVER_NAME "####shifted by 8 dUpper_resp %lx \n",dUpper_resp );
+				
+				r[1] = (UI)(dUpper_resp & 0xFFFFFFFF); 
+				//cdac_pr_info(DRIVER_NAME "####as such dUpper_resp LSB %lx \n",cmd->resp[2] );
+				
+				r[0] = (UI)(dUpper_resp >>32); 
+				//cdac_pr_info(DRIVER_NAME "####as such dUpper_resp MSB %lx \n",cmd->resp[3] );
+				
+				/* The CRC is omitted from the response, so really
+				 * we only got 120 bytes, but the engine expects
+				 * 128 bits, so we have to shift things up.
+				 */
+				for (i = 0; i < 4; i++) {
+					cmd->resp[i] = (r[i] & 0x00FFFFFF) << 8;
+					if (i != 3)
+						cmd->resp[i] |= (r[i + 1] & 0xFF000000) >> 24;
+				}
+
+			}
+			else
+			{
+				cdac_pr_info(DRIVER_NAME ":CCC \n" );
+				cmd->resp[0] = (UI)(__raw_readq(HOST_LWR_RSP(host))& 0xFFFFFFFF);
+				cmd->resp[1] = 0;//(UI)(__raw_readq(HOST_LWR_RSP(host)) >>32);
+				cmd->resp[2] = 0;
+				cmd->resp[3] = 0;
+
+			}
+			//#ifdef DEBUG	
+			/*if(cmd->opcode == 13)
+			{
+			pr_info(DRIVER_NAME ":cmd->resp[0]  %lx \n",cmd->resp[0] );
+			pr_info(DRIVER_NAME ":cmd->resp[1]  %lx \n",cmd->resp[1] );
+			pr_info(DRIVER_NAME ":cmd->resp[2]  %lx \n",cmd->resp[2] );
+			pr_info(DRIVER_NAME ":cmd->resp[3]  %lx \n",cmd->resp[3] );
+			}*/
+			//#endif
+		}
+	}
+
+	/* Figure out errors */
+	/*if (status & (CDAC_MMC_STATUS_CMD_RSP_TXN_ERR | CDAC_MMC_STATUS_CMD_RSP_END_ERR
+					| CDAC_MMC_STATUS_CMD_RSP_TO_ERR))
+					
+
+	cmd->error = -EILSEQ;*/
+
+	trans = host->flags & (HOST_F_XMIT | HOST_F_RECV);
+	
+	cdac_printk("Status:0x %lx", status);
+
+	command_complete_flag = 1; //command complete
+
+	if (!trans || cmd->error) {
+	
+		
+		//printk("cmd finish %d %x %x\n", cmd->opcode, host->flags, cmd->error);
+		//printk("Trans:0x %lx", trans);
+		//	IRQ_OFF(host, SD_CONFIG_TH | SD_CONFIG_RA | SD_CONFIG_RF);
+		tasklet_schedule(&host->finish_task);
+		//printk("END ");
+		return;
+	}
+	
+
+
+	host->status = HOST_S_DATA;
+
+	/*if ((host->flags & (HOST_F_DMA | HOST_F_DBDMA))) {
+		//UI channel = DMA_CHANNEL(host);
+
+		/* Start the DBDMA as soon as the buffer gets something in it */
+
+		/*if (host->flags & HOST_F_RECV) {
+			//			UI mask = SD_STATUS_DB | SD_STATUS_NE;
+
+			//		while ((status & mask) != mask)
+			//status = __raw_readq(HOST_STATUS(host));
+		}
+
+		//	cdac_xx_dbdma_start(channel);
+	}*/
+
+}
+
+static void cdac_mmc_set_clock(struct cdac_mmc_host *host, int rate) {
+	unsigned int pbus = clk_get_rate(host->clk);
+	unsigned int divisor = ((pbus / rate) / 2) - 1;
+	UI config;
+	cdac_pr_info(DRIVER_NAME ":cdac_mmc_set_clock\n");
+	
+	if(rate == 450000)
+	{
+		__raw_writeq(OP_FREQ_400KHz, HOST_OP_FREQ(host));
+		//printk(": EMMC Freq %lx \n",__raw_readq(HOST_OP_FREQ(host))); 	//HDG:OK
+	}
+	
+	else if(rate == 24000000)
+	{
+		__raw_writeq(OP_FREQ_25MHz, HOST_OP_FREQ(host));
+		//printk(": Freq %lx \n",__raw_readq(HOST_OP_FREQ(host))); 	//HDG:OK
+	}
+	
+	else
+	{
+		//printk(":Other Clock Frequency\n");
+		//printk("clk freq: %ld Hz \n",rate);
+
+	}
+	//config = __raw_readq(HOST_CONFIG(host));
+
+	//	config &= ~(SD_CONFIG_DIV);
+	//config |= (divisor & SD_CONFIG_DIV) | SD_CONFIG_DE;
+
+//		__raw_writeq(config, HOST_CONFIG(host));
+	wmb(); /* drain writebuffer */
+}
+
+static int cdac_mmc_prepare_data(struct cdac_mmc_host *host,
+		struct mmc_request *mrq) {
+		
+	struct mmc_data *data = mrq->data;
+
+	int datalen = data->blocks * data->blksz;
+	unsigned long reg_value;
+
+	cdac_pr_info(DRIVER_NAME "cdac_mmc_prepare_data\n");
+			
+	host->mrq = mrq;
+	
+	//printk("No of Data Blocks req from Driver: 0x %lx",data->blocks); //cdac1
+	cdac_printk("Blk Size from Driver: 0x %lx bytes",data->blksz);
+	
+	//printk("Data Blks:%d %d\n",data->blocks, data->blksz);
+
+	if (data->flags & MMC_DATA_READ)
+	{
+		//cdac_printk("AAAAAAA/////////");
+		host->flags |= HOST_F_RECV;
+	}
+	else
+	{
+		//cdac_printk("BBBBBBB/////////");
+		host->flags |= HOST_F_XMIT;
+	}
+
+	//cdac_printk("CCCCCCCCc/////////");
+	
+	cdac_printk("host->mrq->stop ADDR:0x %lx",&(host->mrq->stop));
+	if (host->mrq->stop){
+
+	
+		//printk("host->flags ADDR:0x %lx",&(host->flags));
+	
+	
+		host->flags |= HOST_F_STOP;
+	}
+		
+	//cdac_printk("DDDDDDDDD/////////");
+
+/*	reg_value = __raw_readq(HOST_OP_MODE(host));
+	
+	cdac_printk("Before clearing OPMODE VAL: 0x %lx bytes",reg_value);
+	
+	/*reg_value &= 0xFFFFFFFF00FFFFFF;
+	
+	cdac_printk("After clearing OPMODE VAL: 0x %lx bytes",reg_value);
+
+	if (data->blocks > 255) {
+
+		reg_value = reg_value | (CDAC_MMC_OP_MODE_NUM_BLOCK(255))
+				| (CDAC_MMC_OP_MODE_LEN_BLOCK(data->blksz));
+	} else {
+
+		reg_value = reg_value | (CDAC_MMC_OP_MODE_NUM_BLOCK(data->blocks))
+				| (CDAC_MMC_OP_MODE_LEN_BLOCK(data->blksz));
+
+	}
+
+	reg_value = reg_value | ((UL)(1<<41)); // Total number of frames in FIFO to be interrupted.
+	__raw_writeq(reg_value, HOST_OP_MODE(host));
+	
+	cdac_printk("After writing NEW OPMODE VAL: 0x %lx bytes",reg_value);
+*/
+	host->pio.index = 0;
+	host->pio.offset = 0;
+	host->pio.len = datalen;
+	
+	//cdac_printk("BBBBBBB/////////");
+
+	if (host->flags & HOST_F_XMIT)
+	{
+		//IRQ_ON(host, SD_CONFIG_TH); ///Enable intr for Tx FIFO Empty
+		cdac_pr_info(DRIVER_NAME "Tx Intr...\n");	
+		IRQ_ON(host, CDAC_MMC_INTR_EN_WR_DATA_FIFO_EMPTY_INTR); //Write blocks transmitted
+		cdac_pr_info(DRIVER_NAME "ON\n");	
+	}
+	else if (host->flags & HOST_F_RECV)
+	{
+		//printk("\n Prepare Data: Rx IRQ ON \n");
+		//IRQ_ON(host, SD_CONFIG_NE);  ///Enable intr for Rx FIFO Not Empty
+		cdac_pr_info(DRIVER_NAME "Rx Intr...\n");	
+		IRQ_ON(host, CDAC_MMC_INTR_EN_NUM_BLK_AVL_BOOT_FIFO_INTR);
+		cdac_pr_info(DRIVER_NAME "ON\n");	
+	}
+	/* IRQ_ON(host, SD_CONFIG_RA | SD_CONFIG_RF); */
+
+	return 0;
+
+	dataerr: dma_unmap_sg(mmc_dev(host->mmc), data->sg, data->sg_len,
+			host->dma.dir);
+	return -ETIMEDOUT;
+}
+
+/* This actually starts a command or data transaction */
+
+//#endif
+void cdac_mmc_reset_controller(struct cdac_mmc_host *host) {
+cdac_printk("\n\r cdac_mmc_reset_controller start\n\r");
+	unsigned long reg_value = 0;
+	
+
+
+	/* Change frequency to 400kHz */
+	__raw_writeq(OP_FREQ_400KHz, HOST_OP_FREQ(host));
+	cdac_pr_info(DRIVER_NAME ": Freq %lx \n",__raw_readq(HOST_OP_FREQ(host))); 	//HDG:OK
+	/* Configure OP mode register */
+	
+	reg_value = (CDAC_MMC_OP_MODE_CMD_LINE(1UL)) | (CDAC_MMC_OP_MODE_NUM_BLOCK(0UL)) | (CDAC_MMC_OP_MODE_OPEN_ENDED_TRANSN(1UL))
+			| (CDAC_MMC_OP_MODE_LEN_BLOCK(512UL)) | (CDAC_MMC_OP_MODE_TOT_FRAMES_TO_INRPT(1UL)) | (CDAC_MMC_OP_MODE_STOP_EMMC_CLK(1UL))			//HDG:OK
+			| (CDAC_MMC_OP_MODE_BOOT_ACK_EN(1UL));
+			
+	/*reg_value = (CDAC_MMC_OP_MODE_CMD_LINE(1UL)) | (CDAC_MMC_OP_MODE_NUM_BLOCK(1UL))
+			| (CDAC_MMC_OP_MODE_LEN_BLOCK(512UL)) | (CDAC_MMC_OP_MODE_TOT_FRAMES_TO_INRPT(1UL)) | (CDAC_MMC_OP_MODE_STOP_EMMC_CLK(1UL))			//HDG:OK
+			| (CDAC_MMC_OP_MODE_BOOT_ACK_EN(1UL)) | CDAC_MMC_OP_MODE_DATA_TSFR(1UL) | CDAC_MMC_OP_MODE_DATA_BUS_WIDTH(2UL);*/
+
+
+	//cdac_pr_info(DRIVER_NAME ":reg_value %lx \n",reg_value);
+
+	__raw_writeq(reg_value, HOST_OP_MODE(host));				//HDG:OK
+
+	//cdac_pr_info(DRIVER_NAME ":reg_value1 %lx \n",reg_value);
+	//cdac_pr_info(DRIVER_NAME ": Freq %lx \n",__raw_readq(HOST_OP_FREQ(host)));
+	//cdac_pr_info(DRIVER_NAME ": Freq 1%lx \n",__raw_readq(HOST_OP_FREQ(host)));
+	//__raw_writeq(OP_FREQ_400KHz, HOST_OP_FREQ(host));
+	//	cdac_pr_info(DRIVER_NAME ": Freq 11 %lx \n",__raw_readq(HOST_OP_FREQ(host)));
+	//cdac_pr_info(DRIVER_NAME ":reg_value %lx \n",reg_value);
+//UL reg_opmode = __raw_readq(HOST_OP_MODE(host));
+	//cdac_pr_info(DRIVER_NAME ": Freq %lx \n",__raw_readq(HOST_OP_FREQ(host)));
+	cdac_pr_info(DRIVER_NAME ": OPMODE %lx \n",__raw_readq(HOST_OP_MODE(host)));
+	/* Configure Response timeout register */
+	__raw_writeq(RSP_TIMEOUT_MAX, HOST_RSP_TIMEOUT(host));			//HDG:OK
+	cdac_pr_info(DRIVER_NAME ": RSP_TO: %lx \n",__raw_readq(HOST_RSP_TIMEOUT(host)));
+//	cdac_pr_info(DRIVER_NAME ": Freq %lx \n",__raw_readq(HOST_OP_FREQ(host)));
+	/* Configure Write transaction timeout register */
+	__raw_writeq(WR_TRANS_TIMEOUT_MAX, HOST_WR_TRANS_TIMEOUT(host));		//HDG:OK
+	cdac_pr_info(DRIVER_NAME ": WR_TRANS_TO %lx \n",__raw_readq(HOST_WR_TRANS_TIMEOUT(host)));
+	/* Configure Read transaction timeout register */
+	__raw_writeq(RD_TRANS_TIMEOUT_MAX, HOST_RD_TRANS_TIMEOUT(host));		//HDG:OK
+	cdac_pr_info(DRIVER_NAME ": RD_TRANS_TO %lx \n",__raw_readq(HOST_RD_TRANS_TIMEOUT(host)));
+	
+	gHostIEReg_val = ALL_INTERRUPTS_SET;
+	__raw_writeq(ALL_INTERRUPTS_SET, HOST_IE(host));
+	cdac_pr_info(DRIVER_NAME ":@@@@@@@@@@@@@@@@@@@@ IE 0x %lx \n",ALL_INTERRUPTS_SET);
+	cdac_pr_info(DRIVER_NAME "gHostIEReg_val  0x %lx \n",gHostIEReg_val);
+
+
+#ifndef AUX_REF
+		/* Apply the clock */
+	//	__raw_writeq(SD_ENABLE_CE, HOST_ENABLE(host));
+	//	wmb(); /* drain writebuffer */
+	//	mdelay(1);
+
+	//	__raw_writeq(SD_ENABLE_R | SD_ENABLE_CE, HOST_ENABLE(host));
+	//	wmb(); /* drain writebuffer */
+	//	mdelay(5);
+
+	//	__raw_writeq(~0, HOST_STATUS(host));
+	//	wmb(); /* drain writebuffer */
+
+	//	__raw_writeq(0, HOST_BLKSIZE(host));
+	//	__raw_writeq(0x001fffff, HOST_TIMEOUT(host));
+	//	wmb(); /* drain writebuffer */
+
+	//	__raw_writeq(SD_CONFIG2_EN, HOST_CONFIG2(host));
+	//	wmb(); /* drain writebuffer */
+
+	//	__raw_writeq(SD_CONFIG2_EN | SD_CONFIG2_FF, HOST_CONFIG2(host));
+	//	wmb(); /* drain writebuffer */
+	//	mdelay(1);
+
+	//	__raw_writeq(SD_CONFIG2_EN, HOST_CONFIG2(host));
+	//	wmb(); /* drain writebuffer */
+
+		/* Configure interrupts */
+	//	__raw_writeq(cdac_MMC_INTERRUPTS, HOST_CONFIG(host));
+	//	wmb(); /* drain writebuffer */
+#endif
+cdac_printk("\n\r cdac_mmc_reset_controller end\n\r");
+}
+//#ifdef CDAC
+static void cdac_mmc_set_ios(struct mmc_host *mmc, struct mmc_ios *ios) {
+	struct cdac_mmc_host *host = mmc_priv(mmc);
+	UI config2;
+	UL opmode_reg_value ;
+	
+	
+	//printk(":cdac_mmc_set_ios\n"); //cdac1
+	
+	opmode_reg_value = __raw_readq(HOST_OP_MODE(host));
+
+	if (ios->power_mode == MMC_POWER_OFF)
+	{
+		unsigned long opmode_reg_value = 0;
+			
+
+		opmode_reg_value &= ~(1 << 4); // Clears 4th bit
+		opmode_reg_value &= ~(1 << 5); // Clears 5th bit
+		opmode_reg_value |= ((UL)1 << 32); // Set Bit 32 for Device reset
+		__raw_writeq(opmode_reg_value, HOST_OP_MODE(host));
+		
+		
+		
+		__raw_writeq(OP_FREQ_400KHz, HOST_OP_FREQ(host)); // Set EMMC freq to 400KHz
+		//pr_info(DRIVER_NAME ": EMMC Freq %lx \n",__raw_readq(HOST_OP_FREQ(host))); 	//HDG:OK
+		//pr_info(DRIVER_NAME ": EMMC OPMODE REG VAL  %lx \n",__raw_readq(HOST_OP_MODE(host))); 	//HDG:OK
+		
+		
+		
+		cdac_mmc_set_power(host, 0);
+		//printk(":cdac_mmc_set_power: OFF\n");
+		
+	}
+	else if (ios->power_mode == MMC_POWER_ON) {
+		cdac_mmc_set_power(host, 1);
+		//printk(":cdac_mmc_set_power: ON\n");
+		
+	}
+
+	if (ios->clock && ios->clock != host->clock) {
+		cdac_mmc_set_clock(host, ios->clock);
+		host->clock = ios->clock;
+		//printk("ios->clock=%ld\n",ios->clock);
+	}
+
+//	config2 = __raw_readq(HOST_CONFIG2(host));
+
+	//opmode_reg_value = __raw_readq(HOST_OP_MODE(host));
+	//opmode_reg_value &= ~(1 << 4); // Clears 4th bit
+	//opmode_reg_value &= ~(1 << 5); // Clears 5th bit
+	
+	switch (ios->bus_width) {
+	
+	case MMC_BUS_WIDTH_8:
+//		config2 |= SD_CONFIG2_BB;
+		opmode_reg_value &= ~(1 << 4); // Clears 4th bit
+		//opmode_reg_value &= ~((UL)7 << 4); // Clears Bits 4 to 7 to set Bus width to 1.
+		opmode_reg_value |= (1 << 5); // Sets 5th bit sets Bust width to 8
+		//printk("BW 8 set ios\n");
+		__raw_writeq(opmode_reg_value, HOST_OP_MODE(host));
+
+		break;
+	case MMC_BUS_WIDTH_4:
+//		config2 &= ~SD_CONFIG2_BB;
+//		config2 |= SD_CONFIG2_WB;
+		//printk("BW 4 set ios\n");
+		break;
+	case MMC_BUS_WIDTH_1:
+		opmode_reg_value &= ~(1 << 4); // Clears 4th bit
+		opmode_reg_value &= ~(1 << 5); // Clears 5th bit
+//		config2 &= ~(SD_CONFIG2_WB | SD_CONFIG2_BB);
+		//printk("BW 1 set ios\n");
+		__raw_writeq(opmode_reg_value, HOST_OP_MODE(host));
+		break;
+	}
+	
+	//__raw_writeq(config2, HOST_CONFIG2(host));
+	wmb(); /* drain writebuffer */
+	
+	//printk("\n Press key \n");
+	/*while(sbi_console_getchar()== -1)
+	{
+		msleep(1000);
+	}*/
+
+}
+
+//#define STATUS_TIMEOUT (SD_STATUS_RAT | SD_STATUS_DT)
+//#define STATUS_DATA_IN  (SD_STATUS_NE)
+//#define STATUS_DATA_OUT (SD_STATUS_TH)
+
+/* 8bit memory DMA device */
+//static dbdev_tab_t cdac_mmc_mem_dbdev = { .dev_id = DSCR_CMD0_ALWAYS,
+//.dev_flags = DEV_FLAGS_ANYUSE, .dev_tsize = 0, .dev_devwidth = 8,
+//	.dev_physaddr = 0x00000000, .dev_intlevel = 0, .dev_intpolarity = 0, };
+static int memid;
+
+static void cdac_mmc_dbdma_callback(int irq, void *dev_id) {
+	struct cdac_mmc_host *host = (struct cdac_mmc_host*) dev_id;
+	cdac_pr_info(DRIVER_NAME ":cdac_mmc_dbdma_callback\n");
+	/* Avoid spurious interrupts */
+	if (!host->mrq)
+		return;
+
+	if (host->flags & HOST_F_STOP)
+		SEND_STOP(host);
+
+	tasklet_schedule(&host->data_task);
+}
+
+static int cdac_mmc_dbdma_init(struct cdac_mmc_host *host) {
+	struct resource *res;
+	int txid, rxid;
+	cdac_pr_info(DRIVER_NAME ":cdac_mmc_dbdma_init\n");
+	res = platform_get_resource(host->pdev, IORESOURCE_DMA, 0);
+	if (!res)
+		return -ENODEV;
+	txid = res->start;
+
+	res = platform_get_resource(host->pdev, IORESOURCE_DMA, 1);
+	if (!res)
+		return -ENODEV;
+	rxid = res->start;
+
+	if (!memid)
+		return -ENODEV;
+
+	//host->tx_chan = cdac_xx_dbdma_chan_alloc(memid, txid,
+	//	cdac_mmc_dbdma_callback, (void*) host);
+	if (!host->tx_chan) {
+		dev_err(&host->pdev->dev, "cannot allocate TX DMA\n");
+		return -ENODEV;
+	}
+
+//	host->rx_chan = cdac_xx_dbdma_chan_alloc(rxid, memid,
+	//		cdac_mmc_dbdma_callback, (void*) host);
+	if (!host->rx_chan) {
+		dev_err(&host->pdev->dev, "cannot allocate RX DMA\n");
+		//	cdac_xx_dbdma_chan_free(host->tx_chan);
+		return -ENODEV;
+	}
+
+	//cdac_xx_dbdma_set_devwidth(host->tx_chan, 8);
+	//cdac_xx_dbdma_set_devwidth(host->rx_chan, 8);
+
+	//cdac_xx_dbdma_ring_alloc(host->tx_chan, cdac_MMC_DESCRIPTOR_COUNT);
+	//cdac_xx_dbdma_ring_alloc(host->rx_chan, cdac_MMC_DESCRIPTOR_COUNT);
+
+	/* DBDMA is good to go */
+	host->flags |= HOST_F_DMA | HOST_F_DBDMA;
+
+	return 0;
+}
+
+static void cdac_mmc_dbdma_shutdown(struct cdac_mmc_host *host) {
+
+		cdac_pr_info(DRIVER_NAME ":cdac_mmc_dbdma_shutdown\n");
+	if (host->flags & HOST_F_DMA) {
+		host->flags &= ~HOST_F_DMA;
+		//	cdac_xx_dbdma_chan_free(host->tx_chan);
+		//	cdac_xx_dbdma_chan_free(host->rx_chan);
+	}
+}
+
+static void cdac_mmc_enable_sdio_irq(struct mmc_host *mmc, int en) {
+	struct cdac_mmc_host *host = mmc_priv(mmc);
+	
+		cdac_pr_info(DRIVER_NAME ":cdac_mmc_enable_sdio_irq\n");
+
+	//if (en)
+	//IRQ_ON(host, SD_CONFIG_SI);
+//	else
+	//IRQ_OFF(host, SD_CONFIG_SI);
+}
+static int cdac_mmc_card_inserted(struct mmc_host *mmc) {
+	struct cdac_mmc_host *host = mmc_priv(mmc);
+	
+	cdac_pr_info(DRIVER_NAME ":cdac_mmc_card_inserted\n");
+
+//	if (host->platdata && host->platdata->card_inserted)
+//		return !!host->platdata->card_inserted(host->mmc);
+
+	return 1;
+}
+
+static int cdac_mmc_card_readonly(struct mmc_host *mmc) {
+	struct cdac_mmc_host *host = mmc_priv(mmc);
+
+
+	cdac_pr_info(DRIVER_NAME ":cdac_mmc_card_readonly\n");
+	
+//	if (host->platdata && host->platdata->card_readonly)
+//		return !!host->platdata->card_readonly(mmc);
+
+	return -ENOSYS;
+}
+static void cdac_mmc_request(struct mmc_host *mmc, struct mmc_request *mrq) {
+	
+	struct cdac_mmc_host *host = mmc_priv(mmc);
+	struct mmc_command *cmd;
+	int ret = 0;
+	UL status = 0;
+	unsigned long reg_value = 0;
+	
+	cmd = mrq->cmd;
+	
+	//pr_info(DRIVER_NAME ":cdac_mmc_request\n");
+
+	WARN_ON(irqs_disabled());
+	WARN_ON(host->status != HOST_S_IDLE);
+
+	host->mrq = mrq;
+	host->status = HOST_S_CMD;
+
+	/* fail request immediately if no card is present */
+	/*	if (0 == cdac_mmc_card_inserted(mmc)) {
+	 mrq->cmd->error = -ENOMEDIUM;
+	 cdac_mmc_finish_request(host);
+	 return;
+	 }*/
+
+	if (mrq->data) 
+	{
+		
+		//cdac_printk("Before clearing OPMODE VAL: 0x %lx bytes",reg_value);
+		
+		//reg_value &= E0001FFFFFFFFFFF;
+		
+		//cdac_printk("After clearing OPMODE VAL: 0x %lx bytes",reg_value);
+
+		//if(mrq->data->blksz != 512)
+		//printk("***Common\n");
+
+		if (mrq->data->blocks > 65535) {
+		
+		printk(" Modify EMMC linux driver to support no of blocks > 65535\n");
+
+			//reg_value = reg_value | (CDAC_MMC_OP_MODE_NUM_BLOCK(255))
+			//		| (CDAC_MMC_OP_MODE_LEN_BLOCK(mrq->data->blksz));
+		} else {
+			reg_value = __raw_readq(HOST_OP_MODE(host));
+			reg_value &= 0xE0001FFFFFFFFFFF; // Clears bit from 45 to 60. 
+			reg_value = reg_value | (CDAC_MMC_OP_MODE_NUM_BLOCK(mrq->data->blocks))
+					| (CDAC_MMC_OP_MODE_LEN_BLOCK(mrq->data->blksz));
+			
+			
+			__raw_writeq(reg_value, HOST_OP_MODE(host));
+			//printk("\n OPMODE VAL: 0x %lx ",reg_value);
+
+		}
+
+
+
+		
+		//cdac_printk("After writing NEW OPMODE VAL: 0x %lx bytes",reg_value);
+	
+		if (mrq->data->flags & MMC_DATA_READ)
+		{
+		
+			//printk("***READ\n");
+		
+			host->flags |= HOST_F_RECV;
+			ret = cdac_mmc_prepare_data(host, mrq);
+			if (!ret)
+			{
+			
+				if(mrq->sbc)
+				{
+					//printk("*******HDG:SBC \n");
+					command_complete_flag = 0;
+					ret = cdac_mmc_send_command(host, 0, mrq->sbc, mrq->data);
+					while(command_complete_flag == 0); //wait for the command to be completed
+					//printk(" CMD SENT 1 :23 R\n");
+				}
+				command_complete_flag = 0;
+				ret = cdac_mmc_send_command(host, 0, mrq->cmd, mrq->data);
+				while(command_complete_flag == 0); //wait for the command to be completed
+				
+				//printk(" CMD SENT : R\n");
+				
+				if(cmd->opcode != 8)
+				{
+					if(mrq->sbc)
+					{
+						//printk(" ******CCC \n");
+						
+						do
+						{
+							status = __raw_readq(HOST_STATUS(host));
+							if(status & CDAC_MMC_STATUS_RD_TRANSN_TIMEOUT_ERR)
+								printk(" ******READ Txn Time OUT Err \n");
+						}while(!(status & CDAC_MMC_STATUS_MUL_BLK_RD_CPLT));
+					}
+					else
+					{
+						//printk(" ******DDD \n");
+						do
+						{
+							status = __raw_readq(HOST_STATUS(host));
+							if(status & CDAC_MMC_STATUS_RD_TRANSN_TIMEOUT_ERR)
+								printk(" ******READ Txn Time OUT Err \n");
+						}while(!(status & CDAC_MMC_STATUS_SIN_BLK_RD_CPLT));
+					}
+					
+					/*unsigned long response = 0;
+					response =  (__raw_readq(HOST_LWR_RSP(host)));
+					printk("\n LR 0x: %lx\n",response);
+					response =  (__raw_readq(HOST_UPR_RSP(host)));
+					printk("\n UR 0x: %lx\n",response);*/
+				}
+					
+			}
+
+		}
+		else if (mrq->data->flags & MMC_DATA_WRITE)
+		{
+		
+			//printk("***WRITE\n");
+			//Enters here during write
+	
+			host->flags |= HOST_F_XMIT;
+			
+			//printk("host flags %x \n",host->flags);
+			
+			if(mrq->sbc)
+			{
+				//printk("*******HDG:SBC \n");
+				command_complete_flag = 0;
+				ret = cdac_mmc_send_command(host, 0, mrq->sbc, mrq->data);
+				while(command_complete_flag == 0); //wait for the command to be completed
+			}
+			command_complete_flag = 0;
+			ret = cdac_mmc_send_command(host, 0, mrq->cmd, mrq->data);
+			while(command_complete_flag == 0); //wait for the command to be completed
+			
+			//printk(" CMD SENT : W\n");
+			
+			//printk("cdac_mmc_prepare_data  \n");
+			ret = cdac_mmc_prepare_data(host, mrq);
+			//printk("cdac_mmc_prepare_data 2  \n");
+			
+			if(mrq->sbc)
+			{
+				//printk(" ******AAA \n");
+				UL status;
+				do
+				{
+					status = __raw_readq(HOST_STATUS(host));
+					if(status & CDAC_MMC_STATUS_WTRANS_TMOUT_ERR)
+						printk(" ******WR Txn Time OUT Err \n");
+						
+				//printk(" ******MBWC NOT SET \n");
+				}while(!(status & CDAC_MMC_STATUS_MUL_BLK_WR_CPLT));
+				
+			}
+			else
+			{
+				//printk(" ******BBB \n");
+				do
+				{
+					status = __raw_readq(HOST_STATUS(host));
+					if(status & CDAC_MMC_STATUS_RD_TRANSN_TIMEOUT_ERR)
+						printk(" ******WRITE Txn Time OUT Err \n");
+						
+				}while(!(status & CDAC_MMC_STATUS_SIN_BLK_WR_CPLT));
+				//printk("cdac_mmc_prepare_data 3  \n");
+			}
+			
+			/*unsigned long response = 0;
+			response =  (__raw_readq(HOST_LWR_RSP(host)));
+			printk("\n LR 0x: %lx\n",response);
+			response =  (__raw_readq(HOST_UPR_RSP(host)));
+			printk("\n UR 0x: %lx\n",response);*/
+			
+			
+		}
+	} else{
+		command_complete_flag = 0;
+		ret = cdac_mmc_send_command(host, 0, mrq->cmd, mrq->data);
+		while(command_complete_flag == 0); //wait for the command to be completed
+					//printk(" CMD SENT 3 : else\n");
+		
+	}
+
+
+	if (ret) {
+		mrq->cmd->error = ret;
+		cdac_mmc_finish_request(host);
+	}
+}
+
+
+
+static const struct mmc_host_ops cdac_mmc_ops = { 
+	.request = cdac_mmc_request,
+	.set_ios = cdac_mmc_set_ios, 
+	.get_ro = cdac_mmc_card_readonly,
+	.get_cd = cdac_mmc_card_inserted, 
+	.enable_sdio_irq = cdac_mmc_enable_sdio_irq, 
+};
+
+	volatile int cdac_irq = 0;
+	
+static irqreturn_t cdac_mmc_irq(int irq, void *dev_id) {
+	struct cdac_mmc_host *host = dev_id;
+	u64 status,int_status = 0;
+
+	cdac_irq = 1;
+
+	spin_lock(&host->chip_lock);
+	//printk("In ISR...");
+	int_status = __raw_readq(HOST_INTERRUPT_STATUS(host));
+	cdac_pr_info(DRIVER_NAME ": Interrupt Status %lx \n",int_status);
+	//printk("Interrupt Status 0x %lx \n",int_status);
+
+	// if (int_status & CDAC_MMC_INT_STATUS_CMD_COMPLETE) // HDG: Commented for testing Command Sent interrupt
+	if (int_status & CDAC_MMC_INT_STATUS_CMD_SENT)
+		cdac_mmc_cmd_complete(host);
+		
+		//cdac_pr_info(DRIVER_NAME ": isr return   \n");
+		
+//	if (!(status & SD_STATUS_I))
+//		return IRQ_NONE;	/* not ours */
+
+//	if (status & SD_STATUS_SI)	/* SDIO */
+	//	mmc_signal_sdio_irq(host->mmc);
+
+	/*if ((int_status & CDAC_MMC_INTR_STATUS_RSP_TMOUT))
+		host->mrq->cmd->error = -ETIMEDOUT;
+	else if (int_status & CDAC_MMC_INTR_STATUS_WRT_TMOUT)
+		host->mrq->data->error = -ETIMEDOUT;
+	else if (int_status & CDAC_MMC_INTR_STATUS_RRT_TMOUT)
+		host->mrq->data->error = -ETIMEDOUT;*/
+
+	/* In PIO mode, interrupts might still be enabled */
+//		IRQ_OFF(host, SD_CONFIG_NE | SD_CONFIG_TH);
+	/* IRQ_OFF(host, SD_CONFIG_TH | SD_CONFIG_RA | SD_CONFIG_RF); */
+	//	tasklet_schedule(&host->finish_task);
+//	}
+
+
+	//else if (status & SD_STATUS_CR) {
+	//if (host->status == HOST_S_CMD)
+	//cdac_mmc_cmd_complete(host, status);
+
+//	} else if (!(host->flags & HOST_F_DMA)) {
+
+	//int_status = __raw_readq(HOST_INTERRUPT_STATUS(host));
+	//cdac_pr_info(DRIVER_NAME ":II Interrupt Status %lx \n",int_status);
+	
+	cdac_printk("\n\r host flag:0x %x",host->flags);
+	
+	//printk("In ISR 2...");
+	
+	if ((host->flags & HOST_F_XMIT) && (int_status & CDAC_MMC_INTR_STATUS_WR_DATA_FIFO_EMPTY_INTR))
+	{
+		//printk("ISR....TX");
+		
+		cdac_pr_info(DRIVER_NAME ":host->pio.len: %ld Bytes tx\n", host->pio.len);
+			cdac_mmc_send_pio(host);
+			
+	}
+	else if ((host->flags & HOST_F_RECV) && (int_status & CDAC_MMC_INTR_STATUS_NO_BLK_AVL_B_FIFO_INTR))
+	{
+		//printk("ISR....RX");
+		cdac_pr_info(DRIVER_NAME ":III Interrupt Status %lx \n",int_status);
+		//host->pio.len =  int_status & CDAC_MMC_INTR_STATUS_WR_DATA_FIFO_EMPTY_INTR; // Updating the  number od blocks received during interrupt.
+		
+		//status = __raw_readq(HOST_STATUS(host));
+		//cdac_pr_info(DRIVER_NAME ":Hh HOST_STATUS %lx \n", status);
+
+		//printk("ISR....RX1\n");
+		cdac_pr_info(DRIVER_NAME ":host->pio.len: %ld Bytes Received\n", host->pio.len);
+		cdac_mmc_receive_pio(host);
+	}
+	
+	cdac_printk("\n\r Over");
+	//}else
+	if (int_status & 0x203F3C70) {
+		DBG("Unhandled status %8.8x\n", host->pdev->id, status);
+	}
+
+	//__raw_writeq(status, HOST_STATUS(host));
+	wmb(); /* drain writebuffer */
+	spin_unlock(&host->chip_lock);
+		cdac_irq = 0;
+	return IRQ_HANDLED;
+}
+//#endif
+
+static int cdac_mmc_probe(struct platform_device *pdev) {
+
+
+	struct mmc_host *mmc;
+	struct cdac_mmc_host *host;
+	struct resource *r;
+	//struct device *dev = pdev->dev;
+	int ret, iflag;
+	u64 int_status;
+	u32 dma_base=0;
+	u32 dma_size=0;	
+
+
+
+	
+	cdac_printk("\n\r cdac_mmc_probe--start\n\r");
+
+	mmc = mmc_alloc_host(sizeof(struct cdac_mmc_host), &pdev->dev);
+	if (!mmc) {
+		dev_err(&pdev->dev, "no memory for mmc_host\n");
+		ret = -ENOMEM;
+		goto out0;
+	}
+
+	host = mmc_priv(mmc);
+	host->mmc = mmc;
+	 
+	host->platdata = pdev->dev.platform_data;
+	host->pdev = pdev;
+	ret = -ENODEV;
+
+	r = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!r) {
+		dev_err(&pdev->dev, "no mmio defined\n");
+		goto out1;
+	}
+
+
+	//for_each_available_child_of_node(np, child) {
+
+	
+	ret = of_property_read_u32(pdev->dev.of_node, "dma-base-addr",
+					   &dma_base);
+					   
+	ret = of_property_read_u32(pdev->dev.of_node, "dma-addr-size",
+					   &dma_size);				   
+	
+	
+	spin_lock_init(&host->chip_lock);
+	
+	cdac_pr_info(DRIVER_NAME ": r->start %lx pdev->name %s\n", r->start, pdev->name);
+	cdac_pr_info(DRIVER_NAME "dma_base %x\n", dma_base);
+	cdac_pr_info(DRIVER_NAME "dma_size %x\n", dma_size);
+
+	host->ioarea = request_mem_region(r->start, resource_size(r), pdev->name);
+	if (!host->ioarea) {
+		dev_err(&pdev->dev, "mmio already in use\n");
+		goto out1;
+	}
+
+	host->iobase = ioremap(r->start, resource_size(r));
+	
+	
+	cdac_pr_info(DRIVER_NAME " host->iobase %lx \n", host->iobase);
+
+	if (!host->iobase) {
+		dev_err(&pdev->dev, "cannot remap mmio\n");
+		goto out2;
+	}
+
+	host->dmabase = ioremap(dma_base, dma_size);
+	cdac_pr_info(DRIVER_NAME " host->dmabase %lx \n", host->dmabase);
+
+	if (!host->dmabase) {
+		dev_err(&pdev->dev, "cannot remap dma\n");
+		goto out2a;
+	}
+	
+
+	r = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	if (!r) {
+		dev_err(&pdev->dev, "no IRQ defined\n");
+		goto out3;
+	}
+
+	host->irq = r->start;
+	
+	cdac_pr_info(DRIVER_NAME " host->irq %lx \n", host->irq);
+
+	mmc->ops = &cdac_mmc_ops;			//karthika
+
+	mmc->f_min = 450000;
+	mmc->f_max = 24000000;
+
+	mmc->max_blk_size = 512;
+	mmc->max_blk_count = 16;
+
+	mmc->ocr_avail = CDAC_MMC_OCR;
+	mmc->caps |= (MMC_CAP_8_BIT_DATA | MMC_CAP_CMD23 | MMC_CAP_WAIT_WHILE_BUSY | MMC_CAP_MMC_HIGHSPEED |  MMC_CAP_DONE_COMPLETE \
+	| MMC_CAP_UHS_SDR25 | MMC_CAP_UHS_SDR50 );
+	
+	mmc->caps2 |= (MMC_CAP2_NO_SD | MMC_CAP2_NO_SDIO);
+	mmc->max_segs = CDAC_MMC_DESCRIPTOR_COUNT;
+	
+	//printk("MMC CAPS2 %lx \n",mmc->caps2);
+
+	iflag = IRQF_SHARED; /* Au1100/Au1200: one int for both ctrls */
+
+	//switch (alchemy_get_cputype()) {
+	//case ALCHEMY_CPU_AU1100:
+	//	mmc->max_seg_size = AU1100_MMC_DESCRIPTOR_SIZE;
+	//	break;
+	//case ALCHEMY_CPU_AU1200:
+	//	mmc->max_seg_size = AU1200_MMC_DESCRIPTOR_SIZE;
+	//	break;
+	//case ALCHEMY_CPU_AU1300:
+	//	iflag = 0; /* nothing is shared */
+	//	mmc->max_seg_size = AU1200_MMC_DESCRIPTOR_SIZE;
+	//	mmc->f_max = 52000000;
+	//	if (host->ioarea->start == AU1100_SD0_PHYS_ADDR)
+	//		mmc->caps |= MMC_CAP_8_BIT_DATA;
+	//	break;
+	//}
+
+	//__raw_writeq(0, HOST_IE(host));
+
+	//int_status = __raw_readq(HOST_INTERRUPT_STATUS(host));
+	//__raw_writeq(0, HOST_IE(host));
+	//cdac_pr_info(DRIVER_NAME " request_irq : IE 0");
+	ret = request_irq(host->irq, cdac_mmc_irq, iflag, DRIVER_NAME, host);
+	
+	cdac_pr_info(DRIVER_NAME " request_irq : ret val: %lx \n",ret);
+	
+	if (ret) {
+		dev_err(&pdev->dev, "cannot grab IRQ\n");
+		goto out3;
+	}
+
+//	host->clk = clk_get(&pdev->dev, ALCHEMY_PERIPH_CLK);
+	if (IS_ERR(host->clk)) {
+		dev_err(&pdev->dev, "cannot find clock\n");
+		ret = PTR_ERR(host->clk);
+		goto out_irq;
+	}
+
+	ret = clk_prepare_enable(host->clk);
+	if (ret) {
+		dev_err(&pdev->dev, "cannot enable clock\n");
+		goto out_clk;
+	}
+
+	host->status = HOST_S_IDLE;
+
+	/* board-specific carddetect setup, if any */
+//	if (host->platdata && host->platdata->cd_setup) {
+	//	ret = host->platdata->cd_setup(mmc, 1);
+	//if (ret) {
+	//dev_warn(&pdev->dev, "board CD setup failed\n");
+	//mmc->caps |= MMC_CAP_NEEDS_POLL;
+	//}
+	//} else
+	//mmc->caps |= MMC_CAP_NEEDS_POLL;
+	/* platform may not be able to use all advertised caps */
+//	if (host->platdata)
+	//	mmc->caps &= ~(host->platdata->mask_host_caps);
+	tasklet_init(&host->data_task, cdac_mmc_tasklet_data, (unsigned long) host);
+
+	tasklet_init(&host->finish_task, cdac_mmc_tasklet_finish,
+			(unsigned long) host);
+			
+	Enable_DMAC(host);	// Enabling DMAC.
+
+
+	cdac_mmc_reset_controller(host); // HDG: Initial controller values are set as per "eMMC_Primary_Init_HostController()" in baremetal pgm
+
+	ret = mmc_add_host(mmc);
+	if (ret) {
+		dev_err(&pdev->dev, "cannot add mmc host\n");
+		goto out6;
+	}
+
+	platform_set_drvdata(pdev, host);
+	
+	//mmc->card->quirks |= MMC_QUIRK_BROKEN_HPI;
+	
+	// HDG: Here cdac_mmc_ops() are called like "cdac_mmc_set_ios","cdac_mmc_set_power",cdac_mmc_set_clock etc
+
+	cdac_pr_info(DRIVER_NAME ": MMC Controller %d set up at %lx"
+	" (mode=%s)\n", pdev->id, host->iobase,
+			host->flags & HOST_F_DMA ? "dma" : "pio");
+
+	return 0; /* all ok */
+
+	out6:
+#ifdef CONFIG_LEDS_CLASS
+		if (host->platdata && host->platdata->led)
+			led_classdev_unregister(host->platdata->led);
+		out5:
+#endif
+	//__raw_writeq(0, HOST_ENABLE(host));
+	//__raw_writeq(0, HOST_CONFIG(host));
+	//__raw_writeq(0, HOST_CONFIG2(host));
+	//wmb(); /* drain writebuffer */
+
+	if (host->flags & HOST_F_DBDMA)
+		cdac_mmc_dbdma_shutdown(host);
+
+	tasklet_kill(&host->data_task);
+	tasklet_kill(&host->finish_task);
+
+//	if (host->platdata && host->platdata->cd_setup
+	//		&& !(mmc->caps & MMC_CAP_NEEDS_POLL))
+	//host->platdata->cd_setup(mmc, 0);
+	out_clk: clk_disable_unprepare(host->clk);
+	clk_put(host->clk);
+	out_irq: free_irq(host->irq, host);
+	out3: iounmap((void*) host->dmabase);
+	out2a: iounmap((void*) host->iobase);
+	out2: release_resource(host->ioarea);
+	kfree(host->ioarea);
+	out1: mmc_free_host(mmc);
+	out0: return ret;
+
+}
+
+static int cdac_mmc_remove(struct platform_device *pdev) {
+	struct cdac_mmc_host *host = platform_get_drvdata(pdev);
+	cdac_pr_info(DRIVER_NAME ":cdac_mmc_remove\n");
+	
+	return;
+
+	if (host) {
+		mmc_remove_host(host->mmc);
+
+#ifdef CONFIG_LEDS_CLASS
+			if (host->platdata && host->platdata->led)
+				led_classdev_unregister(host->platdata->led);
+#endif
+
+		//	if (host->platdata && host->platdata->cd_setup
+		//		&& !(host->mmc->caps & MMC_CAP_NEEDS_POLL))
+		//host->platdata->cd_setup(host->mmc, 0);
+
+		//	__raw_writeq(0, HOST_ENABLE(host));
+		//	__raw_writeq(0, HOST_CONFIG(host));
+		//	__raw_writeq(0, HOST_CONFIG2(host));
+		//	wmb(); /* drain writebuffer */
+
+		tasklet_kill(&host->data_task);
+		tasklet_kill(&host->finish_task);
+
+		if (host->flags & HOST_F_DBDMA)
+			cdac_mmc_dbdma_shutdown(host);
+
+		cdac_mmc_set_power(host, 0);
+
+		clk_disable_unprepare(host->clk);
+		clk_put(host->clk);
+
+		free_irq(host->irq, host);
+		iounmap((void*) host->iobase);
+		release_resource(host->ioarea);
+		kfree(host->ioarea);
+
+		mmc_free_host(host->mmc);
+	}
+	return 0;
+}
+
+#ifdef CONFIG_PM
+	static int cdac_mmc_suspend(struct platform_device *pdev, pm_message_t state)
+	{
+		struct cdac_mmc_host *host = platform_get_drvdata(pdev);
+
+		//__raw_writeq(0, HOST_CONFIG2(host));
+		//__raw_writeq(0, HOST_CONFIG(host));
+		//__raw_writeq(0xffffffff, HOST_STATUS(host));
+		//__raw_writeq(0, HOST_ENABLE(host));
+		wmb(); /* drain writebuffer */
+
+		return 0;
+	}
+
+	static int cdac_mmc_resume(struct platform_device *pdev)
+	{
+		struct cdac_mmc_host *host = platform_get_drvdata(pdev);
+
+		cdac_mmc_reset_controller(host);
+
+		return 0;
+	}
+#else
+#define cdac_mmc_suspend NULL
+#define cdac_mmc_resume NULL
+#endif
+
+
+static const struct of_device_id cdac_emmc_match[] = { { .type = "mmc",
+		.compatible = "cdac,cdac_emmc" }, { } };
+MODULE_DEVICE_TABLE( of, cdac_emmc_match);
+
+static struct platform_driver cdac_mmc_driver = {
+
+	.probe = cdac_mmc_probe,
+	.remove = cdac_mmc_remove,
+	.driver = {
+		.name = "cdac_emmc",
+                .owner = THIS_MODULE,
+		.of_match_table = of_match_ptr(cdac_emmc_match),
+	},
+#ifdef CONFIG_PM
+	.suspend = cdac_mmc_suspend,
+	.resume = cdac_mmc_resume,
+#endif
+};
+
+
+static int __init cdac_mmc_init(void)
+{
+
+//#ifdef DBDMA
+	//if (has_dbdma()) {
+		/* DSCR_CMD0_ALWAYS has a stride of 32 bits, we need a stride
+		 * of 8 bits.  And since devices are shared, we need to create
+		 * our own to avoid freaking out other devices.
+		 */
+		//memid = cdac_xx_ddma_add_device(&cdac_mmc_mem_dbdev);
+		//if (!memid)
+		//pr_err("cdac_mmc: cannot add memory dbdma\n");
+	//}
+//#endif
+	return platform_driver_register(&cdac_mmc_driver);
+}
+
+
+
+static void __exit cdac_mmc_exit(void)
+{
+	cdac_pr_info(DRIVER_NAME ":cdac_mmc_exit\n");
+//#ifdef DBDMA
+	//if (has_dbdma() && memid)
+	//cdac_xx_ddma_del_device(memid);
+//#endif
+	platform_driver_unregister(&cdac_mmc_driver);
+}
+
+
+
+
+/***********************DMA FUNCTIONS***********************/
+
+
+/**************************************************
+* Function name		: void Init_DMA_Channel_params(DMAtransfer_Type *gDMAtransfer,UL next_lli_addr,UC lli_master,UC lli_en_dis)
+* returns						: Nil
+* Created by				: Sreeju G R
+* Date created			: 30/08/2019
+* Description			: Create a LLI Table .
+* Notes						:
+**************************************************/
+
+void Init_DMA_Ch_CtrlReg_params_sram_to_sram(UC dce, UC cie,UL src_data_width, UL dst_data_width, UC dai, UC sai, UC cbe, UC cms, US cts, UC cbs)
+{
+	int test=0;
+	gDMAtransfer.Control.dword = 0;		// Initialise structure with 0 value.
+	gDMAtransfer.LLI.dword = 0;				// Initialise structure with 0 value.
+
+	gDMAtransfer.Control.Bits.DCE = dce;
+	gDMAtransfer.Control.Bits.CIE = cie;
+	gDMAtransfer.Control.Bits.SRC_DW = src_data_width;
+	gDMAtransfer.Control.Bits.DST_DW = dst_data_width;   	// 000 : 8-bit source data, 001 : 16-bit source data, 010 : 32-bit source data, 011 : 64-bit source data, 100 : 128-bit source data
+	gDMAtransfer.Control.Bits.DAI = dai;			// CHANNEL WAIT RESPONSE			:::: 0 : disabling wait state, 1 : enable  wait state
+	gDMAtransfer.Control.Bits.SAI = sai;			// CHANNEL ADDRESS INCREMENT :::: 0 : disabling address increment, 1 : disabling address increment
+	gDMAtransfer.Control.Bits.CBE = cbe;			// CHANNEL BURST ENABLE  ::::  0 : disabling burst transaction, 1 : enabling burst transaction
+	gDMAtransfer.Control.Bits.CMS = cms;			// CHANNEL MASTER SELECTOR  :::: 00 : ACE to ACE transaction , 01 : ACE to AXI transaction, 10 : AXI to ACE transaction , 11 : AXI to AXI transaction
+	gDMAtransfer.Control.Bits.CTS = cts;			// CHANNEL TRANSFER SIZE
+	gDMAtransfer.Control.Bits.CBS = cbs;			// CHANNEL BURST SIZE  :::: 001 : BURST 2, 010 : BURST 4, 011 : BURST 8
+	
+	//printk("********* INIT DMA #############");
+
+}
+
+/**************************************************
+* Function name		: Read_DMAC_Global_Status_Reg
+* returns		: Nil
+* Created by		: Sreeju G R
+* Date created		: 19/08/2019
+* Description		: Read the content of DMAC Global status register.
+* Notes			:
+**************************************************/
+
+unsigned long  Read_DMAC_Global_Status_Reg(struct cdac_mmc_host *host)
+{
+		unsigned long  status = 0;
+		status = __raw_readq(DMA_GLOBAL_STATUS_REG(host));
+		return status;
+}
+
+/**************************************************
+* Function name		: Enable_DMAC
+* returns		: Nil
+* Created by		: Sreeju G R
+* Date created		: 19/08/2019
+* Description		: Enable DMAController.
+* Notes			: 
+**************************************************/
+
+void Enable_DMAC(struct cdac_mmc_host *host)
+{
+	cdac_pr_info(DRIVER_NAME ":Enabling DMAC....\n");
+	DMAC_GlobalCtrl_Type gblCtrlReg;
+	UL val=0,status = 0;
+	gblCtrlReg.dword = 0;
+
+	gblCtrlReg.Bits.DE = 1;
+
+	gblCtrlReg.Bits.DIE = DMA_INTR_ENABLE;
+	
+	//DMAC_globalReg.CtrlReg = gblCtrlReg.dword;
+	__raw_writeq(gblCtrlReg.dword, DMA_GLOBAL_CTRL_REG(host)); //writing Global control register
+	__asm__ __volatile__ ("fence");
+	
+	while(val != 3)
+	{
+		val = __raw_readq(DMA_GLOBAL_CTRL_REG(host));
+	}
+
+	do
+	{
+		status = Read_DMAC_Global_Status_Reg(host); 	// Check if channel is active or not
+	} while(((status & DMA_ACTIVE) != DMA_ACTIVE));
+	cdac_pr_info(DRIVER_NAME "Done\n");
+}
+
+/**************************************************
+* Function name		: Check_DMAC_transferDone
+* returns						: Nil
+* Created by				: Sreeju G R
+* Date created			: 19/08/2019
+* Description			: Check if DMA transfer completed.
+* Notes			:
+**************************************************/
+
+void Check_DMAC_transferDone(struct cdac_mmc_host *host,UC channelNum)
+{
+		unsigned long status = 0;
+		UL  test=0;
+
+		//if(channelNum  == DMAC_CHANNEL0)
+		if(channelNum  == CHANNEL0) //Channel 0
+		{
+			do
+			{
+				status = Read_DMAC_Global_Status_Reg(host); 	// Check if channel data transfer is done
+				//Transmit_uart(" \n\r DMA Status Reg Val:");
+				//disp_Rx_data_UL((UL) (status));
+				//Rx_uart();
+			} while(((status & CHK_CH0_DTD) != CHK_CH0_DTD)); 							// wait till channel is data transfer is complete.
+
+			//gDMAFrameCount++;
+		}
+}
+
+
+
+void eMMC_DisplayExtCSDdata(UI noOfBlks)
+{
+	UL *readPtr;
+	UI i=0,j = 0;
+
+	//Flush_Cache_data();
+
+
+	readPtr = (UL*)0x91000000;
+
+	cdac_printk("\n\r\n\r EXT CSD DATA.... ");
+	cdac_printk("\n\r****************\n\r\n\r ");
+	for(j=0;j<noOfBlks;j++)
+	{
+
+		for(i=0;i<(EMMC_BLK_LEN/8);i++)
+		{
+			cdac_printk("[");
+			//cdac_printk("\n\r cdac_mmc_reset_controller start\n\r");
+			cdac_pr_info(DRIVER_NAME "%d",j);
+			cdac_printk(":");
+			//disp_decimal(j+=7);
+			cdac_printk("]");
+
+			cdac_printk("		0x ");
+			//disp_Rx_data_UL(*readPtr);
+			cdac_printk("\n\r ");
+
+			j++;
+
+			readPtr++;
+		}
+	}
+}
+
+
+/*************************************************************/
+module_init( cdac_mmc_init);
+//module_init( cdac_dma_init);
+module_exit( cdac_mmc_exit);
+//module_exit( cdac_dma_exit);
+
+MODULE_AUTHOR("HDG-CDAC-TVM");
+MODULE_DESCRIPTION("MMC/SD driver for the CDAC");
+MODULE_ALIAS("platform:cdac_mmc");
+
diff -Naur linux-5.4.1/drivers/mmc/host/Kconfig linux-5.4.1_modified/drivers/mmc/host/Kconfig
--- linux-5.4.1/drivers/mmc/host/Kconfig	2019-11-29 14:40:32.000000000 +0530
+++ linux-5.4.1_modified/drivers/mmc/host/Kconfig	2025-08-08 10:40:35.442603313 +0530
@@ -173,6 +173,14 @@
 	depends on OF
 	help
 	  This selects the Atmel SDMMC driver
+	  
+config MMC_SDHCI_CDAC
+	tristate "SDHCI OF support for the C-DAC SDHCI controller"
+	depends on MMC_SDHCI_PLTFM
+	depends on OF
+	select MMC_SDHCI_IO_ACCESSORS
+	help
+	  This selects the  C-DAC SDHCI driver
 
 config MMC_SDHCI_OF_ESDHC
 	tristate "SDHCI OF support for the Freescale eSDHC controller"
@@ -474,6 +482,16 @@
 
 	  If unsure, say N.
 
+config MMC_CDAC
+	tristate "CDAC EMMC Card Interface support"
+
+	help
+	  This selects the CDAC Embedded Multimedia card interface.
+	  If you have a CDAC platform with a MMC slot, say Y or M here.
+
+	  If unsure, say N.
+
+
 config MMC_ATMELMCI
 	tristate "Atmel SD/MMC Driver (Multimedia Card Interface)"
 	depends on ARCH_AT91
diff -Naur linux-5.4.1/drivers/mmc/host/Makefile linux-5.4.1_modified/drivers/mmc/host/Makefile
--- linux-5.4.1/drivers/mmc/host/Makefile	2019-11-29 14:40:32.000000000 +0530
+++ linux-5.4.1_modified/drivers/mmc/host/Makefile	2025-08-08 10:40:35.451347584 +0530
@@ -25,6 +25,7 @@
 obj-$(CONFIG_MMC_SDHCI_AM654)	+= sdhci_am654.o
 obj-$(CONFIG_MMC_WBSD)		+= wbsd.o
 obj-$(CONFIG_MMC_AU1X)		+= au1xmmc.o
+obj-$(CONFIG_MMC_CDAC)		+= cdac_mmc.o
 obj-$(CONFIG_MMC_ALCOR)	+= alcor.o
 obj-$(CONFIG_MMC_MTK)		+= mtk-sd.o
 obj-$(CONFIG_MMC_OMAP)		+= omap.o
@@ -86,6 +87,7 @@
 obj-$(CONFIG_MMC_SDHCI_OF_ARASAN)	+= sdhci-of-arasan.o
 obj-$(CONFIG_MMC_SDHCI_OF_ASPEED)	+= sdhci-of-aspeed.o
 obj-$(CONFIG_MMC_SDHCI_OF_AT91)		+= sdhci-of-at91.o
+obj-$(CONFIG_MMC_SDHCI_CDAC)		+= sdhci-cdac.o
 obj-$(CONFIG_MMC_SDHCI_OF_ESDHC)	+= sdhci-of-esdhc.o
 obj-$(CONFIG_MMC_SDHCI_OF_HLWD)		+= sdhci-of-hlwd.o
 obj-$(CONFIG_MMC_SDHCI_OF_DWCMSHC)	+= sdhci-of-dwcmshc.o
diff -Naur linux-5.4.1/drivers/mmc/host/sdhci-cdac.c linux-5.4.1_modified/drivers/mmc/host/sdhci-cdac.c
--- linux-5.4.1/drivers/mmc/host/sdhci-cdac.c	1970-01-01 05:30:00.000000000 +0530
+++ linux-5.4.1_modified/drivers/mmc/host/sdhci-cdac.c	2025-08-08 10:40:35.451508416 +0530
@@ -0,0 +1,367 @@
+/*
+ * CDAC SDHCI controller driver
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License version 2 as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/err.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <linux/module.h>
+#include <linux/io.h>
+#include <linux/gpio.h>
+#include <linux/mmc/card.h>
+#include <linux/mmc/host.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+
+#include "sdhci.h"
+#include "sdhci-pltfm.h"
+
+#define ALIGN_32_MASK 0xFFFFFFFC
+
+#define MASK_8_BIT 0xFF
+
+#define SD_FIFO_PARAM		0xe0
+#define DIS_PAD_SD_CLK_GATE	0x0400 /* Turn on/off Dynamic SD Clock Gating */
+#define CLK_GATE_ON		0x0200 /* Disable/enable Clock Gate */
+#define CLK_GATE_CTL		0x0100 /* Clock Gate Control */
+#define CLK_GATE_SETTING_BITS	(DIS_PAD_SD_CLK_GATE | \
+		CLK_GATE_ON | CLK_GATE_CTL)
+
+#define SD_CLOCK_BURST_SIZE_SETUP	0xe6
+#define SDCLK_SEL_SHIFT		8
+#define SDCLK_SEL_MASK		0x3
+#define SDCLK_DELAY_SHIFT	10
+#define SDCLK_DELAY_MASK	0x3c
+
+#define SD_CE_ATA_2		0xea
+#define MMC_CARD		0x1000
+#define MMC_WIDTH		0x0100
+
+struct sdhci_ersdhc_platdata {
+	unsigned int	flags;
+	unsigned int	clk_delay_cycles;
+	unsigned int	clk_delay_sel;
+	bool		clk_delay_enable;
+	unsigned int	ext_cd_gpio;
+	bool		ext_cd_gpio_invert;
+	unsigned int	max_speed;
+	u32		host_caps;
+	u32		host_caps2;
+	unsigned int	quirks;
+	unsigned int	quirks2;
+	unsigned int	pm_caps;
+};
+
+static void ersdhc_reset(struct sdhci_host *host, u8 mask)
+{
+	//struct platform_device *pdev = to_platform_device(mmc_dev(host->mmc));
+	//struct sdhci_ersdhc_platdata *pdata = pdev->dev.platform_data;
+
+	//sdhci_reset(host, mask);
+
+	ktime_t timeout;
+
+	sdhci_writew(host, 0x401, SDHCI_CLOCK_CONTROL); 
+
+
+	while(!(sdhci_readw(host, SDHCI_CLOCK_CONTROL) & 0x2)){// wait till internal clock stable is 1
+
+	//	printk("SDHCI_CLOCK_CONTROL  : %x",sdhci_readw(host, SDHCI_CLOCK_CONTROL));
+
+	}
+
+	sdhci_writeb(host, mask, SDHCI_SOFTWARE_RESET);
+	//printk("SDHCI CDAC MASK: %x",(int)mask);
+	if (mask & SDHCI_RESET_ALL) {
+		host->clock = 0;
+		/* Reset-all turns off SD Bus Power */
+		//if (host->quirks2 & SDHCI_QUIRK2_CARD_ON_NEEDS_BUS_ON)
+			//sdhci_runtime_pm_bus_off(host);
+	}
+
+	/* Wait max 100 ms */
+	timeout = ktime_add_ms(ktime_get(), 100);
+
+	/* hw clears the bit when it's done */
+	while (sdhci_readb(host, SDHCI_SOFTWARE_RESET) & mask) {
+		if (ktime_after(ktime_get(), timeout)) {
+			pr_err("%s: Reset 0x%x never completed.\n",
+				mmc_hostname(host->mmc), (int)mask);
+
+			sdhci_dumpregs(host);
+			return;
+		}
+		udelay(10);
+	}
+
+	//printk("[VEGA RESET VEGA RESET VEGA RESET VEGA RESET VEGA RESET VEGA RESET VEGA RESET VEGA RESET]");
+	return;
+}
+
+unsigned int cdac_sdhci_timeout_clock(struct sdhci_host *host) {
+	printk(" Timeout function");
+	return 25000;
+}
+/*
+static void cdac_sdhci_write_b (struct sdhci_host *host, u8 val, int reg){
+	u32 new_val = 0;
+	int new_reg;
+	u8 * val_pos = (u8 *) &new_val;
+
+	//mdelay(200);
+	new_reg = (reg & ALIGN_32_MASK);          // align to 32 bit address
+	new_val = readl(host->ioaddr + new_reg);  // read 32 bit value
+    val_pos+= (reg & ~ALIGN_32_MASK);         // finding index in 32 bit value
+	*val_pos = val;                           //setting value
+	//printk("[$$$] W8 reg : %x new_reg : %x val : %x new_val : %x \n",reg, new_reg, val, new_val);
+	printk("[08] W  ( %x : %x )  => ( %x : %x )\n", reg, val,  new_reg, new_val);
+	//printk(".");
+	writel(new_val, host->ioaddr + new_reg);
+}
+
+static void cdac_sdhci_write_w (struct sdhci_host *host, u16 val, int reg){
+	u32 new_val = 0;
+	int new_reg;
+	u16 * val_pos = (u16 *) &new_val;
+
+	//mdelay(200);
+	new_reg = (reg & ALIGN_32_MASK);          // align to 32 bit address
+	new_val = readl(host->ioaddr + new_reg);  // read 32 bit value
+    if (reg & ~ALIGN_32_MASK)         // finding index in 32 bit value
+		val_pos++;
+	*val_pos = val;                           //setting value
+	//printk("[$$$] W16 reg : %x new_reg : %x val : %x new_val : %x \n",reg, new_reg, val, new_val);
+	//if(reg == 0x2c)
+	printk("[16] W  ( %x : %x )  => ( %x : %x )\n", reg, val,  new_reg, new_val);
+	//printk(".");
+	writel(new_val, host->ioaddr + new_reg);
+}
+
+static u8 cdac_sdhci_read_b (struct sdhci_host *host, int reg){
+	u32 val = 0;
+	int new_reg;
+	u8 * ret = (u8 *) &val;
+
+	//mdelay(200);
+	new_reg = (reg & ALIGN_32_MASK);          // align to 32 bit address
+	val = readl(host->ioaddr + new_reg);  // read 32 bit value
+	ret+= (reg & ~ALIGN_32_MASK);         // finding index in 32 bit value
+	//if(reg == 0x2c)
+	//printk("[$$$] R8 reg : %x new_reg : %x val : %x new_val : %x \n",reg, new_reg, val, *ret);
+	//printk("[$$$] R reg : %x val : %x \n", reg, val);
+	//printk(".");
+	return *ret;
+}
+
+static u16 cdac_sdhci_read_w (struct sdhci_host *host, int reg){
+	u32 val = 0;
+	int new_reg;
+	u16 * ret = (u16 *) &val;
+
+	///mdelay(200);
+	new_reg = (reg & ALIGN_32_MASK);          // align to 32 bit address
+	val = readl(host->ioaddr + new_reg);  // read 32 bit value
+	 if (reg & ~ALIGN_32_MASK)         // finding index in 32 bit value
+		ret++;
+	//if(reg == 0x2c)
+//	printk("[$$$] R16 reg : %x new_reg : %x val : %x new_val : %x \n",reg, new_reg, val, *ret);
+	//printk("[$$$] R reg : %x val : %x \n", reg, val);
+	//printk(".");
+	return *ret;
+}
+*/
+void cdac_voltage_switch(struct sdhci_host *host){
+	printk("[     VEGA     ] Voltage Switch : %x \n", host->mmc->ios.signal_voltage);
+
+	usleep_range(5000, 6250);
+	/*
+		switch (host->mmc->ios.signal_voltage) {
+	case MMC_SIGNAL_VOLTAGE_330:
+		sdhci_writeb(host, SDHCI_POWER_ON | SDHCI_POWER_330, SDHCI_POWER_CONTROL);
+		break;
+	case MMC_SIGNAL_VOLTAGE_180:
+		sdhci_writeb(host, SDHCI_POWER_ON | SDHCI_POWER_180, SDHCI_POWER_CONTROL);
+		break;
+	default:
+		// No signal voltage switch required 
+		break;
+	}
+	*/
+}
+
+void cdac_sdhci_set_clock(struct sdhci_host *host, unsigned int clock)
+{
+	u16 clk;
+
+	host->mmc->actual_clock = 0;
+
+	sdhci_writew(host, 0, SDHCI_CLOCK_CONTROL);
+
+	if (clock == 0)
+		return;
+
+	clk = sdhci_calc_clk(host, clock, &host->mmc->actual_clock);
+	//printk("CLOCK SET");
+	//if(clk==0x400)
+		//clk = 0x300;
+
+	sdhci_enable_clk(host, clk);
+}
+
+
+static const struct sdhci_ops ersdhc_sdhci_ops = {
+	.set_clock     = sdhci_set_clock,
+	.get_max_clock = sdhci_pltfm_clk_get_max_clock,
+	.set_bus_width = sdhci_set_bus_width,
+	.reset         = ersdhc_reset,
+	.set_uhs_signaling = sdhci_set_uhs_signaling,
+	.get_timeout_clock = cdac_sdhci_timeout_clock,
+	//.write_b = cdac_sdhci_write_b,
+	//.write_w = cdac_sdhci_write_w,
+	//.read_b = cdac_sdhci_read_b,
+	//.read_w = cdac_sdhci_read_w,
+	//.voltage_switch = cdac_voltage_switch,
+};
+
+
+#ifdef CONFIG_OF
+static const struct of_device_id sdhci_ersdhc_of_match[] = {
+	{
+		.compatible = "cdac,cdac-sdhci",
+	},
+	{},
+};
+MODULE_DEVICE_TABLE(of, sdhci_ersdhc_of_match);
+
+static struct sdhci_ersdhc_platdata *ersdhc_get_mmc_pdata(struct device *dev)
+{
+	struct sdhci_ersdhc_platdata *pdata;
+	//struct device_node *np = dev->of_node;
+	//u32 bus_width;
+	//u32 clk_delay_cycles;
+
+
+	printk("ersdhc_get_mmc_pdata");
+	pdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);
+	if (!pdata)
+		return NULL;
+	return pdata;
+}
+#else
+static inline struct sdhci_ersdhc_platdata *ersdhc_get_mmc_pdata(struct device *dev)
+{
+	return NULL;
+}
+#endif
+
+static int sdhci_ersdhc_probe(struct platform_device *pdev)
+{
+	struct sdhci_pltfm_host *pltfm_host;
+	struct sdhci_ersdhc_platdata *pdata = pdev->dev.platform_data;
+	struct device *dev = &pdev->dev;
+	struct sdhci_host *host = NULL;
+	const struct of_device_id *match;
+
+	int ret;
+	//struct clk *clk;
+
+	//printk("Probe fun()\n");
+	//pr_err("TEST");
+	host = sdhci_pltfm_init(pdev, NULL, 0);
+	if (IS_ERR(host))
+		return PTR_ERR(host);
+
+	//clk = devm_clk_get(dev, "sdhci_clock");
+	pltfm_host = sdhci_priv(host);
+
+	//clk = devm_clk_get(dev, "sdhci_clock");
+	//if (IS_ERR(clk)) {
+	//	dev_err(dev, "failed to get io clock\n");
+	//	ret = PTR_ERR(clk);
+	//	goto free;
+	//}
+
+	//printk("probe host->clock = %x, clk = %x ",host->clock,clk_get_rate(clk));
+
+	//pltfm_host->clk = clk;
+
+	//printk("probe host->clock = %x, host->mmc->actual_clock = %x, /host->mmc->ios->clock = %x", host->clock, host->mmc->actual_clock, host->mmc->ios.clock);
+
+	//host->clock
+	//host->mmc->actual_clock
+	//host->mmc->ios.clock
+
+	//ret = clk_prepare_enable(clk);
+	//if (ret) {
+	//	dev_err(&pdev->dev, "failed to enable io clock\n");
+	//	goto free;
+	//}
+	//printk("2probe host->clock = %x, host->mmc->actual_clock = %x, /host->mmc->ios->clock = %x", host->clock, host->mmc->actual_clock, host->mmc->ios.clock);
+
+	host->quirks = SDHCI_QUIRK_BROKEN_ADMA | SDHCI_QUIRK_BROKEN_DMA| SDHCI_QUIRK_MULTIBLOCK_READ_ACMD12;
+	//	| SDHCI_QUIRK_CAP_CLOCK_BASE_BROKEN;
+
+			//	| SDHCI_QUIRK_BROKEN_TIMEOUT_VAL
+
+
+    // CDAC
+	//host->quirks |= SDHCI_QUIRK_MISSING_CAPS ;
+	host->quirks2 = SDHCI_QUIRK2_PRESET_VALUE_BROKEN | SDHCI_QUIRK2_DISABLE_HW_TIMEOUT | SDHCI_QUIRK2_NO_1_8_V;//| SDHCI_QUIRK2_PRESET_VALUE_BROKEN;
+	host->mmc->caps2 = MMC_CAP2_NO_SDIO | MMC_CAP2_NO_MMC ;
+
+	match = of_match_device(of_match_ptr(sdhci_ersdhc_of_match), &pdev->dev);
+	if (match) {
+		pdata = ersdhc_get_mmc_pdata(dev);
+	}
+	/*
+	if (pdata) {
+		if (pdata->flags & PXA_FLAG_CARD_PERMANENT) {
+			// on-chip device 
+			printk("Test");
+		}
+	}
+	*/
+	host->ops = &ersdhc_sdhci_ops;
+	//printk("Ok 1 \n");
+	//printk("1 mmc caps2 : %x",host->mmc->caps2 );
+	ret = sdhci_add_host(host);
+	//printk("1b mmc caps2 : %x",host->mmc->caps2 );
+	//printk("Ok 2, ret = %d \n",ret);
+	//printk(" Caps : %x, Capas1 : %x Quirks : %x Quirks2 : %x \n", host->caps, host->caps1, host->quirks, host->quirks2);
+	//if (ret)
+		//goto disable_clk;
+
+	//printk(" Caps : %x, Capas1 : %x Quirks : %x Quirks2 : %x \n", host->caps, host->caps1, host->quirks, host->quirks2);
+	//printk("probeX host->clock = %x, host->mmc->actual_clock = %x, /host->mmc->ios->clock = %x", host->clock, host->mmc->actual_clock, host->mmc->ios.clock);
+	return 0;
+
+//disable_clk:
+	//clk_disable_unprepare(clk);
+//free:
+	//sdhci_pltfm_free(pdev);
+	return ret;
+}
+
+static struct platform_driver sdhci_ersdhc_driver = {
+	.driver		= {
+		.name	= "sdhci-cdac",
+		.of_match_table = of_match_ptr(sdhci_ersdhc_of_match),
+		.pm	= &sdhci_pltfm_pmops,
+	},
+	.probe		= sdhci_ersdhc_probe,
+	.remove		= sdhci_pltfm_unregister,
+};
+
+module_platform_driver(sdhci_ersdhc_driver);
+
+MODULE_DESCRIPTION("SDHCI driver for C-DAC SDHCI controller");
+MODULE_AUTHOR("Anoop Varghese <vanoop@cdac.in>");
+MODULE_LICENSE("GPL v2");
+
diff -Naur linux-5.4.1/drivers/net/ethernet/cdac/cdac_gmac.c linux-5.4.1_modified/drivers/net/ethernet/cdac/cdac_gmac.c
--- linux-5.4.1/drivers/net/ethernet/cdac/cdac_gmac.c	1970-01-01 05:30:00.000000000 +0530
+++ linux-5.4.1_modified/drivers/net/ethernet/cdac/cdac_gmac.c	2025-08-08 10:40:35.451924005 +0530
@@ -0,0 +1,1078 @@
+/*
+ * drivers/net/ethernet/nxp/cdac_eth.c
+ *
+ * Author: Kevin Wells <kevin.wells@nxp.com>
+ *
+ * Copyright (C) 2010 NXP Semiconductors
+ * Copyright (C) 2012 Roland Stigge <stigge@antcom.de>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/errno.h>
+#include <linux/ioport.h>
+#include <linux/crc32.h>
+#include <linux/platform_device.h>
+#include <linux/spinlock.h>
+#include <linux/ethtool.h>
+#include <linux/stddef.h>
+#include <linux/mii.h>
+#include <linux/clk.h>
+#include <linux/workqueue.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/phy.h>
+#include <linux/dma-mapping.h>
+#include <linux/of.h>
+#include <linux/of_net.h>
+#include <linux/of_irq.h>
+#include <linux/of_platform.h>
+#include <linux/of_address.h>
+#include <linux/types.h>
+#include <linux/irqdomain.h>
+#include <linux/spinlock.h>
+
+#include <linux/io.h>
+
+#include "cdac_gmac.h"
+#include "ergmac.h"
+#include <asm/csr.h>
+
+#define MODNAME "cdac_gmac"
+#define DRV_NAME        "cdac_gmac"
+#define DRV_VERSION 	"1.00"
+#define DRV_DESC        "CDAC GMAC driver"
+
+#define DEBUG
+
+#define ENET_MAXF_SIZE 1536
+#define ENET_RX_DESC 48
+#define ENET_TX_DESC 16
+
+#define NAPI_WEIGHT 0
+
+#define NO_IRQ	((unsigned int)(-1))
+
+void __iomem *			gDma_base;
+
+/*
+ * powerdown register definitions
+ */
+#define CDAC_POWERDOWN_MACAHB			(1 << 31)
+
+
+
+static phy_interface_t cdac_phy_interface_mode(struct device *dev) {
+	if (dev && dev->of_node) {
+		const char *mode = of_get_property(dev->of_node, "phy-mode", NULL);
+		if (mode && !strcmp(mode, "gmii"))
+			return PHY_INTERFACE_MODE_GMII;
+		else
+			return PHY_INTERFACE_MODE_SGMII;
+	}
+	return PHY_INTERFACE_MODE_GMII;
+}
+
+/*
+ * MAC support functions
+ */
+static void __cdac_set_mac(struct net_device *ndev, u8 *mac) {
+	unsigned int mac_addr;
+	struct dev_priv *priv = netdev_priv(ndev);
+
+	mac_addr = mac[0] << 24 | mac[1] << 16 | mac[2] << 8 | mac[3];
+	//cdac_writeword(priv->net_base, ERGMAC_ADDR_HIGH_REG, mac_addr);
+	writel(mac_addr,(priv->net_base+ERGMAC_ADDR_HIGH_REG));
+	mac_addr = mac[4] << 8 | mac[5];
+	//cdac_writeword(priv->net_base, ERGMAC_ADDR_LOW_REG, mac_addr);
+	writel(mac_addr,(priv->net_base+ERGMAC_ADDR_LOW_REG));
+	netdev_dbg(ndev, "Ethernet MAC address %pM\n", mac);
+}
+
+static void __cdac_get_mac(struct net_device *ndev, u8 *mac) {
+	unsigned int mac_addr;
+  struct dev_priv *priv = netdev_priv(ndev);
+	//mac_addr = readl(priv->net_base, ERGMAC_ADDR_HIGH_REG);
+	mac_addr =  readl((priv->net_base+ERGMAC_ADDR_HIGH_REG));
+	mac[0] = mac_addr >> 24;
+	mac[1] = (mac_addr >> 16) & 0xff;
+	mac[2] = (mac_addr >> 8) & 0xff;
+	mac[3] = mac_addr & 0xff;
+	mac_addr = readl((priv->net_base+ERGMAC_ADDR_LOW_REG));
+	mac[4] = (mac_addr >> 8) & 0xff;
+	mac[5] = mac_addr & 0xff;
+}
+
+static void __cdac_params_setup(struct net_device *ndev) {
+	//printk("*********__cdac_params_setup \n");
+}
+
+static void __cdac_eth_reset(struct net_device *ndev) {
+	//printk("*********__cdac_eth_reset \n");
+
+}
+
+static int __cdac_mii_mngt_reset(struct dev_priv *priv) {
+	//printk("*********__cdac_mii_mngt_reset \n");
+
+	return 0;
+}
+
+static void cdac_eth_enable_int(void __iomem *regbase) {
+	//printk("*********cdac_eth_enable_int \n");
+
+}
+
+//static void cdac_eth_disable_int(void __iomem *regbase) {
+	//printk("*********cdac_eth_disable_int \n");
+
+//}
+
+static void __cdac_eth_init(struct net_device *ndev) {
+	struct dev_priv *priv = netdev_priv(ndev);
+
+	__cdac_params_setup(ndev);
+
+	smp_wmb();
+
+	Init_PHY_default_SAF_GMAC(priv->net_base);
+
+	cdac_eth_enable_int((void __iomem *)(priv->net_base));
+
+}
+
+static void __cdac_eth_shutdown(struct net_device *ndev) {
+	/* Reset ethernet and power down PHY */
+	__cdac_eth_reset(ndev);
+}
+
+/*
+ * MAC<--->PHY support functions
+ */
+static int cdac_mdio_read(struct mii_bus *bus, int phy_id, int phyreg) {
+	int lps = 0;
+	unsigned int mdio_op_reg;
+	struct dev_priv *priv = bus->priv;
+	//printk("*********cdac_mdio_read\n");
+ //cdac_writeword(priv->net_base, ERGMAC_MDIO_OPERATION_REG, (MDIO_READ_COMMAND | (phy_id << 26) |(phyreg << 21))); //command for read
+
+
+	writel((MDIO_READ_COMMAND | (phy_id << 26) |(phyreg << 21)),(priv->net_base+ERGMAC_MDIO_OPERATION_REG));
+	__asm__ __volatile__ ("fence"); //To complete the read fifo operation in O-O-O processor
+	while (1) {
+	//	printk("*********loop\n");
+		mdio_op_reg = readl((priv->net_base+ERGMAC_MDIO_OPERATION_REG));
+		__asm__ __volatile__ ("fence");
+	//	printk("%lx\n",mdio_op_reg);
+		if (mdio_op_reg & (1 << 31))
+			break; //read OK
+	}
+
+	lps = readl((priv->net_base+ERGMAC_MDIO_READ_DATA_REG)); //phy reg data
+	//printk("*********cdac_mdio_read exit\n");
+	return lps;
+}
+
+
+/*static int cdac_phyreg_read(int phy_id, int phyreg) {
+
+	int lps = 0;
+	unsigned int mdio_op_reg;
+
+	cdac_writeword(0, ERGMAC_MDIO_OPERATION_REG, (MDIO_READ_COMMAND | (phy_id << 26) |(phyreg << 21)));
+	while (1) {
+
+		mdio_op_reg = readl(0, ERGMAC_MDIO_OPERATION_REG);
+		if (mdio_op_reg & (1 << 31))
+			break; //read OK
+	}
+
+	lps = readl(0, ERGMAC_MDIO_READ_DATA_REG); //phy reg data
+
+	return lps;
+}*/
+
+
+static int cdac_mdio_write(struct mii_bus *bus, int phy_id, int phyreg,	u16 phydata) {
+/*	unsigned int mdio_op_reg;
+
+	cdac_writeword(bus->priv->net_base, ERGMAC_MDIO_WRITE_DATA_REG, phydata); //data to write
+	cdac_writeword(bus->priv->net_base, ERGMAC_MDIO_OPERATION_REG, (MDIO_WRITE_COMMAND | (phy_id << 26) |( phyreg << 21))); //command for write
+	__asm__ __volatile__ ("fence"); //To complete the read fifo operation in O-O-O processor
+	 while (1){
+		 mdio_op_reg = readl(priv->net_base,ERGMAC_MDIO_OPERATION_REG);
+		 if(mdio_op_reg & (1 << 31))
+			break; //PHY reg write OK
+	 }*/
+	return 0;
+}
+
+static int cdac_mdio_reset(struct mii_bus *bus) {
+	//printk("*********cdac_mdio_reset \n");
+
+	return __cdac_mii_mngt_reset((struct dev_priv *) bus->priv);
+}
+
+static void cdac_handle_link_change(struct net_device *ndev) {
+	struct phy_device *phydev = ndev->phydev;
+	unsigned long flags;
+	struct dev_priv *priv = netdev_priv(ndev);
+
+	bool status_change = false;
+
+	spin_lock_irqsave(&priv->chip_lock, flags);
+
+	if (phydev->link) {
+		if ((priv->speed != phydev->speed)
+				|| (priv->duplex != phydev->duplex)) {
+			priv->speed = phydev->speed;
+			priv->duplex = phydev->duplex;
+			status_change = true;
+		}
+	}
+
+	if (phydev->link != priv->link) {
+		if (!phydev->link) {
+			priv->speed = 0;
+			priv->duplex = -1;
+		}
+		priv->link = phydev->link;
+
+		status_change = true;
+	}
+
+	spin_unlock_irqrestore(&priv->chip_lock, flags);
+
+	if (status_change) {
+		if (phydev->link) {
+			netdev_info(ndev, "link up (%d/%s)\n",
+			       phydev->speed,
+			       DUPLEX_FULL == phydev->duplex ? "Full" : "Half");
+			//netif_carrier_on(ndev);
+		}
+		else {
+			netdev_info(ndev, "link down\n");
+			//netif_carrier_off(ndev);
+		}
+		__cdac_params_setup(ndev);
+	}
+}
+
+static int cdac_mii_probe(struct net_device *ndev) {
+	struct dev_priv *priv = netdev_priv(ndev);
+	struct phy_device *phydev = phy_find_first(priv->mii_bus);
+
+	if (!phydev) {
+		netdev_err(ndev, "no PHY found\n");
+		return -ENODEV;
+	}
+
+	//printk("*********cdac_mii_probe \n");
+
+	/* Attach to the PHY */
+	if (cdac_phy_interface_mode(&priv->pdev->dev) == PHY_INTERFACE_MODE_GMII)
+		netdev_info(ndev, "using GMII interface\n");
+	else
+		netdev_info(ndev, "using RMII interface\n");
+	phydev = phy_connect(ndev, phydev_name(phydev), &cdac_handle_link_change,
+			cdac_phy_interface_mode(&priv->pdev->dev));
+
+	if (IS_ERR(phydev)) {
+		netdev_err(ndev, "Could not attach to PHY\n");
+		return PTR_ERR(phydev);
+	}
+
+	/* mask with MAC supported features */
+	//phydev->supported &= PHY_BASIC_FEATURES;
+         linkmode_and(phydev->supported, phydev->supported, PHY_BASIC_FEATURES);
+
+
+	//phydev->advertising = phydev->supported;
+	linkmode_copy(phydev->advertising, phydev->supported);
+
+
+	phy_attached_info(phydev);
+
+	return 0;
+}
+
+static int cdac_mii_init(struct net_device *ndev) {
+	int err;
+	struct dev_priv *priv = netdev_priv(ndev);
+	int i;
+	const char *mode;
+	err = -ENXIO;
+	priv->mii_bus = mdiobus_alloc();
+	if (!priv->mii_bus) {
+		err = -ENOMEM;
+		goto err_out;
+	}
+
+	priv->mii_bus->name = "cdac_mii_bus";
+	priv->mii_bus->read = &cdac_mdio_read;
+	priv->mii_bus->write = &cdac_mdio_write;
+	priv->mii_bus->reset = &cdac_mdio_reset;
+
+	snprintf(priv->mii_bus->id, MII_BUS_ID_SIZE, "%s-%x", priv->pdev->name,
+			priv->pdev->id);
+	priv->mii_bus->priv = priv;
+	priv->mii_bus->parent = &priv->pdev->dev;
+
+
+	for (i = 0; i < PHY_MAX_ADDR; i++)
+		priv->mii_bus->irq[i] = PHY_POLL;
+
+
+	mode = of_get_property(priv->pdev->dev.of_node, "platform", NULL);
+	if (mode && !strcmp(mode, "htg_virtex7"))
+		priv->mii_bus->phy_mask = ~(1 << 3);// used phy
+
+
+	platform_set_drvdata(priv->pdev, priv->mii_bus);
+
+	if (mdiobus_register(priv->mii_bus))
+		goto err_out_unregister_bus;
+	if (cdac_mii_probe(priv->ndev) != 0)
+		goto err_out_unregister_bus;
+
+	return 0;
+
+	err_out_unregister_bus: mdiobus_unregister(priv->mii_bus);
+	mdiobus_free(priv->mii_bus);
+	err_out: return err;
+}
+
+static void __cdac_handle_xmit(struct net_device *ndev) {
+	//struct dev_priv *priv = netdev_priv(ndev);
+	//int skblen;
+
+	/*skblen=priv->tx_len[priv->tx_intr_index];
+	priv->tx_intr_index++;
+	if(priv->tx_intr_index==100)
+		priv->tx_intr_index=0;
+
+	ndev->stats.tx_bytes += skblen;*/
+	//printk("*********__cdac_handle_xmit\n");
+	ndev->stats.tx_packets++;
+}
+
+
+static int __cdac_handle_recv(struct net_device *ndev, int budget) {
+	struct dev_priv *priv = netdev_priv(ndev);
+	int rx_done = 0;
+	unsigned int len = 0;
+	struct sk_buff *skb;
+	//printk("*********__cdac_handle_recv\n");
+	while(1) {
+
+		if ((len = check_gmac_rx(priv->net_base)) == 0) {
+			return 0;
+		}
+
+		/* Packet is good */
+		skb = netdev_alloc_skb(ndev, (len+2));
+		if (!skb) {
+			ndev->stats.rx_dropped++;
+		} else {
+			skb_reserve(skb, 2);
+			receive_ethernet(skb->data, priv->net_base, len);
+			skb_put(skb, len);
+			skb->protocol = eth_type_trans(skb, ndev);
+			netif_rx(skb);
+			ndev->stats.rx_packets++;
+			ndev->stats.rx_bytes += len;
+		}
+	}
+
+	return rx_done;
+}
+
+/*static int cdac_eth_poll(struct napi_struct *napi, int budget) {
+	struct dev_priv
+	*priv = container_of(napi, struct dev_priv, napi);
+	struct net_device *ndev = priv->ndev;
+	int rx_done = 0;
+	//struct netdev_queue *txq = netdev_get_tx_queue(ndev, 0);
+
+	//printk("*********cdac_eth_poll %d \n", budget);
+
+	//__netif_tx_lock(txq, smp_processor_id());
+	//__cdac_handle_xmit(ndev);
+	//__netif_tx_unlock(txq);
+	rx_done = __cdac_handle_recv(ndev, budget);
+
+	//if (rx_done < budget) {
+	//napi_complete_done(napi, rx_done);
+	//cdac_eth_enable_int(priv->net_base);
+	//}
+
+	return rx_done;
+}*/
+
+int gIntrflag = 0;
+
+static irqreturn_t __cdac_eth_interrupt(int irq, void *dev_id) {
+	struct net_device *ndev = dev_id;
+	struct dev_priv *priv = netdev_priv(ndev);
+	UI intr_status;
+	//printk("*********__cdac_eth_interrupt\n");
+	spin_lock(&priv->chip_lock);
+
+	intr_status = readl(priv->net_base+ERGMAC_INTR_STATUS_REG); //to clear gmac interrupt
+	__asm__ volatile ("fence");
+
+	if (intr_status & (1 << 30)) {
+		//printk("*********__cdac_handle_xmit\n");
+
+		__cdac_handle_xmit(ndev);
+	}
+
+	if (intr_status & (1 << 24)) {
+		//printk("*********__cdac_handle_recv\n");
+
+		__cdac_handle_recv(ndev, 0);
+	}
+//	printk("[C-DAC DEBUG] before sbi_clear_seip_set_meie@cdac_gmac\n");
+	//sbi_clear_seip_set_meie(); //clear seip, and set meie after supervisor ext. intr.
+  //printk("[C-DAC DEBUG] after sbi_clear_seip_set_meie@cdac_gmac\n");
+	//sbi_clear_suip_set_muie();
+
+
+	spin_unlock(&priv->chip_lock);
+
+	//printk("********* __cdac_eth_interrupt finished\n");
+	return IRQ_HANDLED;
+}
+
+#ifdef CONFIG_NET_POLL_CONTROLLER
+/*static void cdac_gmac_poll(struct net_device *ndev)
+ {
+ unsigned long flags;
+ printk("*********cdac_gmac_poll?????????????? \n");
+ //local_irq_save(flags);
+ //__cdac_eth_interrupt(0, ndev);
+ //local_irq_restore(flags);
+ }*/
+#endif
+
+static int cdac_eth_close(struct net_device *ndev) {
+	unsigned long flags;
+	struct dev_priv *priv = netdev_priv(ndev);
+
+	if (netif_msg_ifdown(priv))
+		dev_dbg(&priv->pdev->dev, "shutting down %s\n", ndev->name);
+
+	//napi_disable(&priv->napi);
+
+	//del_timer_sync(&priv->timer);
+
+	netif_stop_queue(ndev);
+
+	if (ndev->phydev)
+		phy_stop(ndev->phydev);
+
+	spin_lock_irqsave(&priv->chip_lock, flags);
+	__cdac_eth_reset(ndev);
+
+	free_irq(ndev->irq, ndev);
+
+	//netif_carrier_off(ndev);
+	spin_unlock_irqrestore(&priv->chip_lock, flags);
+
+	return 0;
+}
+
+static int cdac_eth_hard_start_xmit(struct sk_buff *skb,
+		struct net_device *ndev) {
+	struct dev_priv *priv = netdev_priv(ndev);
+	unsigned long flags;
+	//unsigned int tx_status;
+
+	spin_lock_irqsave(&priv->chip_lock, flags);
+
+	/*tx_status = readl(priv->net_base, ERGMAC_TX_DATA_FIFO_STATUS_REG);
+	tx_status = (tx_status & 0x7ff) * 4;	//bytes in tx fifo
+	tx_status = 8000 - tx_status; //free space  in tx fifo*/
+
+	/*if (skb->len > tx_status) {
+		// This function should never be called when there are no
+		// buffers
+		printk("*********netif_stop_queue : \n");
+		netif_stop_queue(ndev);
+		spin_unlock_irqrestore(&priv->chip_lock, flags);
+		WARN(1, "BUG! TX request when no free TX buffers!\n");
+		return NETDEV_TX_BUSY;
+	}*/
+
+	send_ethernet(skb->data, priv->net_base, skb->len);
+
+	ndev->stats.tx_bytes += skb->len;
+
+	/*priv->tx_len[priv->tx_index] = skb->len;
+	priv->tx_index++;
+	if(priv->tx_index == 100)
+		priv->tx_index = 0;
+
+	tx_status = readl(0, ERGMAC_TX_DATA_FIFO_STATUS_REG);
+	tx_status = (tx_status & 0x7ff) * 4;		//bytes in tx fifo
+	tx_status = 8000 - tx_status; //free space  in tx fifo*/
+
+	/*if (skb->len > tx_status) {
+		/ //This function should never be called when there are no
+		// buffers
+		printk("*********netif_stop_queue : \n");
+		netif_stop_queue(ndev);
+	}*/
+
+	wmb();
+	/* drain writebuffer */
+	dev_kfree_skb_any(skb);
+
+	spin_unlock_irqrestore(&priv->chip_lock, flags);
+
+	return NETDEV_TX_OK;
+}
+
+static int cdac_set_mac_address(struct net_device *ndev, void *p) {
+	struct sockaddr *addr = p;
+	struct dev_priv *priv = netdev_priv(ndev);
+	unsigned long flags;
+
+	if (!is_valid_ether_addr(addr->sa_data))
+		return -EADDRNOTAVAIL;
+	memcpy(ndev->dev_addr, addr->sa_data, ETH_ALEN);
+
+	spin_lock_irqsave(&priv->chip_lock, flags);
+
+	/* Set station address */
+	__cdac_set_mac(ndev, ndev->dev_addr);
+
+	spin_unlock_irqrestore(&priv->chip_lock, flags);
+
+	return 0;
+}
+
+//static void cdac_eth_set_multicast_list(struct net_device *ndev) {
+
+	//printk("*********cdac_eth_set_multicast_list \n");
+
+/*#ifdef __USED_CDAC
+
+	struct dev_priv *priv = netdev_priv(ndev);
+	struct netdev_hw_addr_list *mcptr = &ndev->mc;
+	struct netdev_hw_addr *ha;
+	u32 tmp32, hash_val, hashlo, hashhi;
+	unsigned long flags;
+
+	spin_lock_irqsave(&priv->chip_lock, flags);
+
+	// Set station address //
+	__cdac_set_mac(pldat, ndev->dev_addr);
+
+	tmp32 = CDAC_RXFLTRW_ACCEPTUBROADCAST | CDAC_RXFLTRW_ACCEPTPERFECT;
+
+	if (ndev->flags & IFF_PROMISC)
+	tmp32 |= CDAC_RXFLTRW_ACCEPTUNICAST |
+	CDAC_RXFLTRW_ACCEPTUMULTICAST;
+	if (ndev->flags & IFF_ALLMULTI)
+	tmp32 |= CDAC_RXFLTRW_ACCEPTUMULTICAST;
+
+	if (netdev_hw_addr_list_count(mcptr))
+	tmp32 |= CDAC_RXFLTRW_ACCEPTUMULTICASTHASH;
+
+//	writel(tmp32, CDAC_ENET_RXFILTER_CTRL(pldat->net_base));
+
+	// Set initial hash table //
+	hashlo = 0x0;
+	hashhi = 0x0;
+
+	// 64 bits : multicast address in hash table //
+	netdev_hw_addr_list_for_each(ha, mcptr) {
+		hash_val = (ether_crc(6, ha->addr) >> 23) & 0x3F;
+
+		if (hash_val >= 32)
+		hashhi |= 1 << (hash_val - 32);
+		else
+		hashlo |= 1 << hash_val;
+	}
+
+	//writel(hashlo, CDAC_ENET_HASHFILTERL(pldat->net_base));
+	//writel(hashhi, CDAC_ENET_HASHFILTERH(pldat->net_base));
+
+	spin_unlock_irqrestore(&priv->chip_lock, flags);
+
+#endif //__USED_CDAC*/
+
+//}
+
+static int cdac_eth_ioctl(struct net_device *ndev, struct ifreq *req, int cmd) {
+	//printk("*********cdac_eth_ioctl \n");
+
+	struct phy_device *phydev = ndev->phydev;
+
+	if (!netif_running(ndev))
+		return -EINVAL;
+
+	if (!phydev)
+		return -ENODEV;
+
+	return phy_mii_ioctl(phydev, req, cmd);
+}
+
+static int cdac_eth_open(struct net_device *ndev) {
+
+	struct dev_priv *priv = netdev_priv(ndev);
+	int err;
+
+	if (netif_msg_ifup(priv))
+		dev_dbg(&priv->pdev->dev, "enabling %s\n", ndev->name);
+
+	/* Suspended PHY makes CDAC ethernet core block, so resume now */
+	//phy_resume(ndev->phydev);
+
+	/* Reset and initialize */
+	__cdac_eth_reset(ndev);
+
+	/* Setup error IRQ handler */
+	err = request_irq(ndev->irq, __cdac_eth_interrupt, 0, ndev->name, ndev);
+	if (err) {
+		printk(KERN_ERR "%s: failed to request IRQ %d\n",
+		       ndev->name, ndev->irq);
+		return err;
+	}
+
+	__cdac_eth_init(ndev);
+//	printk("eth open 1 ok \n");
+
+	priv->tx_index=0;
+	priv->tx_intr_index=0;
+
+	/* schedule a link state check */
+	phy_start(ndev->phydev);
+//	printk("eth open 2 ok \n");
+
+	//priv->timer.expires = jiffies;
+
+	//add_timer(&priv->timer);
+
+	netif_start_queue(ndev);
+
+//	printk("eth open 3 ok \n");
+
+	//napi_enable(&priv->napi);
+
+	return 0;
+}
+
+/*
+ * Ethtool ops
+ */
+static void cdac_eth_ethtool_getdrvinfo(struct net_device *ndev,
+		struct ethtool_drvinfo *info) {
+	strlcpy(info->driver, MODNAME, sizeof(info->driver));
+	strlcpy(info->version, DRV_VERSION, sizeof(info->version));
+	strlcpy(info->bus_info, dev_name(ndev->dev.parent), sizeof(info->bus_info));
+}
+
+static u32 cdac_eth_ethtool_getmsglevel(struct net_device *ndev) {
+	struct dev_priv *priv = netdev_priv(ndev);
+
+	return priv->msg_enable;
+}
+
+static void cdac_eth_ethtool_setmsglevel(struct net_device *ndev, u32 level) {
+	struct dev_priv *priv = netdev_priv(ndev);
+
+	priv->msg_enable = level;
+}
+
+static const struct ethtool_ops cdac_eth_ethtool_ops = { .get_drvinfo =
+		cdac_eth_ethtool_getdrvinfo, .get_msglevel =
+		cdac_eth_ethtool_getmsglevel, .set_msglevel =
+		cdac_eth_ethtool_setmsglevel, .get_link = ethtool_op_get_link,
+		.get_link_ksettings = phy_ethtool_get_link_ksettings,
+		.set_link_ksettings = phy_ethtool_set_link_ksettings, };
+
+static const struct net_device_ops cdac_netdev_ops = {
+		.ndo_open = cdac_eth_open, .ndo_stop = cdac_eth_close, .ndo_start_xmit =
+				cdac_eth_hard_start_xmit,
+//	.ndo_set_rx_mode	= cdac_eth_set_multicast_list,
+		.ndo_do_ioctl = cdac_eth_ioctl, .ndo_set_mac_address =
+				cdac_set_mac_address, .ndo_validate_addr = eth_validate_addr,
+/*#ifdef CONFIG_NET_POLL_CONTROLLER
+ .ndo_poll_controller	 = cdac_gmac_poll,
+ #endif*/
+};
+
+/*static void cdac_riscv_mask_irq(struct irq_data *d) {
+	//printk("cdac_riscv_mask_irq\n");
+
+}
+
+static void cdac_riscv_unmask_irq(struct irq_data *d) {
+	//printk("cdac_riscv_unmask_irq\n");
+
+}
+
+static struct irq_chip cdac_riscv_irq_chip = { .irq_ack = cdac_riscv_mask_irq,
+		.irq_mask = cdac_riscv_mask_irq, .irq_unmask = cdac_riscv_unmask_irq,
+		.name = "gmac_irq" };*/
+
+//static void cdac_eth_timer(struct timer_list *t) {
+
+	/*struct dev_priv	  *priv = from_timer(priv, t, timer);
+	struct net_device *dev = priv->ndev;
+
+	//struct net_device *dev = (struct net_device *) data;
+	//struct dev_priv *priv = netdev_priv(dev);
+	struct phy_device *phydev=dev->phydev;
+
+	unsigned int lnkstat, carrier;
+	unsigned long flags;
+
+	spin_lock_irqsave(&priv->chip_lock, flags);
+	lnkstat = cdac_phyreg_read(3, 1);
+	lnkstat = 1;//(lnkstat >> 2) & 1;// Linkup bit
+	printk("%d: link stat\n", lnkstat);
+	spin_unlock_irqrestore(&priv->chip_lock, flags);
+	//phydev->link;//1;
+	//read_ireg(dev->base_addr, ISALED0) & ISALED0_LNKST;
+
+	carrier = netif_carrier_ok(dev);
+
+	printk("%d:  carrier\n", carrier);
+
+	if (lnkstat && !carrier) {
+		netif_carrier_on(dev);
+		printk("%s: link up\n", dev->name);
+	} else if (!lnkstat && carrier) {
+		netif_carrier_off(dev);
+		printk("%s: link down\n", dev->name);
+	}
+
+	mod_timer(&priv->timer, jiffies + msecs_to_jiffies(2000));
+
+	//printk("cdac_eth_timer:time_out=%lx\n", (jiffies + msecs_to_jiffies(500)));*/
+//}
+
+/*struct riscv_irq_data {
+	struct irq_chip chip;
+	struct irq_domain *domain;
+	int hart;
+	char name[20];
+};
+DEFINE_PER_CPU(struct riscv_irq_data, extern riscv_irq_data);*/
+
+
+static int cdac_dma_drv_probe(struct platform_device *pdev) {
+	struct resource dma_resource;
+	struct device_node *np = pdev->dev.of_node;
+
+	if (of_get_property(np, "disabled", NULL) || !of_device_is_available(np))
+		return -ENODEV;
+
+	/* Map EMAC regs */
+	if (of_address_to_resource(np, 0, &dma_resource)) {
+		printk(KERN_ERR "%s: Can't get registers address\n",
+		       np->full_name);
+	}
+
+	gDma_base = ioremap_nocache(dma_resource.start, resource_size(&dma_resource));
+	printk("cdac_dma initialized at %lx \n", (unsigned long) gDma_base);
+
+	if (gDma_base == NULL) {
+		printk(KERN_ERR "%s: Can't map device registers!\n",  np->full_name);
+	}
+
+	return 0;
+}
+
+static int cdac_dma_drv_remove(struct platform_device *pdev) {
+
+	iounmap((volatile void *)(gDma_base));
+	return 0;
+}
+
+static int cdac_eth_drv_probe(struct platform_device *pdev) {
+	struct resource gmac_resource;
+	struct net_device *ndev;
+	struct dev_priv *priv;
+	struct phy_device *phydev;
+	struct device_node *np = pdev->dev.of_node;
+	int irq, ret = 0;
+	if (of_get_property(np, "disabled", NULL) || !of_device_is_available(np))
+		return -ENODEV;
+
+	/* Allocate net driver data structure */
+	ndev = alloc_etherdev(sizeof(struct dev_priv));
+	if (!ndev) {
+		dev_err(&pdev->dev, "could not allocate device.\n");
+		ret = -ENOMEM;
+		goto err_exit;
+	}
+	SET_NETDEV_DEV(ndev, &pdev->dev);
+	priv = netdev_priv(ndev);
+	priv->pdev = pdev;
+	priv->ndev = ndev;
+
+	spin_lock_init(&priv->chip_lock);
+	irq =  irq_of_parse_and_map(np, 0);
+	if (irq == NO_IRQ) {
+		printk(KERN_ERR "%s: Can't map main interrupt\n", np->full_name);
+		goto err_out_free_dev;
+	}
+
+	ndev->irq = irq;
+
+	/* Map EMAC regs */
+	if (of_address_to_resource(np, 0, &gmac_resource)) {
+		printk(KERN_ERR "%s: Can't get registers address\n",
+		       np->full_name);
+		goto err_irq_unmap;
+	}
+
+	//priv->net_base = ioremap(gmac_resource.start, resource_size(&gmac_resource));
+	priv->net_base = ioremap_nocache(gmac_resource.start, resource_size(&gmac_resource));
+
+	if (priv->net_base == NULL) {
+		printk(KERN_ERR "%s: Can't map device registers!\n",  np->full_name);
+		ret = -ENOMEM;
+		goto err_irq_unmap;
+	}
+	ndev->base_addr = (unsigned long)priv->net_base;
+	/* Setup driver functions */
+	ndev->netdev_ops = &cdac_netdev_ops;
+	ndev->ethtool_ops = &cdac_eth_ethtool_ops;
+	ndev->watchdog_timeo = msecs_to_jiffies(10000);
+	netdev_dbg(ndev, "IO address space     :%pR\n", &gmac_resource);
+	netdev_dbg(ndev, "IO address size      :%lld\n", resource_size(&gmac_resource));
+	netdev_dbg(ndev, "IO address (mapped)  :0x%ld\n", (long int)priv->net_base);
+	netdev_dbg(ndev, "IRQ number           :%d\n", ndev->irq);
+
+
+	/* Get MAC address from current HW setting (POR state is all zeros) */
+	__cdac_get_mac(ndev, ndev->dev_addr);
+	if (!is_valid_ether_addr(ndev->dev_addr)) {
+		const char *macaddr = of_get_mac_address(pdev->dev.of_node);
+		if (macaddr)
+			memcpy(ndev->dev_addr, macaddr, ETH_ALEN);
+	}
+	if (!is_valid_ether_addr(ndev->dev_addr))
+		eth_hw_addr_random(ndev);
+
+	/* Reset the ethernet controller */
+	__cdac_eth_reset(ndev);
+	/* then shut everything down to save power */
+	__cdac_eth_shutdown(ndev);
+
+	/* Set default parameters */
+	priv->msg_enable = NETIF_MSG_LINK;
+
+	/* Force an MII interface reset and clock setup */
+	__cdac_mii_mngt_reset(priv);
+
+	/* Force default PHY interface setup in chip, this will probably be
+	 changed by the PHY driver */
+	priv->link = 0;
+	priv->speed = 1000;
+	priv->duplex = DUPLEX_FULL;
+	__cdac_params_setup(ndev);
+
+	//netif_napi_add(ndev, &priv->napi, cdac_eth_poll, NAPI_WEIGHT);
+
+	ret = register_netdev(ndev);
+	if (ret) {
+		dev_err(&pdev->dev, "Cannot register net device, aborting.\n");
+		goto err_out_iounmap;
+	}
+	platform_set_drvdata(pdev, ndev);
+	ret = cdac_mii_init(ndev);
+	if (ret)
+		goto err_out_unregister_netdev;
+
+	netdev_info(ndev, "CDAC mac at 0x%08llx irq %d\n", gmac_resource.start, ndev->irq);
+	phydev = ndev->phydev;
+
+	device_init_wakeup(&pdev->dev, 1);
+	device_set_wakeup_enable(&pdev->dev, 1);
+	return 0;
+
+	err_out_unregister_netdev:
+		 unregister_netdev(ndev);
+	err_out_iounmap:
+		 iounmap((volatile void *)(priv->net_base));
+	err_irq_unmap:
+		irq_dispose_mapping(irq);
+	err_out_free_dev:
+		free_netdev(ndev);
+	err_exit:
+	pr_err("%s: not found (%d).\n", MODNAME, ret);
+
+	return ret;
+}
+
+static int cdac_eth_drv_remove(struct platform_device *pdev) {
+	struct net_device *ndev = platform_get_drvdata(pdev);
+	struct dev_priv *priv = netdev_priv(ndev);
+
+	unregister_netdev(ndev);
+	iounmap((volatile void *)(priv->net_base));
+	mdiobus_unregister(priv->mii_bus);
+	mdiobus_free(priv->mii_bus);
+	free_netdev(ndev);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int cdac_eth_drv_suspend(struct platform_device *pdev,
+		pm_message_t state)
+{
+	struct net_device *ndev = platform_get_drvdata(pdev);
+	struct netdata_local *pldat = netdev_priv(ndev);
+
+	if (device_may_wakeup(&pdev->dev))
+	enable_irq_wake(ndev->irq);
+
+	if (ndev) {
+		if (netif_running(ndev)) {
+			netif_device_detach(ndev);
+			__cdac_eth_shutdown(pldat);
+			clk_disable_unprepare(pldat->clk);
+
+			/*
+			 * Reset again now clock is disable to be sure
+			 * EMC_MDC is down
+			 */
+			__cdac_eth_reset(pldat);
+		}
+	}
+
+	return 0;
+}
+
+static int cdac_eth_drv_resume(struct platform_device *pdev)
+{
+	struct net_device *ndev = platform_get_drvdata(pdev);
+	struct netdata_local *pldat;
+
+	if (device_may_wakeup(&pdev->dev))
+	disable_irq_wake(ndev->irq);
+
+	if (ndev) {
+		if (netif_running(ndev)) {
+			pldat = netdev_priv(ndev);
+
+			/* Enable interface clock */
+			clk_enable(pldat->clk);
+
+			/* Reset and initialize */
+			__cdac_eth_reset(pldat);
+			__cdac_eth_init(pldat);
+
+			netif_device_attach(ndev);
+		}
+	}
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_OF
+static const struct of_device_id cdac_gmac_match[] = {
+	{
+		.type		= "network",
+		.compatible 	= "cdac,cdac_gmac"
+	},
+	{}
+};
+
+static const struct of_device_id cdac_dma_match[] = {
+	{
+		.type		= "dma",
+		.compatible 	= "cdac,cdac_dma"
+	},
+	{}
+};
+
+
+MODULE_DEVICE_TABLE(of, cdac_gmac_match);
+MODULE_DEVICE_TABLE(of, cdac_dma_match);
+#endif
+
+static struct platform_driver cdac_gmac_driver = {
+	.probe = cdac_eth_drv_probe,
+	.remove = cdac_eth_drv_remove,
+	.driver = {
+		.name = "cdac_gmac",
+                .owner = THIS_MODULE,
+		.of_match_table = of_match_ptr(cdac_gmac_match),
+	},
+#ifdef CONFIG_PM
+	.suspend = cdac_eth_drv_suspend,
+	.resume = cdac_eth_drv_resume,
+#endif
+
+};
+
+static struct platform_driver cdac_dma_driver = {
+	.probe = cdac_dma_drv_probe,
+	.remove = cdac_dma_drv_remove,
+	.driver = {
+		.name = "cdac_dma",
+                .owner = THIS_MODULE,
+		.of_match_table = of_match_ptr(cdac_dma_match),
+	},
+#ifdef CONFIG_PM
+	.suspend = cdac_eth_drv_suspend,
+	.resume = cdac_eth_drv_resume,
+#endif
+
+};
+
+static int __init cdac_gmac_init(void)
+{
+	int rc, dc;
+
+	printk(KERN_INFO DRV_DESC ", version " DRV_VERSION "\n");
+
+  dc = platform_driver_register(&cdac_dma_driver);
+	rc = platform_driver_register(&cdac_gmac_driver);
+	if (rc)
+		goto err;
+
+	return 0;
+
+ err:
+	return rc;
+}
+
+static void __exit cdac_gmac_exit(void)
+{
+	platform_driver_unregister(&cdac_gmac_driver);
+
+}
+
+module_init(cdac_gmac_init);
+module_exit(cdac_gmac_exit);
+
+MODULE_AUTHOR("Sreenadh S <sreenadh@cdac.in>");
+MODULE_DESCRIPTION("CDAC Ethernet Driver");
+MODULE_LICENSE("GPL");
diff -Naur linux-5.4.1/drivers/net/ethernet/cdac/cdac_gmac.h linux-5.4.1_modified/drivers/net/ethernet/cdac/cdac_gmac.h
--- linux-5.4.1/drivers/net/ethernet/cdac/cdac_gmac.h	1970-01-01 05:30:00.000000000 +0530
+++ linux-5.4.1_modified/drivers/net/ethernet/cdac/cdac_gmac.h	2025-08-08 10:40:35.452040885 +0530
@@ -0,0 +1,164 @@
+/*
+ * linux/drivers/net/ethernet/amd/am79c961a.h
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef _LINUX_CDAC_ETH_H
+#define _LINUX_CDAC_ETH_H
+
+/* use 0 for production, 1 for verification, >2 for debug. debug flags: */
+#define DEBUG_TX	 2
+#define DEBUG_RX	 4
+#define DEBUG_INT	 8
+#define DEBUG_IC	16
+#ifndef NET_DEBUG
+#define NET_DEBUG 	0
+#endif
+
+#define NET_UID		0
+#define NET_RDP		0x10
+#define NET_RAP		0x12
+#define NET_RESET	0x14
+#define NET_IDP		0x16
+
+/*
+ * RAP registers
+ */
+#define CSR0		0
+#define CSR0_INIT	0x0001
+#define CSR0_STRT	0x0002
+#define CSR0_STOP	0x0004
+#define CSR0_TDMD	0x0008
+#define CSR0_TXON	0x0010
+#define CSR0_RXON	0x0020
+#define CSR0_IENA	0x0040
+#define CSR0_INTR	0x0080
+#define CSR0_IDON	0x0100
+#define CSR0_TINT	0x0200
+#define CSR0_RINT	0x0400
+#define CSR0_MERR	0x0800
+#define CSR0_MISS	0x1000
+#define CSR0_CERR	0x2000
+#define CSR0_BABL	0x4000
+#define CSR0_ERR	0x8000
+
+#define CSR3		3
+#define CSR3_EMBA	0x0008
+#define CSR3_DXMT2PD	0x0010
+#define CSR3_LAPPEN	0x0020
+#define CSR3_DXSUFLO	0x0040
+#define CSR3_IDONM	0x0100
+#define CSR3_TINTM	0x0200
+#define CSR3_RINTM	0x0400
+#define CSR3_MERRM	0x0800
+#define CSR3_MISSM	0x1000
+#define CSR3_BABLM	0x4000
+#define CSR3_MASKALL	0x5F00
+
+#define CSR4		4
+#define CSR4_JABM	0x0001
+#define CSR4_JAB	0x0002
+#define CSR4_TXSTRTM	0x0004
+#define CSR4_TXSTRT	0x0008
+#define CSR4_RCVCCOM	0x0010
+#define CSR4_RCVCCO	0x0020
+#define CSR4_MFCOM	0x0100
+#define CSR4_MFCO	0x0200
+#define CSR4_ASTRP_RCV	0x0400
+#define CSR4_APAD_XMIT	0x0800
+
+#define CTRL1		5
+#define CTRL1_SPND	0x0001
+
+#define LADRL		8
+#define LADRM1		9
+#define LADRM2		10
+#define LADRH		11
+#define PADRL		12
+#define PADRM		13
+#define PADRH		14
+
+#define MODE		15
+#define MODE_DISRX	0x0001
+#define MODE_DISTX	0x0002
+#define MODE_LOOP	0x0004
+#define MODE_DTCRC	0x0008
+#define MODE_COLL	0x0010
+#define MODE_DRETRY	0x0020
+#define MODE_INTLOOP	0x0040
+#define MODE_PORT_AUI	0x0000
+#define MODE_PORT_10BT	0x0080
+#define MODE_DRXPA	0x2000
+#define MODE_DRXBA	0x4000
+#define MODE_PROMISC	0x8000
+
+#define BASERXL		24
+#define BASERXH		25
+#define BASETXL		30
+#define BASETXH		31
+
+#define POLLINT		47
+
+#define SIZERXR		76
+#define SIZETXR		78
+
+#define CSR_MFC		112
+
+#define RMD_ENP		0x0100
+#define RMD_STP		0x0200
+#define RMD_CRC		0x0800
+#define RMD_FRAM	0x2000
+#define RMD_ERR		0x4000
+#define RMD_OWN		0x8000
+
+#define TMD_ENP		0x0100
+#define TMD_STP		0x0200
+#define TMD_MORE	0x1000
+#define TMD_ERR		0x4000
+#define TMD_OWN		0x8000
+
+#define TST_RTRY	0x0400
+#define TST_LCAR	0x0800
+#define TST_LCOL	0x1000
+#define TST_UFLO	0x4000
+#define TST_BUFF	0x8000
+
+#define ISALED0		0x0004
+#define ISALED0_LNKST	0x8000
+
+#define TX_BUFFERS 15
+#define RX_BUFFERS 25
+
+extern void __iomem *			gDma_base;
+
+
+struct dev_priv {
+    unsigned long	rxbuffer[RX_BUFFERS];
+    unsigned long	txbuffer[TX_BUFFERS];
+    unsigned char	txhead;
+    unsigned char	txtail;
+    unsigned char	rxhead;
+    unsigned char	rxtail;
+    unsigned long	rxhdr;
+    unsigned long	txhdr;
+    spinlock_t		chip_lock;
+    struct timer_list		timer;
+   // struct clk *clk;
+    struct net_device   	*ndev;
+	struct platform_device	*pdev;
+    struct mii_bus 			*mii_bus;
+	void __iomem *			net_base;
+	int tx_len[100];
+	int tx_intr_index;
+	int tx_index;
+	struct napi_struct	napi;
+	u32			msg_enable;
+	int			link;
+	int			speed;
+	int			duplex;
+};
+
+#endif
diff -Naur linux-5.4.1/drivers/net/ethernet/cdac/ergmac.c linux-5.4.1_modified/drivers/net/ethernet/cdac/ergmac.c
--- linux-5.4.1/drivers/net/ethernet/cdac/ergmac.c	1970-01-01 05:30:00.000000000 +0530
+++ linux-5.4.1_modified/drivers/net/ethernet/cdac/ergmac.c	2025-08-08 10:40:35.452145982 +0530
@@ -0,0 +1,260 @@
+#include "ergmac.h"
+
+#include <asm/csr.h>
+
+#include <linux/delay.h>
+
+#include <linux/slab.h>
+
+
+
+
+
+void Init_PHY_default_SAF_GMAC(void __iomem * gmac_base_vaddr) {
+
+
+
+	UI ercnofig_val;
+
+	UI intr_status;
+
+
+	printk("Initializing ethernet.... \n");
+
+
+
+	intr_status = readl(gmac_base_vaddr + ERGMAC_INTR_STATUS_REG); //clear if any pending intr is there
+
+	__asm__ __volatile__ ("fence"); //To complete the write operation in O-O-O processor
+
+	//cdac_writeword(gmac_base_vaddr, ERGMAC_CONFIG_REG, (0x54006780 | UNICAST | BROADCAST));
+
+
+
+	//ercnofig_val = readl(gmac_base_vaddr + ERGMAC_CONFIG_REG);
+
+	writel((0x54006780 | UNICAST | BROADCAST) ,(gmac_base_vaddr + ERGMAC_CONFIG_REG));
+
+	mdelay(800);
+
+	//writel((ercnofig_val | BROADCAST) ,(gmac_base_vaddr + ERGMAC_CONFIG_REG) );
+
+	__asm__ __volatile__ ("fence"); //To complete the write operation in O-O-O processor
+
+
+
+	//cdac_writeword(gmac_base_vaddr, ERGMAC_INTR_MASK_REG, 0xffffffff);
+
+	writel(0xffffffff,(gmac_base_vaddr + ERGMAC_INTR_MASK_REG) );
+
+	__asm__ __volatile__ ("fence"); //To complete the write operation in O-O-O processor
+
+
+
+//	cdac_writeword(gmac_base_vaddr, ERGMAC_INTR_MASK_REG, ~((1 << 24)|(1 << 30)));// bit: 24==> Rx Interrupt,bit: 30==> Tx Interrupt
+
+	writel(~((1 << 24)|(1 << 30)) ,(gmac_base_vaddr + ERGMAC_INTR_MASK_REG) );
+
+	__asm__ __volatile__ ("fence"); //To complete the write operation in O-O-O processor
+
+
+
+	intr_status = readl(gmac_base_vaddr + ERGMAC_INTR_STATUS_REG); //clear if any pending intr is there
+
+	__asm__ __volatile__ ("fence"); //To complete the write operation in O-O-O processor
+
+}
+
+
+
+UI clear_supervisor_ext_intrpt(void __iomem * gmac_base_vaddr) {
+
+
+
+	UI intr_status;
+
+
+
+	//intr_status = readl(gmac_base_vaddr+ERGMAC_INTR_STATUS_REG);
+
+
+
+	//printk("[C-DAC DEBUG] before sbi_clear_seip_set_meie@ergmac\n");
+
+//	sbi_clear_seip_set_meie(); //clear seip, and set meie after supervisor ext. intr.
+
+	//printk("[C-DAC DEBUG] after sbi_clear_seip_set_meie@ergmac\n");
+
+
+
+//	sbi_clear_suip_set_muie();
+
+
+
+	return intr_status;
+
+}
+
+
+
+void send_ethernet(volatile unsigned char *buf, void __iomem * gmac_base_vaddr, int length) {
+
+	int i, tLen;
+
+	unsigned int data;
+
+
+
+	unsigned int *tx_memory;
+
+
+
+	tx_memory=(unsigned int *)kmalloc(8000, GFP_KERNEL);
+
+
+
+	memcpy(tx_memory, buf, length);
+
+
+
+	if ((length % 4) != 0)
+
+		tLen = (length / 4) + 1;
+
+	else
+
+		tLen = (length / 4);
+
+
+
+	for (i = 0; i < tLen; i++) {
+
+		/*while (1) {
+
+			reg_val = readl(gmac_base_vaddr, ERGMAC_TX_DATA_FIFO_STATUS_REG);
+
+			if ((reg_val & (1 << 15)) == 0)
+
+				break; //Not full
+
+		}*/
+
+		data =tx_memory[i];//bigToLittle();
+
+		//cdac_writeword(gmac_base_vaddr, ERGMAC_TX_DATA_FIFO, data);
+
+		writel(data ,(gmac_base_vaddr + ERGMAC_TX_DATA_FIFO) );
+
+
+
+	}
+
+	__asm__ __volatile__ ("fence"); //To complete the write operation in O-O-O processor
+
+	kfree(tx_memory);
+
+	/*while (1) {
+
+			reg_val = readl(gmac_base_vaddr, ERGMAC_TX_LENGTH_FIFO_STATUS_REG);
+
+			if ((reg_val & (1 << 13)) == 0)
+
+				break; //Not full
+
+		}*/
+
+	//cdac_writeword(gmac_base_vaddr, ERGMAC_TX_LENGTH_FIFO, length);
+
+	writel(length ,(gmac_base_vaddr + ERGMAC_TX_LENGTH_FIFO) );
+
+
+
+	__asm__ __volatile__ ("fence"); //To complete the write operation in O-O-O processor
+
+}
+
+
+
+
+
+int check_gmac_rx(void __iomem * gmac_base_vaddr) {
+
+	UI reg_val;
+
+	unsigned int length;
+
+
+
+	reg_val = readl(gmac_base_vaddr + ERGMAC_RX_LENGTH_FIFO_STATUS_REG);
+
+	if((reg_val & (1 << 11)) == 0)
+
+	{//length fifo not empty
+
+		length = readl(gmac_base_vaddr + ERGMAC_RX_LENGTH_FIFO);
+
+		return length; //Length FIFO not empty
+
+	}
+
+	else
+
+		return 0; //Length FIFO empty
+
+}
+
+
+
+int receive_ethernet(UC *buf, void __iomem * gmac_base_vaddr,unsigned int length) {
+
+	UI i = 0, tLen = 0, data;
+
+	unsigned int *rx_memory;
+
+
+
+	rx_memory=(unsigned int *)kmalloc(8000, GFP_KERNEL);
+
+
+
+	if ((length % 4) != 0)
+
+		tLen = (length / 4) + 1;
+
+	else
+
+		tLen = (length / 4);
+
+
+
+	for (i = 0; i < tLen; i++) {
+
+		data = readl(gmac_base_vaddr + ERGMAC_RX_DATA_FIFO);
+
+		rx_memory[i] = data ;//bigToLittle(data);
+
+	}
+
+
+
+	memcpy(buf, rx_memory, length);
+
+
+
+	kfree(rx_memory);
+
+
+
+	return length;
+
+}
+
+
+
+unsigned int bigToLittle(unsigned int x) {
+
+	return (((x >> 24) & 0x000000ff) | ((x >> 8) & 0x0000ff00)
+
+			| ((x << 8) & 0x00ff0000) | ((x << 24) & 0xff000000));
+
+}
diff -Naur linux-5.4.1/drivers/net/ethernet/cdac/ergmac.h linux-5.4.1_modified/drivers/net/ethernet/cdac/ergmac.h
--- linux-5.4.1/drivers/net/ethernet/cdac/ergmac.h	1970-01-01 05:30:00.000000000 +0530
+++ linux-5.4.1_modified/drivers/net/ethernet/cdac/ergmac.h	2025-08-08 10:40:35.452251940 +0530
@@ -0,0 +1,171 @@
+#ifndef MAC_H
+
+#define MAC_H
+
+
+
+#include <linux/io.h>
+
+#include <asm/sbi.h>
+
+
+
+typedef unsigned long UL;
+
+
+
+typedef unsigned int UI;
+
+typedef unsigned char UC;
+
+typedef unsigned short US;
+
+
+
+
+
+struct ether_header {
+
+	UC ether_dhost[6]; /* destination eth addr	*/
+
+	UC ether_shost[6]; /* source ether addr	*/
+
+	US ether_type; /* packet type ID field	*/
+
+	US id;
+
+	UI packet_no;
+
+}__attribute__ ((__packed__));
+
+
+
+#define GMAC_BASE_ADDR		0x2000000
+
+
+
+#define	MDIO_WRITE_COMMAND	0x000D0001
+
+#define MDIO_READ_COMMAND	0x00150001
+
+
+
+#define cdac_writeword(dev_base,off,val) sbi_write_32_periph((GMAC_BASE_ADDR + off), val);//__raw_writel(val, dev_base + off); __asm__ __volatile__ ("fence w,o" : : : "memory")
+
+#define cdac_readword(dev_base,off)      sbi_read_32_periph((GMAC_BASE_ADDR + off));//__raw_readl(dev_base + off); __asm__ __volatile__ ("fence i,r" : : : "memory")
+
+
+
+#define		TX_ENABLE		1<<30
+
+#define		RX_ENABLE		1<<28
+
+#define		PHY_ENABLE		1<<26
+
+#define		SA_FILTER		1<<19
+
+#define		PROMISCUS		1<<18
+
+#define		MULTICAST		1<<17
+
+#define		BROADCAST		1<<16
+
+#define		UNICAST			1<<15
+
+#define		JUMBOFRAME		1<<22
+
+
+
+
+
+#define		MII_READ_DATA	0x1F
+
+#define		MII_WRITE_DATA	0x1D
+
+
+
+//GMAC Registers
+
+#define ERGMAC_BASE_ADDRESS    0x02000000
+
+
+
+#define ERGMAC_TX_DATA_FIFO                0xFC
+
+#define ERGMAC_TX_LENGTH_FIFO              0xF8
+
+#define ERGMAC_TX_STATUS_FIFO              0xF4
+
+#define ERGMAC_RX_DATA_FIFO                0xF0
+
+
+
+#define ERGMAC_RX_LENGTH_FIFO              0xEC
+
+#define ERGMAC_RX_STATUS_FIFO              0xE8
+
+#define ERGMAC_CONFIG_REG                  0xE4
+
+#define ERGMAC_ADDR_HIGH_REG               0xE0
+
+
+
+#define ERGMAC_ADDR_LOW_REG                0xDC
+
+#define ERGMAC_FLOW_CTRL_CONFG_REG         0xD8
+
+
+
+#define ERGMAC_SRC_FLT_ADDRH_REG           0xC8
+
+#define ERGMAC_SRC_FLT_ADDRL_REG           0xC4
+
+#define ERGMAC_MDIO_OPERATION_REG          0xC0
+
+
+
+#define ERGMAC_MDIO_WRITE_DATA_REG         0xBC
+
+#define ERGMAC_MDIO_READ_DATA_REG	   0xB8
+
+#define ERGMAC_TX_DATA_FIFO_STATUS_REG     0xB4
+
+#define ERGMAC_TX_LENGTH_FIFO_STATUS_REG   0xB0
+
+
+
+#define ERGMAC_TX_STATUS_FIFO_STATUS_REG   0xAC
+
+#define ERGMAC_RX_DATA_FIFO_STATUS_REG     0xA8
+
+#define ERGMAC_RX_LENGTH_FIFO_STATUS_REG   0xA4
+
+#define ERGMAC_RX_STATUS_FIFO_STATUS_REG   0xA0
+
+
+
+#define ERGMAC_INTR_MASK_REG               0x08
+
+#define ERGMAC_INTR_STATUS_REG             0x04
+
+
+
+void Init_PHY_default_SAF_GMAC(void __iomem * gmac_base_vaddr);
+
+void send_ethernet(volatile unsigned char *buf, void __iomem * gmac_base_vaddr, int length);
+
+int receive_ethernet(UC *buf, void __iomem * gmac_base_vaddr,unsigned int length);
+
+unsigned int bigToLittle(unsigned int x);
+
+unsigned int cdac_readword_fn(void __iomem * dev_base, unsigned long off);
+
+int check_gmac_rx(void __iomem * gmac_base_vaddr);
+
+UI clear_supervisor_ext_intrpt(void __iomem * dev_base);
+
+
+
+
+
+#endif
diff -Naur linux-5.4.1/drivers/net/ethernet/cdac/ermac/cdac_mac.c linux-5.4.1_modified/drivers/net/ethernet/cdac/ermac/cdac_mac.c
--- linux-5.4.1/drivers/net/ethernet/cdac/ermac/cdac_mac.c	1970-01-01 05:30:00.000000000 +0530
+++ linux-5.4.1_modified/drivers/net/ethernet/cdac/ermac/cdac_mac.c	2025-08-08 10:40:35.452515094 +0530
@@ -0,0 +1,986 @@
+/*
+ * drivers/net/ethernet/cdac/ermac/cdac_gmac.c
+ *
+ * Authors: Sreenadh S <sreenadh@cdac.in>, Anoop Varghese <vanoop@cdac.in>
+ *
+ * Copyright (C) 2020 C-DAC Thiruvananthapuram.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/errno.h>
+#include <linux/ioport.h>
+#include <linux/crc32.h>
+#include <linux/platform_device.h>
+#include <linux/spinlock.h>
+#include <linux/ethtool.h>
+#include <linux/stddef.h>
+#include <linux/mii.h>
+#include <linux/clk.h>
+#include <linux/workqueue.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/phy.h>
+#include <linux/dma-mapping.h>
+#include <linux/of.h>
+#include <linux/of_net.h>
+#include <linux/of_irq.h>
+#include <linux/of_platform.h>
+#include <linux/of_address.h>
+#include <linux/types.h>
+#include <linux/irqdomain.h>
+#include <linux/spinlock.h>
+#include <linux/io.h>
+
+#include "cdac_mac.h"
+#include "ermac.h"
+#include <asm/csr.h>
+
+#define MODNAME 		"cdac_mac"
+#define DRV_NAME        "cdac_mac"
+#define DRV_VERSION 	"1.00"
+#define DRV_DESC        "CDAC ERMAC driver"
+
+#define DEBUG
+
+#define ENET_MAXF_SIZE 		1536
+#define ENET_RX_DESC 		48
+#define ENET_TX_DESC 		16
+
+#define NAPI_WEIGHT 		0
+
+#define NO_IRQ	((unsigned int)(-1))
+
+void __iomem *			gDma_base;
+
+/*
+ * powerdown register definitions
+ */
+#define CDAC_POWERDOWN_MACAHB			(1 << 31)
+
+/*
+ * MAC support functions
+ */
+static void __cdac_set_mac(struct net_device *ndev, u8 *mac) {
+	unsigned int mac_addr;
+	struct dev_priv *priv = netdev_priv(ndev);
+
+	mac_addr = mac[0] << 8 | mac[1] ;
+	writel(mac_addr,(priv->net_base+ERMAC_ADDR_HIGH_REG));
+	mac_addr = mac[2] << 24 | mac[3] << 16 |mac[4] << 8 | mac[5];
+	writel(mac_addr,(priv->net_base+ERMAC_ADDR_LOW_REG));
+	netdev_dbg(ndev, "Ethernet MAC address %pM\n", mac);
+}
+
+static void __cdac_get_mac(struct net_device *ndev, u8 *mac) {
+	unsigned int mac_addr;
+	struct dev_priv *priv = netdev_priv(ndev);
+
+	mac_addr =  readl((priv->net_base+ERMAC_ADDR_HIGH_REG));
+	mac[0] = (mac_addr >> 8) & 0xff;
+	mac[1] = mac_addr & 0xff;
+	mac_addr = readl((priv->net_base+ERMAC_ADDR_LOW_REG));
+	mac[2] = mac_addr >> 24;
+	mac[3] = (mac_addr >> 16) & 0xff;
+	mac[4] = (mac_addr >> 8) & 0xff;
+	mac[5] = mac_addr & 0xff;
+}
+
+static void __cdac_params_setup(struct net_device *ndev) {
+	//printk("*********__cdac_params_setup \n");
+}
+
+static void __cdac_eth_reset(struct net_device *ndev) {
+	//printk("*********__cdac_eth_reset \n");
+
+}
+
+static int __cdac_mii_mngt_reset(struct dev_priv *priv) {
+	//printk("*********__cdac_mii_mngt_reset \n");
+
+	return 0;
+}
+
+static void cdac_eth_enable_int(void __iomem *regbase) {
+	//printk("*********cdac_eth_enable_int \n");
+
+}
+
+//static void cdac_eth_disable_int(void __iomem *regbase) {
+	//printk("*********cdac_eth_disable_int \n");
+
+//}
+
+static void __cdac_eth_init(struct net_device *ndev) {
+	struct dev_priv *priv = netdev_priv(ndev);
+	__cdac_params_setup(ndev);
+	smp_wmb();
+	Init_PHY_default_SAF_GMAC(priv->net_base);
+	cdac_eth_enable_int((void __iomem *)(priv->net_base));
+}
+
+static void __cdac_eth_shutdown(struct net_device *ndev) {
+	/* Reset ethernet and power down PHY */
+	__cdac_eth_reset(ndev);
+}
+
+/*
+ * MAC<--->PHY support functions
+ */
+static int cdac_mii_read(struct mii_bus *bus, int phy_id, int phyreg) {
+	int lps = 0;
+	unsigned int mdio_op_reg;
+	struct dev_priv *priv = bus->priv;
+	writel(MII_READ_DATA_CMD(phy_id, phyreg),(priv->net_base + ERMAC_MII_MNGMNT_CNTRL_REG));
+	//printk("[C-DAC DEBUG] @cdac_mii_read   : %x.\n", MII_READ_DATA_CMD(phy_id, phyreg));
+	while (1) {
+		mdio_op_reg = readl((priv->net_base + ERMAC_MII_MNGMNT_CNTRL_REG));
+		//printk("%lx\n",mdio_op_reg);
+		if ((mdio_op_reg & PHY_BUSY_BIT) == 0)
+			break; //read OK
+	}
+	lps = readl((priv->net_base+ERMAC_MII_READ_DATA_REG)); //phy reg data
+	//printk("[C-DAC DEBUG] @cdac_mii_read exit, lps : %x.\n",lps);
+	lps = lps >> 8;
+	return lps;
+}
+
+
+/*static int cdac_phyreg_read(int phy_id, int phyreg) {
+
+	int lps = 0;
+	unsigned int mdio_op_reg;
+
+	cdac_writeword(0, ERMAC_MII_MNGMNT_CNTRL_REG, (MDIO_READ_COMMAND | (phy_id << 26) |(phyreg << 21)));
+	while (1) {
+
+		mdio_op_reg = readl(0, ERMAC_MII_MNGMNT_CNTRL_REG);
+		if (mdio_op_reg & (1 << 31))
+			break; //read OK
+	}
+
+	lps = readl(0, ERMAC_MII_READ_DATA_REG); //phy reg data
+
+	return lps;
+}*/
+
+
+static int cdac_mii_write(struct mii_bus *bus, int phy_id, int phyreg,	u16 phydata) {
+/*	unsigned int mdio_op_reg;
+
+	cdac_writeword(bus->priv->net_base, ERMAC_MDIO_WRITE_DATA_REG, phydata); //data to write
+	cdac_writeword(bus->priv->net_base, ERMAC_MII_MNGMNT_CNTRL_REG, (MDIO_WRITE_COMMAND | (phy_id << 26) |( phyreg << 21))); //command for write
+	__asm__ __volatile__ ("fence"); //To complete the read fifo operation in O-O-O processor
+	 while (1){
+		 mdio_op_reg = readl(priv->net_base,ERMAC_MII_MNGMNT_CNTRL_REG);
+		 if(mdio_op_reg & (1 << 31))
+			break; //PHY reg write OK
+	 }*/
+	return 0;
+}
+
+static int cdac_mii_reset(struct mii_bus *bus) {
+	//printk("*********cdac_mii_reset \n");
+
+	return __cdac_mii_mngt_reset((struct dev_priv *) bus->priv);
+}
+
+static void cdac_handle_link_change(struct net_device *ndev) {
+	struct phy_device *phydev = ndev->phydev;
+	unsigned long flags;
+	struct dev_priv *priv = netdev_priv(ndev);
+
+	bool status_change = false;
+
+	spin_lock_irqsave(&priv->chip_lock, flags);
+
+	if (phydev->link) {
+		if ((priv->speed != phydev->speed)
+				|| (priv->duplex != phydev->duplex)) {
+			priv->speed = phydev->speed;
+			priv->duplex = phydev->duplex;
+			status_change = true;
+		}
+	}
+
+	if (phydev->link != priv->link) {
+		if (!phydev->link) {
+			priv->speed = 0;
+			priv->duplex = -1;
+		}
+		priv->link = phydev->link;
+
+		status_change = true;
+	}
+
+	spin_unlock_irqrestore(&priv->chip_lock, flags);
+
+	if (status_change) {
+		if (phydev->link) {
+			netdev_info(ndev, "link up (%d/%s)\n",
+			       phydev->speed,
+			       DUPLEX_FULL == phydev->duplex ? "Full" : "Half");
+			//netif_carrier_on(ndev);
+		}
+		else {
+			netdev_info(ndev, "link down\n");
+			//netif_carrier_off(ndev);
+		}
+		__cdac_params_setup(ndev);
+	}
+}
+
+static int cdac_mii_probe(struct net_device *ndev) {
+	struct dev_priv *priv = netdev_priv(ndev);
+	struct phy_device *phydev = phy_find_first(priv->mii_bus);
+
+	if (!phydev) {
+		netdev_err(ndev, "no PHY found\n");
+		return -ENODEV;
+	}
+
+	//printk("*********cdac_mii_probe \n");
+
+	/* Attach to the PHY */
+	//if (cdac_phy_interface_mode(&priv->pdev->dev) == PHY_INTERFACE_MODE_GMII)
+	//	netdev_info(ndev, "using GMII interface\n");
+	//else
+
+	netdev_info(ndev, "using MII interface\n");
+	phydev = phy_connect(ndev, phydev_name(phydev), &cdac_handle_link_change, PHY_INTERFACE_MODE_MII);
+
+	if (IS_ERR(phydev)) {
+		netdev_err(ndev, "Could not attach to PHY\n");
+		return PTR_ERR(phydev);
+	}
+
+	/* mask with MAC supported features */
+	//phydev->supported &= PHY_BASIC_FEATURES;
+	linkmode_and(phydev->supported, phydev->supported, PHY_BASIC_FEATURES);
+
+	//phydev->advertising = phydev->supported;
+	linkmode_copy(phydev->advertising, phydev->supported);
+
+	phy_attached_info(phydev);
+
+	return 0;
+}
+
+static int cdac_mii_init(struct net_device *ndev) {
+	int err;
+	struct dev_priv *priv = netdev_priv(ndev);
+	int i;
+	const char *mode;
+	err = -ENXIO;
+	priv->mii_bus = mdiobus_alloc();
+	if (!priv->mii_bus) {
+		err = -ENOMEM;
+		goto err_out;
+	}
+
+	priv->mii_bus->name = "cdac_mii_bus";
+	priv->mii_bus->read = &cdac_mii_read;
+	priv->mii_bus->write = &cdac_mii_write;
+	priv->mii_bus->reset = &cdac_mii_reset;
+
+	snprintf(priv->mii_bus->id, MII_BUS_ID_SIZE, "%s-%x", priv->pdev->name,
+			priv->pdev->id);
+	priv->mii_bus->priv = priv;
+	priv->mii_bus->parent = &priv->pdev->dev;
+
+
+	for (i = 0; i < PHY_MAX_ADDR; i++)
+		priv->mii_bus->irq[i] = PHY_POLL;
+
+
+	mode = of_get_property(priv->pdev->dev.of_node, "platform", NULL);
+	//if (mode && !strcmp(mode, "htg_virtex7"))
+	//	priv->mii_bus->phy_mask = ~(1 << 3);// used phy
+
+
+	platform_set_drvdata(priv->pdev, priv->mii_bus);
+
+	if (mdiobus_register(priv->mii_bus))
+		goto err_out_unregister_bus;
+	if (cdac_mii_probe(priv->ndev) != 0)
+		goto err_out_unregister_bus;
+
+	return 0;
+
+	err_out_unregister_bus: mdiobus_unregister(priv->mii_bus);
+	mdiobus_free(priv->mii_bus);
+	err_out: return err;
+}
+
+static void __cdac_handle_xmit(struct net_device *ndev) {
+	//struct dev_priv *priv = netdev_priv(ndev);
+	//int skblen;
+
+	/*skblen=priv->tx_len[priv->tx_intr_index];
+	priv->tx_intr_index++;
+	if(priv->tx_intr_index==100)
+		priv->tx_intr_index=0;
+
+	ndev->stats.tx_bytes += skblen;*/
+	//printk("*********__cdac_handle_xmit\n");
+	ndev->stats.tx_packets++;
+}
+
+
+static int __cdac_handle_recv(struct net_device *ndev, int budget) {
+	struct dev_priv *priv = netdev_priv(ndev);
+	int rx_done = 0;
+	unsigned int len = 0;
+	struct sk_buff *skb;
+	//printk("*********__cdac_handle_recv\n");
+	while(1) {
+
+		if ((len = check_gmac_rx(priv->net_base)) == 0) {
+			return 0;
+		}
+
+		/* Packet is good */
+		skb = netdev_alloc_skb(ndev, (len+2));
+		if (!skb) {
+			ndev->stats.rx_dropped++;
+		} else {
+			skb_reserve(skb, 2);
+			receive_ethernet(skb->data, priv->net_base, len);
+			skb_put(skb, len);
+			skb->protocol = eth_type_trans(skb, ndev);
+			netif_rx(skb);
+			ndev->stats.rx_packets++;
+			ndev->stats.rx_bytes += len;
+		}
+	}
+
+	return rx_done;
+}
+
+/*static int cdac_eth_poll(struct napi_struct *napi, int budget) {
+	struct dev_priv
+	*priv = container_of(napi, struct dev_priv, napi);
+	struct net_device *ndev = priv->ndev;
+	int rx_done = 0;
+	//struct netdev_queue *txq = netdev_get_tx_queue(ndev, 0);
+
+	//printk("*********cdac_eth_poll %d \n", budget);
+
+	//__netif_tx_lock(txq, smp_processor_id());
+	//__cdac_handle_xmit(ndev);
+	//__netif_tx_unlock(txq);
+	rx_done = __cdac_handle_recv(ndev, budget);
+
+	//if (rx_done < budget) {
+	//napi_complete_done(napi, rx_done);
+	//cdac_eth_enable_int(priv->net_base);
+	//}
+
+	return rx_done;
+}*/
+
+int gIntrflag = 0;
+
+static irqreturn_t __cdac_eth_interrupt(int irq, void *dev_id) {
+	struct net_device *ndev = dev_id;
+	struct dev_priv *priv = netdev_priv(ndev);
+	UI intr_status;
+	//printk("*********__cdac_eth_interrupt\n");
+	spin_lock(&priv->chip_lock);
+
+	intr_status = readl(priv->net_base + ERMAC_INTR_STATUS_REG); //to clear gmac interrupt
+	//__asm__ volatile ("fence");
+
+	if (intr_status & TX_INTR_STAT) {
+		//printk("*********__cdac_handle_xmit [%x]\n", intr_status);
+		__cdac_handle_xmit(ndev);
+	}
+
+	if (intr_status & RX_INTR_STAT) {
+		//printk("*********__cdac_handle_recv [%x]\n", intr_status);
+		__cdac_handle_recv(ndev, 0);
+	}
+//	printk("[C-DAC DEBUG] before sbi_clear_seip_set_meie@cdac_gmac\n");
+	//sbi_clear_seip_set_meie(); //clear seip, and set meie after supervisor ext. intr.
+  //printk("[C-DAC DEBUG] after sbi_clear_seip_set_meie@cdac_gmac\n");
+	//sbi_clear_suip_set_muie();
+
+
+	spin_unlock(&priv->chip_lock);
+
+	//printk("********* __cdac_eth_interrupt finished\n");
+	return IRQ_HANDLED;
+}
+
+#ifdef CONFIG_NET_POLL_CONTROLLER
+/*static void cdac_gmac_poll(struct net_device *ndev)
+ {
+ unsigned long flags;
+ printk("*********cdac_gmac_poll?????????????? \n");
+ //local_irq_save(flags);
+ //__cdac_eth_interrupt(0, ndev);
+ //local_irq_restore(flags);
+ }*/
+#endif
+
+static int cdac_eth_close(struct net_device *ndev) {
+	unsigned long flags;
+	struct dev_priv *priv = netdev_priv(ndev);
+
+	if (netif_msg_ifdown(priv))
+		dev_dbg(&priv->pdev->dev, "shutting down %s\n", ndev->name);
+
+	//napi_disable(&priv->napi);
+
+	//del_timer_sync(&priv->timer);
+
+	netif_stop_queue(ndev);
+
+	if (ndev->phydev)
+		phy_stop(ndev->phydev);
+
+	spin_lock_irqsave(&priv->chip_lock, flags);
+	__cdac_eth_reset(ndev);
+
+	free_irq(ndev->irq, ndev);
+
+	//netif_carrier_off(ndev);
+	spin_unlock_irqrestore(&priv->chip_lock, flags);
+
+	return 0;
+}
+
+static int cdac_eth_hard_start_xmit(struct sk_buff *skb,
+		struct net_device *ndev) {
+	struct dev_priv *priv = netdev_priv(ndev);
+	unsigned long flags;
+	//unsigned int tx_status;
+
+	spin_lock_irqsave(&priv->chip_lock, flags);
+
+	/*tx_status = readl(priv->net_base, ERMAC_TX_DATA_FIFO_STATUS_REG);
+	tx_status = (tx_status & 0x7ff) * 4;	//bytes in tx fifo
+	tx_status = 8000 - tx_status; //free space  in tx fifo*/
+
+	/*if (skb->len > tx_status) {
+		// This function should never be called when there are no
+		// buffers
+		printk("*********netif_stop_queue : \n");
+		netif_stop_queue(ndev);
+		spin_unlock_irqrestore(&priv->chip_lock, flags);
+		WARN(1, "BUG! TX request when no free TX buffers!\n");
+		return NETDEV_TX_BUSY;
+	}*/
+
+	send_ethernet(skb->data, priv->net_base, skb->len);
+
+	ndev->stats.tx_bytes += skb->len;
+
+	/*priv->tx_len[priv->tx_index] = skb->len;
+	priv->tx_index++;
+	if(priv->tx_index == 100)
+		priv->tx_index = 0;
+
+	tx_status = readl(0, ERMAC_TX_DATA_FIFO_STATUS_REG);
+	tx_status = (tx_status & 0x7ff) * 4;		//bytes in tx fifo
+	tx_status = 8000 - tx_status; //free space  in tx fifo*/
+
+	/*if (skb->len > tx_status) {
+		/ //This function should never be called when there are no
+		// buffers
+		printk("*********netif_stop_queue : \n");
+		netif_stop_queue(ndev);
+	}*/
+
+	wmb();
+	/* drain writebuffer */
+	dev_kfree_skb_any(skb);
+
+	spin_unlock_irqrestore(&priv->chip_lock, flags);
+
+	return NETDEV_TX_OK;
+}
+
+static int cdac_set_mac_address(struct net_device *ndev, void *p) {
+	struct sockaddr *addr = p;
+	struct dev_priv *priv = netdev_priv(ndev);
+	unsigned long flags;
+
+	if (!is_valid_ether_addr(addr->sa_data))
+		return -EADDRNOTAVAIL;
+	memcpy(ndev->dev_addr, addr->sa_data, ETH_ALEN);
+
+	spin_lock_irqsave(&priv->chip_lock, flags);
+
+	/* Set station address */
+	__cdac_set_mac(ndev, ndev->dev_addr);
+
+	spin_unlock_irqrestore(&priv->chip_lock, flags);
+
+	return 0;
+}
+
+//static void cdac_eth_set_multicast_list(struct net_device *ndev) {
+
+	//printk("*********cdac_eth_set_multicast_list \n");
+
+/*#ifdef __USED_CDAC
+
+	struct dev_priv *priv = netdev_priv(ndev);
+	struct netdev_hw_addr_list *mcptr = &ndev->mc;
+	struct netdev_hw_addr *ha;
+	u32 tmp32, hash_val, hashlo, hashhi;
+	unsigned long flags;
+
+	spin_lock_irqsave(&priv->chip_lock, flags);
+
+	// Set station address //
+	__cdac_set_mac(pldat, ndev->dev_addr);
+
+	tmp32 = CDAC_RXFLTRW_ACCEPTUBROADCAST | CDAC_RXFLTRW_ACCEPTPERFECT;
+
+	if (ndev->flags & IFF_PROMISC)
+	tmp32 |= CDAC_RXFLTRW_ACCEPTUNICAST |
+	CDAC_RXFLTRW_ACCEPTUMULTICAST;
+	if (ndev->flags & IFF_ALLMULTI)
+	tmp32 |= CDAC_RXFLTRW_ACCEPTUMULTICAST;
+
+	if (netdev_hw_addr_list_count(mcptr))
+	tmp32 |= CDAC_RXFLTRW_ACCEPTUMULTICASTHASH;
+
+//	writel(tmp32, CDAC_ENET_RXFILTER_CTRL(pldat->net_base));
+
+	// Set initial hash table //
+	hashlo = 0x0;
+	hashhi = 0x0;
+
+	// 64 bits : multicast address in hash table //
+	netdev_hw_addr_list_for_each(ha, mcptr) {
+		hash_val = (ether_crc(6, ha->addr) >> 23) & 0x3F;
+
+		if (hash_val >= 32)
+		hashhi |= 1 << (hash_val - 32);
+		else
+		hashlo |= 1 << hash_val;
+	}
+
+	//writel(hashlo, CDAC_ENET_HASHFILTERL(pldat->net_base));
+	//writel(hashhi, CDAC_ENET_HASHFILTERH(pldat->net_base));
+
+	spin_unlock_irqrestore(&priv->chip_lock, flags);
+
+#endif //__USED_CDAC*/
+
+//}
+
+static int cdac_eth_ioctl(struct net_device *ndev, struct ifreq *req, int cmd) {
+	//printk("*********cdac_eth_ioctl \n");
+
+	struct phy_device *phydev = ndev->phydev;
+
+	if (!netif_running(ndev))
+		return -EINVAL;
+
+	if (!phydev)
+		return -ENODEV;
+
+	return phy_mii_ioctl(phydev, req, cmd);
+}
+
+static int cdac_eth_open(struct net_device *ndev) {
+
+	struct dev_priv *priv = netdev_priv(ndev);
+	int err;
+
+	if (netif_msg_ifup(priv))
+		dev_dbg(&priv->pdev->dev, "enabling %s\n", ndev->name);
+
+	/* Suspended PHY makes CDAC ethernet core block, so resume now */
+	//phy_resume(ndev->phydev);
+
+	/* Reset and initialize */
+	__cdac_eth_reset(ndev);
+
+	/* Setup error IRQ handler */
+	err = request_irq(ndev->irq, __cdac_eth_interrupt, 0, ndev->name, ndev);
+	if (err) {
+		printk(KERN_ERR "%s: failed to request IRQ %d\n",
+		       ndev->name, ndev->irq);
+		return err;
+	}
+
+	__cdac_eth_init(ndev);
+//	printk("eth open 1 ok \n");
+
+	priv->tx_index=0;
+	priv->tx_intr_index=0;
+
+	/* schedule a link state check */
+	phy_start(ndev->phydev);
+//	printk("eth open 2 ok \n");
+
+	//priv->timer.expires = jiffies;
+
+	//add_timer(&priv->timer);
+
+	netif_start_queue(ndev);
+
+//	printk("eth open 3 ok \n");
+
+	//napi_enable(&priv->napi);
+
+	return 0;
+}
+
+/*
+ * Ethtool ops
+ */
+static void cdac_eth_ethtool_getdrvinfo(struct net_device *ndev,
+		struct ethtool_drvinfo *info) {
+	strlcpy(info->driver, MODNAME, sizeof(info->driver));
+	strlcpy(info->version, DRV_VERSION, sizeof(info->version));
+	strlcpy(info->bus_info, dev_name(ndev->dev.parent), sizeof(info->bus_info));
+}
+
+static u32 cdac_eth_ethtool_getmsglevel(struct net_device *ndev) {
+	struct dev_priv *priv = netdev_priv(ndev);
+
+	return priv->msg_enable;
+}
+
+static void cdac_eth_ethtool_setmsglevel(struct net_device *ndev, u32 level) {
+	struct dev_priv *priv = netdev_priv(ndev);
+
+	priv->msg_enable = level;
+}
+
+static const struct ethtool_ops cdac_eth_ethtool_ops = { .get_drvinfo =
+		cdac_eth_ethtool_getdrvinfo, .get_msglevel =
+		cdac_eth_ethtool_getmsglevel, .set_msglevel =
+		cdac_eth_ethtool_setmsglevel, .get_link = ethtool_op_get_link,
+		.get_link_ksettings = phy_ethtool_get_link_ksettings,
+		.set_link_ksettings = phy_ethtool_set_link_ksettings, };
+
+static const struct net_device_ops cdac_netdev_ops = {
+		.ndo_open = cdac_eth_open, .ndo_stop = cdac_eth_close, .ndo_start_xmit =
+				cdac_eth_hard_start_xmit,
+//	.ndo_set_rx_mode	= cdac_eth_set_multicast_list,
+		.ndo_do_ioctl = cdac_eth_ioctl, .ndo_set_mac_address =
+				cdac_set_mac_address, .ndo_validate_addr = eth_validate_addr,
+/*#ifdef CONFIG_NET_POLL_CONTROLLER
+ .ndo_poll_controller	 = cdac_gmac_poll,
+ #endif*/
+};
+
+/*static void cdac_riscv_mask_irq(struct irq_data *d) {
+	//printk("cdac_riscv_mask_irq\n");
+
+}
+
+static void cdac_riscv_unmask_irq(struct irq_data *d) {
+	//printk("cdac_riscv_unmask_irq\n");
+
+}
+
+static struct irq_chip cdac_riscv_irq_chip = { .irq_ack = cdac_riscv_mask_irq,
+		.irq_mask = cdac_riscv_mask_irq, .irq_unmask = cdac_riscv_unmask_irq,
+		.name = "gmac_irq" };*/
+
+//static void cdac_eth_timer(struct timer_list *t) {
+
+	/*struct dev_priv	  *priv = from_timer(priv, t, timer);
+	struct net_device *dev = priv->ndev;
+
+	//struct net_device *dev = (struct net_device *) data;
+	//struct dev_priv *priv = netdev_priv(dev);
+	struct phy_device *phydev=dev->phydev;
+
+	unsigned int lnkstat, carrier;
+	unsigned long flags;
+
+	spin_lock_irqsave(&priv->chip_lock, flags);
+	lnkstat = cdac_phyreg_read(3, 1);
+	lnkstat = 1;//(lnkstat >> 2) & 1;// Linkup bit
+	printk("%d: link stat\n", lnkstat);
+	spin_unlock_irqrestore(&priv->chip_lock, flags);
+	//phydev->link;//1;
+	//read_ireg(dev->base_addr, ISALED0) & ISALED0_LNKST;
+
+	carrier = netif_carrier_ok(dev);
+
+	printk("%d:  carrier\n", carrier);
+
+	if (lnkstat && !carrier) {
+		netif_carrier_on(dev);
+		printk("%s: link up\n", dev->name);
+	} else if (!lnkstat && carrier) {
+		netif_carrier_off(dev);
+		printk("%s: link down\n", dev->name);
+	}
+
+	mod_timer(&priv->timer, jiffies + msecs_to_jiffies(2000));
+
+	//printk("cdac_eth_timer:time_out=%lx\n", (jiffies + msecs_to_jiffies(500)));*/
+//}
+
+/*struct riscv_irq_data {
+	struct irq_chip chip;
+	struct irq_domain *domain;
+	int hart;
+	char name[20];
+};
+DEFINE_PER_CPU(struct riscv_irq_data, extern riscv_irq_data);*/
+
+static int cdac_eth_drv_probe(struct platform_device *pdev) {
+	struct resource gmac_resource;
+	struct net_device *ndev;
+	struct dev_priv *priv;
+	struct phy_device *phydev;
+	struct device_node *np = pdev->dev.of_node;
+	int irq, ret = 0;
+	if (of_get_property(np, "disabled", NULL) || !of_device_is_available(np))
+		return -ENODEV;
+
+	/* Allocate net driver data structure */
+	ndev = alloc_etherdev(sizeof(struct dev_priv));
+	if (!ndev) {
+		dev_err(&pdev->dev, "could not allocate device.\n");
+		ret = -ENOMEM;
+		goto err_exit;
+	}
+	SET_NETDEV_DEV(ndev, &pdev->dev);
+	priv = netdev_priv(ndev);
+	priv->pdev = pdev;
+	priv->ndev = ndev;
+
+	spin_lock_init(&priv->chip_lock);
+	irq =  irq_of_parse_and_map(np, 0);
+	if (irq == NO_IRQ) {
+		printk(KERN_ERR "%s: Can't map main interrupt\n", np->full_name);
+		goto err_out_free_dev;
+	}
+
+	ndev->irq = irq;
+
+	/* Map EMAC regs */
+	if (of_address_to_resource(np, 0, &gmac_resource)) {
+		printk(KERN_ERR "%s: Can't get registers address\n",
+		       np->full_name);
+		goto err_irq_unmap;
+	}
+
+	//priv->net_base = ioremap(gmac_resource.start, resource_size(&gmac_resource));
+	priv->net_base = ioremap_nocache(gmac_resource.start, resource_size(&gmac_resource));
+
+	if (priv->net_base == NULL) {
+		printk(KERN_ERR "%s: Can't map device registers!\n",  np->full_name);
+		ret = -ENOMEM;
+		goto err_irq_unmap;
+	}
+	ndev->base_addr = (unsigned long)priv->net_base;
+	/* Setup driver functions */
+	ndev->netdev_ops = &cdac_netdev_ops;
+	ndev->ethtool_ops = &cdac_eth_ethtool_ops;
+	ndev->watchdog_timeo = msecs_to_jiffies(10000);
+	netdev_dbg(ndev, "IO address space     :%pR\n", &gmac_resource);
+	netdev_dbg(ndev, "IO address size      :%lld\n", resource_size(&gmac_resource));
+	netdev_dbg(ndev, "IO address (mapped)  :0x%ld\n", (long int)priv->net_base);
+	netdev_dbg(ndev, "IRQ number           :%d\n", ndev->irq);
+
+	/* Get MAC address from current HW setting (POR state is all zeros) */
+	__cdac_get_mac(ndev, ndev->dev_addr);
+	if (!is_valid_ether_addr(ndev->dev_addr)) {
+		const char *macaddr = of_get_mac_address(pdev->dev.of_node);
+		if (macaddr)
+			memcpy(ndev->dev_addr, macaddr, ETH_ALEN);
+	}
+	if (!is_valid_ether_addr(ndev->dev_addr))
+		eth_hw_addr_random(ndev);
+
+	/* Reset the ethernet controller */
+	__cdac_eth_reset(ndev);
+	/* then shut everything down to save power */
+	__cdac_eth_shutdown(ndev);
+
+	/* Set default parameters */
+	priv->msg_enable = NETIF_MSG_LINK;
+
+	/* Force an MII interface reset and clock setup */
+	__cdac_mii_mngt_reset(priv);
+
+	/* Force default PHY interface setup in chip, this will probably be
+	 changed by the PHY driver */
+	priv->link = 0;
+	priv->speed = 100;
+	priv->duplex = DUPLEX_FULL;
+	__cdac_params_setup(ndev);
+
+	//netif_napi_add(ndev, &priv->napi, cdac_eth_poll, NAPI_WEIGHT);
+
+	ret = register_netdev(ndev);
+	if (ret) {
+		dev_err(&pdev->dev, "Cannot register net device, aborting.\n");
+		goto err_out_iounmap;
+	}
+	platform_set_drvdata(pdev, ndev);
+	ret = cdac_mii_init(ndev);
+	if (ret)
+		goto err_out_unregister_netdev;
+
+	netdev_info(ndev, "CDAC mac at 0x%08llx irq %d\n", gmac_resource.start, ndev->irq);
+	phydev = ndev->phydev;
+
+	device_init_wakeup(&pdev->dev, 1);
+	device_set_wakeup_enable(&pdev->dev, 1);
+	return 0;
+
+	err_out_unregister_netdev:
+		 unregister_netdev(ndev);
+	err_out_iounmap:
+		 iounmap((volatile void *)(priv->net_base));
+	err_irq_unmap:
+		irq_dispose_mapping(irq);
+	err_out_free_dev:
+		free_netdev(ndev);
+	err_exit:
+	pr_err("%s: not found (%d).\n", MODNAME, ret);
+
+	return ret;
+}
+
+static int cdac_eth_drv_remove(struct platform_device *pdev) {
+	struct net_device *ndev = platform_get_drvdata(pdev);
+	struct dev_priv *priv = netdev_priv(ndev);
+
+	unregister_netdev(ndev);
+	iounmap((volatile void *)(priv->net_base));
+	mdiobus_unregister(priv->mii_bus);
+	mdiobus_free(priv->mii_bus);
+	free_netdev(ndev);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int cdac_eth_drv_suspend(struct platform_device *pdev,
+		pm_message_t state)
+{
+	struct net_device *ndev = platform_get_drvdata(pdev);
+	struct netdata_local *pldat = netdev_priv(ndev);
+
+	if (device_may_wakeup(&pdev->dev))
+	enable_irq_wake(ndev->irq);
+
+	if (ndev) {
+		if (netif_running(ndev)) {
+			netif_device_detach(ndev);
+			__cdac_eth_shutdown(pldat);
+			clk_disable_unprepare(pldat->clk);
+
+			/*
+			 * Reset again now clock is disable to be sure
+			 * EMC_MDC is down
+			 */
+			__cdac_eth_reset(pldat);
+		}
+	}
+
+	return 0;
+}
+
+static int cdac_eth_drv_resume(struct platform_device *pdev)
+{
+	struct net_device *ndev = platform_get_drvdata(pdev);
+	struct netdata_local *pldat;
+
+	if (device_may_wakeup(&pdev->dev))
+	disable_irq_wake(ndev->irq);
+
+	if (ndev) {MODULE_DEVICE_TABLE(of, cdac_dma_match);
+			/* Enable interface clock */
+			clk_enable(pldat->clk);
+
+			/* Reset and initialize */
+			__cdac_eth_reset(pldat);
+			__cdac_eth_init(pldat);
+
+			netif_device_attach(ndev);
+		}
+	}
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_OF
+static const struct of_device_id cdac_gmac_match[] = {
+	{
+		.type		= "network",
+		.compatible 	= "cdac,cdac_mac"
+	},
+	{}
+};
+
+MODULE_DEVICE_TABLE(of, cdac_gmac_match);
+#endif
+
+static struct platform_driver cdac_gmac_driver = {
+	.probe = cdac_eth_drv_probe,
+	.remove = cdac_eth_drv_remove,
+	.driver = {
+		.name = "cdac_mac",
+                .owner = THIS_MODULE,
+		.of_match_table = of_match_ptr(cdac_gmac_match),
+	},
+#ifdef CONFIG_PM
+	.suspend = cdac_eth_drv_suspend,
+	.resume = cdac_eth_drv_resume,
+#endif
+
+};
+
+static int __init cdac_gmac_init(void)
+{
+	int rc;
+
+	printk(KERN_INFO DRV_DESC ", version " DRV_VERSION "\n");
+
+	rc = platform_driver_register(&cdac_gmac_driver);
+	if (rc)
+		goto err;
+
+	return 0;
+
+ err:
+	return rc;
+}
+
+static void __exit cdac_gmac_exit(void)
+{
+	platform_driver_unregister(&cdac_gmac_driver);
+
+}
+
+module_init(cdac_gmac_init);
+module_exit(cdac_gmac_exit);
+
+MODULE_AUTHOR("Sreenadh S <sreenadh@cdac.in>, Anoop Varghese <vanoop@cdac.in>");
+MODULE_DESCRIPTION("CDAC Ethernet Driver");
+MODULE_LICENSE("GPL");
diff -Naur linux-5.4.1/drivers/net/ethernet/cdac/ermac/cdac_mac.h linux-5.4.1_modified/drivers/net/ethernet/cdac/ermac/cdac_mac.h
--- linux-5.4.1/drivers/net/ethernet/cdac/ermac/cdac_mac.h	1970-01-01 05:30:00.000000000 +0530
+++ linux-5.4.1_modified/drivers/net/ethernet/cdac/ermac/cdac_mac.h	2025-08-08 10:40:35.452622115 +0530
@@ -0,0 +1,165 @@
+/*
+ * linux/drivers/net/ethernet/cdac/ermac/cdac_gmac.h
+
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef _LINUX_CDAC_ETH_H
+#define _LINUX_CDAC_ETH_H
+
+/* use 0 for production, 1 for verification, >2 for debug. debug flags: */
+#define DEBUG_TX	 2
+#define DEBUG_RX	 4
+#define DEBUG_INT	 8
+#define DEBUG_IC	16
+#ifndef NET_DEBUG
+#define NET_DEBUG 	0
+#endif
+
+#define NET_UID		0
+#define NET_RDP		0x10
+#define NET_RAP		0x12
+#define NET_RESET	0x14
+#define NET_IDP		0x16
+
+/*
+ * RAP registers
+ */
+#define CSR0		0
+#define CSR0_INIT	0x0001
+#define CSR0_STRT	0x0002
+#define CSR0_STOP	0x0004
+#define CSR0_TDMD	0x0008
+#define CSR0_TXON	0x0010
+#define CSR0_RXON	0x0020
+#define CSR0_IENA	0x0040
+#define CSR0_INTR	0x0080
+#define CSR0_IDON	0x0100
+#define CSR0_TINT	0x0200
+#define CSR0_RINT	0x0400
+#define CSR0_MERR	0x0800
+#define CSR0_MISS	0x1000
+#define CSR0_CERR	0x2000
+#define CSR0_BABL	0x4000
+#define CSR0_ERR	0x8000
+
+#define CSR3		3
+#define CSR3_EMBA	0x0008
+#define CSR3_DXMT2PD	0x0010
+#define CSR3_LAPPEN	0x0020
+#define CSR3_DXSUFLO	0x0040
+#define CSR3_IDONM	0x0100
+#define CSR3_TINTM	0x0200
+#define CSR3_RINTM	0x0400
+#define CSR3_MERRM	0x0800
+#define CSR3_MISSM	0x1000
+#define CSR3_BABLM	0x4000
+#define CSR3_MASKALL	0x5F00
+
+#define CSR4		4
+#define CSR4_JABM	0x0001
+#define CSR4_JAB	0x0002
+#define CSR4_TXSTRTM	0x0004
+#define CSR4_TXSTRT	0x0008
+#define CSR4_RCVCCOM	0x0010
+#define CSR4_RCVCCO	0x0020
+#define CSR4_MFCOM	0x0100
+#define CSR4_MFCO	0x0200
+#define CSR4_ASTRP_RCV	0x0400
+#define CSR4_APAD_XMIT	0x0800
+
+#define CTRL1		5
+#define CTRL1_SPND	0x0001
+
+#define LADRL		8
+#define LADRM1		9
+#define LADRM2		10
+#define LADRH		11
+#define PADRL		12
+#define PADRM		13
+#define PADRH		14
+
+#define MODE		15
+#define MODE_DISRX	0x0001
+#define MODE_DISTX	0x0002
+#define MODE_LOOP	0x0004
+#define MODE_DTCRC	0x0008
+#define MODE_COLL	0x0010
+#define MODE_DRETRY	0x0020
+#define MODE_INTLOOP	0x0040
+#define MODE_PORT_AUI	0x0000
+#define MODE_PORT_10BT	0x0080
+#define MODE_DRXPA	0x2000
+#define MODE_DRXBA	0x4000
+#define MODE_PROMISC	0x8000
+
+#define BASERXL		24
+#define BASERXH		25
+#define BASETXL		30
+#define BASETXH		31
+
+#define POLLINT		47
+
+#define SIZERXR		76
+#define SIZETXR		78
+
+#define CSR_MFC		112
+
+#define RMD_ENP		0x0100
+#define RMD_STP		0x0200
+#define RMD_CRC		0x0800
+#define RMD_FRAM	0x2000
+#define RMD_ERR		0x4000
+#define RMD_OWN		0x8000
+
+#define TMD_ENP		0x0100
+#define TMD_STP		0x0200
+#define TMD_MORE	0x1000
+#define TMD_ERR		0x4000
+#define TMD_OWN		0x8000
+
+#define TST_RTRY	0x0400
+#define TST_LCAR	0x0800
+#define TST_LCOL	0x1000
+#define TST_UFLO	0x4000
+#define TST_BUFF	0x8000
+
+#define ISALED0		0x0004
+#define ISALED0_LNKST	0x8000
+
+#define TX_BUFFERS 15
+#define RX_BUFFERS 25
+
+extern void __iomem *			gDma_base;
+
+
+struct dev_priv {
+    unsigned long	rxbuffer[RX_BUFFERS];
+    unsigned long	txbuffer[TX_BUFFERS];
+    unsigned char	txhead;
+    unsigned char	txtail;
+    unsigned char	rxhead;
+    unsigned char	rxtail;
+    unsigned long	rxhdr;
+    unsigned long	txhdr;
+    spinlock_t		chip_lock;
+    struct timer_list		timer;
+   // struct clk *clk;
+    struct net_device   	*ndev;
+	struct platform_device	*pdev;
+    struct mii_bus 			*mii_bus;
+	void __iomem *			net_base;
+	int tx_len[100];
+	int tx_intr_index;
+	int tx_index;
+	struct napi_struct	napi;
+	u32			msg_enable;
+	int			link;
+	int			speed;
+	int			duplex;
+};
+
+#endif
diff -Naur linux-5.4.1/drivers/net/ethernet/cdac/ermac/ermac.c linux-5.4.1_modified/drivers/net/ethernet/cdac/ermac/ermac.c
--- linux-5.4.1/drivers/net/ethernet/cdac/ermac/ermac.c	1970-01-01 05:30:00.000000000 +0530
+++ linux-5.4.1_modified/drivers/net/ethernet/cdac/ermac/ermac.c	2025-08-08 10:40:35.452736910 +0530
@@ -0,0 +1,181 @@
+#include "ermac.h"
+
+#include <asm/csr.h>
+
+#include <linux/delay.h>
+
+#include <linux/slab.h>
+
+
+
+//__asm__ __volatile__ ("fence"); //To complete the write operation in O-O-O processor
+
+
+
+void Init_PHY_default_SAF_GMAC(void __iomem *gmac_base_vaddr)
+
+{
+
+	UI intr_status;
+
+
+
+	printk("Initializing ethernet.... \n");
+
+	intr_status = readl(
+
+		gmac_base_vaddr +
+
+		ERMAC_INTR_STATUS_REG); //clear if any pending intr is there
+
+	writel((0x800000F0 | UNICAST_BROADCAST | DUPLEX | TX_ENABLE | RX_ENABLE | PROMISCUS),
+
+	       (gmac_base_vaddr + ERMAC_CNTRL_REG));
+
+	mdelay(800);
+
+	writel(0, (gmac_base_vaddr + ERMAC_INTR_EN_REG));
+
+	writel((TX_CMP_INTR | RX_CMP_INTR),
+
+	       (gmac_base_vaddr + ERMAC_INTR_EN_REG));
+
+	intr_status = readl(
+
+		gmac_base_vaddr +
+
+		ERMAC_INTR_STATUS_REG); //clear if any pending intr is there
+
+}
+
+
+
+void send_ethernet(volatile unsigned char *buf, void __iomem *gmac_base_vaddr,
+
+		   int length)
+
+{
+
+	int i, tLen;
+
+	unsigned int data;
+
+	unsigned int *tx_memory;
+
+
+
+	//printk("[C-DAC DEBUG] @send_ethernet : %x --> %d \n", gmac_base_vaddr, length);
+
+	tx_memory = (unsigned int *)kmalloc(8000, GFP_KERNEL);
+
+	memcpy(tx_memory, (unsigned int *) buf, length);
+
+
+
+	if ((length % 4) != 0)
+
+		tLen = (length / 4) + 1;
+
+	else
+
+		tLen = (length / 4);
+
+
+
+	for (i = 0; i < tLen; i++) {
+
+		data = bigToLittle(tx_memory[i]); //tx_memory[i];
+
+		writel(data, (gmac_base_vaddr + ERMAC_TX_DATA_FIFO));
+
+	}
+
+	kfree(tx_memory);
+
+	writel(length, (gmac_base_vaddr + ERMAC_TX_LENGTH_FIFO));
+
+}
+
+
+
+int check_gmac_rx(void __iomem *gmac_base_vaddr)
+
+{
+
+	UI reg_val;
+
+	unsigned int length;
+
+
+
+	reg_val = readl(gmac_base_vaddr + ERMAC_RX_LENGTH_FIFO_STATUS_REG);
+
+	if ((reg_val & RX_LENGTH_FIFO_EMTY) == 0) { //length fifo not empty
+
+		length = readl(gmac_base_vaddr + ERMAC_RX_LENGTH_FIFO);
+
+		return length; //Length FIFO not empty
+
+	} else
+
+		return 0; //Length FIFO empty
+
+}
+
+
+
+int receive_ethernet(UC *buf, void __iomem *gmac_base_vaddr,
+
+		     unsigned int length)
+
+{
+
+	UI i = 0, tLen = 0, data;
+
+	unsigned int *rx_memory;
+
+
+
+	rx_memory = (unsigned int *)kmalloc(8000, GFP_KERNEL);
+
+
+
+	if ((length % 4) != 0)
+
+		tLen = (length / 4) + 1;
+
+	else
+
+		tLen = (length / 4);
+
+	for (i = 0; i < tLen; i++) {
+
+		data = readl(gmac_base_vaddr + ERMAC_RX_DATA_FIFO);
+
+		rx_memory[i] = bigToLittle(data); //data ;
+
+	}
+
+	memcpy(buf, rx_memory, length);
+
+
+
+	kfree(rx_memory);
+
+
+
+	return length;
+
+}
+
+
+
+unsigned int bigToLittle(unsigned int x)
+
+{
+
+	return (((x >> 24) & 0x000000ff) | ((x >> 8) & 0x0000ff00) |
+
+		((x << 8) & 0x00ff0000) | ((x << 24) & 0xff000000));
+
+}
diff -Naur linux-5.4.1/drivers/net/ethernet/cdac/ermac/ermac.h linux-5.4.1_modified/drivers/net/ethernet/cdac/ermac/ermac.h
--- linux-5.4.1/drivers/net/ethernet/cdac/ermac/ermac.h	1970-01-01 05:30:00.000000000 +0530
+++ linux-5.4.1_modified/drivers/net/ethernet/cdac/ermac/ermac.h	2025-08-08 10:40:35.452832329 +0530
@@ -0,0 +1,123 @@
+#include <linux/io.h>
+
+#include <asm/sbi.h>
+
+
+
+typedef unsigned long 	UL;
+
+typedef unsigned int 	UI;
+
+typedef unsigned char 	UC;
+
+typedef unsigned short 	US;
+
+
+
+#define PHY_READ_BIT		0x01
+
+#define PHY_WRITE_BIT		0x00
+
+#define PHY_BUSY_BIT		0x01
+
+#define	MII_READ_DATA_CMD(PHY_ADDR, REG_ADDR)	(PHY_ADDR << 2) | (PHY_READ_BIT << 1) | (PHY_BUSY_BIT << 0) | (REG_ADDR << 7)
+
+#define	MII_WRITE_DATA_CMD(PHY_ADDR, REG_ADDR)	(PHY_ADDR << 2) | (PHY_WRITE_BIT << 1) | (PHY_BUSY_BIT << 0) | (REG_ADDR << 7)
+
+
+
+#define ERMAC_TX_DATA_FIFO                	0xEC
+
+#define ERMAC_TX_LENGTH_FIFO              	0xE8
+
+#define ERMAC_TX_STATUS_FIFO              	0xFC
+
+
+
+#define ERMAC_RX_DATA_FIFO                	0xF4
+
+#define ERMAC_RX_LENGTH_FIFO              	0xF0
+
+#define ERMAC_RX_STATUS_FIFO              	0xF8
+
+
+
+#define ERMAC_CNTRL_REG                  	0x00
+
+#define	DUPLEX								BIT(0)
+
+#define	TX_ENABLE							BIT(2)
+
+#define	RX_ENABLE							BIT(4)
+
+#define	UNICAST_BROADCAST					BIT(15)
+
+#define	PROMISCUS							BIT(17)
+
+
+
+#define ERMAC_ADDR_HIGH_REG               	0x18
+
+#define ERMAC_ADDR_LOW_REG                	0x14
+
+
+
+#define ERMAC_SRC_FLT_ADDRH_REG           	0x38
+
+#define ERMAC_SRC_FLT_ADDRL_REG           	0x3C
+
+#define ERMAC_MII_MNGMNT_CNTRL_REG          0x2C
+
+
+
+#define ERMAC_MII_READ_DATA_REG				0x88
+
+
+
+#define ERMAC_TX_DATA_FIFO_STATUS_REG     	0xCC
+
+#define ERMAC_TX_LENGTH_FIFO_STATUS_REG   	0xC4
+
+#define ERMAC_TX_STATUS_FIFO_STATUS_REG   	0xBC
+
+
+
+#define ERMAC_RX_DATA_FIFO_STATUS_REG     	0xC8
+
+#define ERMAC_RX_LENGTH_FIFO_STATUS_REG   	0xC0
+
+#define RX_LENGTH_FIFO_EMTY					BIT(2)
+
+
+
+#define ERMAC_RX_STATUS_FIFO_STATUS_REG   	0xB8
+
+
+
+#define ERMAC_INTR_EN_REG               	0x28
+
+#define RX_CMP_INTR 						BIT(0)
+
+#define TX_CMP_INTR							BIT(31)
+
+
+
+#define ERMAC_INTR_STATUS_REG             	0x24
+
+#define RX_INTR_STAT						BIT(0)
+
+#define TX_INTR_STAT						BIT(31)
+
+
+
+void Init_PHY_default_SAF_GMAC(void __iomem * gmac_base_vaddr);
+
+void send_ethernet(volatile unsigned char *buf, void __iomem * gmac_base_vaddr, int length);
+
+int receive_ethernet(UC *buf, void __iomem * gmac_base_vaddr,unsigned int length);
+
+unsigned int bigToLittle(unsigned int x);
+
+unsigned int cdac_readword_fn(void __iomem * dev_base, unsigned long off);
+
+int check_gmac_rx(void __iomem * gmac_base_vaddr);
diff -Naur linux-5.4.1/drivers/net/ethernet/cdac/ermac/Kconfig linux-5.4.1_modified/drivers/net/ethernet/cdac/ermac/Kconfig
--- linux-5.4.1/drivers/net/ethernet/cdac/ermac/Kconfig	1970-01-01 05:30:00.000000000 +0530
+++ linux-5.4.1_modified/drivers/net/ethernet/cdac/ermac/Kconfig	2025-08-08 10:54:53.871934058 +0530
@@ -0,0 +1,8 @@
+config NET_CDAC_ERMAC
+        tristate "CDAC ethernet ERMAC (10/100) on C-DAC devices"
+        depends on ARCH_RV32I
+        select PHYLIB
+        help
+	  Say Y or M here if you want to use the C-DAC ethernet MAC (10/100) included on
+	  some CDAC RISCV devices. You can safely enable this option for CDAC
+	  SoC. Also available as a module.
diff -Naur linux-5.4.1/drivers/net/ethernet/cdac/ermac/Makefile linux-5.4.1_modified/drivers/net/ethernet/cdac/ermac/Makefile
--- linux-5.4.1/drivers/net/ethernet/cdac/ermac/Makefile	1970-01-01 05:30:00.000000000 +0530
+++ linux-5.4.1_modified/drivers/net/ethernet/cdac/ermac/Makefile	2025-08-08 10:40:35.452996547 +0530
@@ -0,0 +1,6 @@
+# SPDX-License-Identifier: GPL-2.0
+#
+# Makefile for the CDAC network device drivers.
+#
+
+obj-$(CONFIG_NET_CDAC_ERMAC) += cdac_mac.o ermac.o
diff -Naur linux-5.4.1/drivers/net/ethernet/cdac/Kconfig linux-5.4.1_modified/drivers/net/ethernet/cdac/Kconfig
--- linux-5.4.1/drivers/net/ethernet/cdac/Kconfig	1970-01-01 05:30:00.000000000 +0530
+++ linux-5.4.1_modified/drivers/net/ethernet/cdac/Kconfig	2025-08-08 10:55:07.552346467 +0530
@@ -0,0 +1,8 @@
+config CDAC_ENET
+        tristate "CDAC ethernet MAC on CDAC devices"
+        depends on ARCH_RV32I
+        select PHYLIB
+        help
+	  Say Y or M here if you want to use the C-DAC GMAC included on
+	  some CDAC RISCV devices. You can safely enable this option for CDAC
+	  SoC. Also available as a module.
diff -Naur linux-5.4.1/drivers/net/ethernet/cdac/Makefile linux-5.4.1_modified/drivers/net/ethernet/cdac/Makefile
--- linux-5.4.1/drivers/net/ethernet/cdac/Makefile	1970-01-01 05:30:00.000000000 +0530
+++ linux-5.4.1_modified/drivers/net/ethernet/cdac/Makefile	2025-08-08 10:40:35.453139766 +0530
@@ -0,0 +1,6 @@
+# SPDX-License-Identifier: GPL-2.0
+#
+# Makefile for the CDAC network device drivers.
+#
+
+obj-$(CONFIG_CDAC_ENET) += cdac_gmac.o ergmac.o
diff -Naur linux-5.4.1/drivers/net/ethernet/Kconfig linux-5.4.1_modified/drivers/net/ethernet/Kconfig
--- linux-5.4.1/drivers/net/ethernet/Kconfig	2019-11-29 14:40:32.000000000 +0530
+++ linux-5.4.1_modified/drivers/net/ethernet/Kconfig	2025-08-08 10:40:35.453234183 +0530
@@ -43,6 +43,8 @@
 source "drivers/net/ethernet/cirrus/Kconfig"
 source "drivers/net/ethernet/cisco/Kconfig"
 source "drivers/net/ethernet/cortina/Kconfig"
+source "drivers/net/ethernet/cdac/Kconfig"
+source "drivers/net/ethernet/cdac/ermac/Kconfig"
 
 config CX_ECAT
 	tristate "Beckhoff CX5020 EtherCAT master support"
diff -Naur linux-5.4.1/drivers/net/ethernet/Makefile linux-5.4.1_modified/drivers/net/ethernet/Makefile
--- linux-5.4.1/drivers/net/ethernet/Makefile	2019-11-29 14:40:32.000000000 +0530
+++ linux-5.4.1_modified/drivers/net/ethernet/Makefile	2025-08-08 10:40:35.453370078 +0530
@@ -96,3 +96,5 @@
 obj-$(CONFIG_NET_VENDOR_XIRCOM) += xircom/
 obj-$(CONFIG_NET_VENDOR_SYNOPSYS) += synopsys/
 obj-$(CONFIG_NET_VENDOR_PENSANDO) += pensando/
+obj-$(CONFIG_NET_CDAC_ERMAC) += cdac/ermac/
+obj-$(CONFIG_CDAC_ENET) += cdac/
diff -Naur linux-5.4.1/drivers/pwm/Kconfig linux-5.4.1_modified/drivers/pwm/Kconfig
--- linux-5.4.1/drivers/pwm/Kconfig	2019-11-29 14:40:32.000000000 +0530
+++ linux-5.4.1_modified/drivers/pwm/Kconfig	2025-08-08 10:40:35.453505011 +0530
@@ -553,4 +553,9 @@
 	  To compile this driver as a module, choose M here: the module
 	  will be called pwm-zx.
 
+config PWM_CDAC
+	tristate "C-DAC PWM support"
+	help
+	  Generic PWM framework driver for C-DAC THEJAS64 SoCs.
+	  
 endif
diff -Naur linux-5.4.1/drivers/pwm/Makefile linux-5.4.1_modified/drivers/pwm/Makefile
--- linux-5.4.1/drivers/pwm/Makefile	2019-11-29 14:40:32.000000000 +0530
+++ linux-5.4.1_modified/drivers/pwm/Makefile	2025-08-08 10:40:35.453649261 +0530
@@ -55,3 +55,4 @@
 obj-$(CONFIG_PWM_TWL_LED)	+= pwm-twl-led.o
 obj-$(CONFIG_PWM_VT8500)	+= pwm-vt8500.o
 obj-$(CONFIG_PWM_ZX)		+= pwm-zx.o
+obj-$(CONFIG_PWM_CDAC)		+= pwm-cdac.o
diff -Naur linux-5.4.1/drivers/pwm/pwm-cdac.c linux-5.4.1_modified/drivers/pwm/pwm-cdac.c
--- linux-5.4.1/drivers/pwm/pwm-cdac.c	1970-01-01 05:30:00.000000000 +0530
+++ linux-5.4.1_modified/drivers/pwm/pwm-cdac.c	2025-08-19 11:00:55.704270853 +0530
@@ -0,0 +1,254 @@
+/*
+ * C-DAC Pulse Width Modulation Controller
+ *
+ * Copyright (C) 2020 C-DAC Thiruvananthapuram.
+ *
+ */
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/pwm.h>
+#include <linux/slab.h>
+
+/* The following is global registers for PWM controller */
+#define GLOBAL_CONTROL_REG			0x80
+#define GLOBAL_PWM_ENABLE			BIT(0)
+#define GLOBAL_INTR_ENABLE			BIT(1)
+#define GLOBAL_INTR_PENDING			GENMASK(9, 2)
+
+/* The following register is PWM channel related registers */
+#define PWM_CH_CONTROL_REG			0x00
+#define PWM_CH_MODE					GENMASK(1, 0)
+#define PWM_CH_ALIGN				GENMASK(2, 3)
+#define PWM_CH_INTR_ENABLE			BIT(4)
+#define PWM_CH_OUTPUT				BIT(5)
+#define PWM_CH_COUNT				GENMASK(21, 6)
+
+#define PWM_CH_STATUS_REG			0x04
+#define PWM_CH_STATUS				BIT(0)
+#define PWM_CH_INTR_PENDING			BIT(1)
+
+#define PWM_CH_PERIOD_REG			0x08
+#define PWM_CH_DUTY_REG				0x0C // ON/OFF register as per documentation.
+
+/* PWM Mode Values */
+#define PWM_IDLE					0x0
+#define PWM_ONE_SHORT				0x1
+#define PWM_CONTINUOUS				0x2
+
+#define PWM_LEFT_ALIGN				0x0
+#define PWM_RIGHT_ALIGN				0x1
+
+/*
+ * Max and Min value for duty and period
+ */
+#define PWM_MIN_PERIOD				0x2
+#define PWM_MAX_PERIOD				0xFFFFFFFF
+#define PWM_MIN_DUTY				0x1
+#define PWM_MAX_DUTY				(PWM_MAX_PERIOD - 1)
+
+#define PWM_CH_REG_SIZE				0x10
+#define PRD_MAX_CHANNELS			8
+#define SEC_IN_NS					1000000000
+
+
+struct cdac_pwm_chip {
+	struct pwm_chip chip;
+	struct clk *clk;
+	void __iomem *base;
+
+	unsigned int updated_pwms;
+	/* ISR is cleared when read, ensure only one thread does that */
+	struct mutex isr_lock;
+};
+
+static inline struct cdac_pwm_chip *to_cdac_pwm_chip(struct pwm_chip *chip)
+{
+	return container_of(chip, struct cdac_pwm_chip, chip);
+}
+
+
+static inline u32 cdac_pwm_readl(struct cdac_pwm_chip *chip,
+				  unsigned int offset)
+{
+	return readl(chip->base + offset);
+}
+
+static inline void cdac_pwm_writel(struct cdac_pwm_chip *chip,
+				    unsigned int offset, unsigned int val)
+{
+	writel(val, chip->base + offset);
+}
+
+static unsigned int ns_to_cycle(struct cdac_pwm_chip *cdac_pwm, unsigned int nano_secs){
+	unsigned int cycles = (nano_secs * clk_get_rate(cdac_pwm->clk))/SEC_IN_NS ;
+	return cycles;
+}
+static int cdac_pwm_apply(struct pwm_chip *chip, struct pwm_device *pwm,
+			    const struct pwm_state *state)
+{
+	struct cdac_pwm_chip *cdac_pwm = to_cdac_pwm_chip(chip);
+	struct pwm_state prev_state;
+	unsigned int cycle_period, cycle_duty;
+	u32 ctrl_reg;
+	int ret;
+        
+        //pr_err("state->period ::> %d\n",state->period);
+        //pr_err("state->duty_cycle ::> %d\n",state->duty_cycle);
+        //pr_err("state->enabled ::> %d\n",state->enabled);
+        //pr_err("state->polarity ::> %d\n",state->polarity);
+        
+	pwm_get_state(pwm, &prev_state);
+	ns_to_cycle(cdac_pwm, state->period);
+
+	if(prev_state.period != state->period){
+		//cycle_period = ns_to_cycle(cdac_pwm, state->period);
+		cdac_pwm_writel(cdac_pwm, ((pwm->hwpwm * PWM_CH_REG_SIZE)+PWM_CH_PERIOD_REG), state->period);
+	}
+
+	if(prev_state.duty_cycle != state->duty_cycle){
+		//cycle_duty = ns_to_cycle(cdac_pwm, state->duty_cycle);
+		cdac_pwm_writel(cdac_pwm, ((pwm->hwpwm * PWM_CH_REG_SIZE)+PWM_CH_DUTY_REG), state->duty_cycle);
+	}
+	if (state->polarity == PWM_POLARITY_NORMAL){
+			ctrl_reg = (PWM_CH_ALIGN | (PWM_LEFT_ALIGN << 2));
+	}
+	else{
+			ctrl_reg = (PWM_CH_ALIGN | (PWM_RIGHT_ALIGN << 2));
+	}
+	//pr_err("state->enabled ::> %d\n",state->enabled);
+	if(state->enabled){
+		//pr_err("state->enabled 1(ON):::::::::::::>\n");
+		ctrl_reg = (PWM_CH_MODE & PWM_CONTINUOUS);
+	}else
+	{
+		//pr_err("state->enabled 0(OFF):::::::::::::>\n");
+		ctrl_reg = (PWM_CH_MODE & PWM_IDLE);
+	}
+	
+	//pr_err("ctrl_reg ::> 0x%lx\n",ctrl_reg);
+	
+	cdac_pwm_writel(cdac_pwm, ((pwm->hwpwm * PWM_CH_REG_SIZE)+PWM_CH_CONTROL_REG), 0);
+	cdac_pwm_writel(cdac_pwm, ((pwm->hwpwm * PWM_CH_REG_SIZE)+PWM_CH_CONTROL_REG), ctrl_reg);
+	cdac_pwm_writel(cdac_pwm, GLOBAL_CONTROL_REG, 0);
+	cdac_pwm_writel(cdac_pwm, GLOBAL_CONTROL_REG, GLOBAL_PWM_ENABLE);
+	return 0;
+}
+
+static const struct pwm_ops cdac_pwm_ops = {
+	.apply = cdac_pwm_apply,
+	.owner = THIS_MODULE,
+};
+
+
+
+static const struct platform_device_id cdac_pwm_devtypes[] = {
+	{
+		.name = "cdac-pwm",
+	}, {
+		/* sentinel */
+	},
+};
+MODULE_DEVICE_TABLE(platform, cdac_pwm_devtypes);
+
+static const struct of_device_id cdac_pwm_dt_ids[] = {
+	{
+		.compatible = "cdac,cdac-pwm",
+	}, {
+		/* sentinel */
+	},
+};
+MODULE_DEVICE_TABLE(of, cdac_pwm_dt_ids);
+
+
+
+
+static int cdac_pwm_probe(struct platform_device *pdev)
+{
+	struct cdac_pwm_chip *cdac_pwm;
+	struct resource *res;
+	int ret;
+	//pr_err("Inside cdac_pwm_probe:::::::::::::::::::::::::::::::::::::::::::::::::::>1\n");
+	cdac_pwm = devm_kzalloc(&pdev->dev, sizeof(*cdac_pwm), GFP_KERNEL);
+	if (!cdac_pwm)
+		return -ENOMEM;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	cdac_pwm->base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(cdac_pwm->base))
+		return PTR_ERR(cdac_pwm->base);
+
+	cdac_pwm->clk = devm_clk_get(&pdev->dev, "pwm_clock");
+	if (IS_ERR(cdac_pwm->clk))
+		return PTR_ERR(cdac_pwm->clk);
+
+	ret = clk_prepare(cdac_pwm->clk);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to prepare PWM clock\n");
+		return ret;
+	}
+
+	cdac_pwm->chip.dev = &pdev->dev;
+	cdac_pwm->chip.ops = &cdac_pwm_ops;
+
+	if (pdev->dev.of_node) {
+		cdac_pwm->chip.of_xlate = of_pwm_xlate_with_flags;
+		cdac_pwm->chip.of_pwm_n_cells = 3;
+	}
+
+	cdac_pwm->chip.base = 0;
+	cdac_pwm->chip.npwm = PRD_MAX_CHANNELS;
+	cdac_pwm->updated_pwms = 0;
+	mutex_init(&cdac_pwm->isr_lock);
+
+	ret = pwmchip_add(&cdac_pwm->chip);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "failed to add PWM chip %d\n", ret);
+		goto unprepare_clk;
+	}
+
+	/* Enabling PWM */
+	cdac_pwm_writel(cdac_pwm, GLOBAL_CONTROL_REG, GLOBAL_PWM_ENABLE);
+	dev_info(&pdev->dev,"C-DAC PWM Controller at 0x%08lx \n", (unsigned int)cdac_pwm->base);
+	//pr_err("C-DAC PWM Controller at 0x%08lx \n", (unsigned int)cdac_pwm->base);
+
+	platform_set_drvdata(pdev, cdac_pwm);
+
+	return ret;
+
+unprepare_clk:
+	clk_unprepare(cdac_pwm->clk);
+	return ret;
+}
+
+static int cdac_pwm_remove(struct platform_device *pdev)
+{
+	struct cdac_pwm_chip *cdac_pwm = platform_get_drvdata(pdev);
+
+	clk_unprepare(cdac_pwm->clk);
+	mutex_destroy(&cdac_pwm->isr_lock);
+
+	return pwmchip_remove(&cdac_pwm->chip);
+}
+
+static struct platform_driver cdac_pwm_driver = {
+	.driver = {
+		.name = "cdac-pwm",
+		.of_match_table = of_match_ptr(cdac_pwm_dt_ids),
+	},
+	.id_table = cdac_pwm_devtypes,
+	.probe = cdac_pwm_probe,
+	.remove = cdac_pwm_remove,
+};
+module_platform_driver(cdac_pwm_driver);
+
+MODULE_ALIAS("platform:cdac-pwm");
+MODULE_DESCRIPTION("C-DAC Thiruvananthapuram PWM Driver");
+MODULE_AUTHOR("Anoop Varghese <vanoop@cdac.in>");
+MODULE_LICENSE("GPL v2");
diff -Naur linux-5.4.1/drivers/spi/Kconfig linux-5.4.1_modified/drivers/spi/Kconfig
--- linux-5.4.1/drivers/spi/Kconfig	2019-11-29 14:40:32.000000000 +0530
+++ linux-5.4.1_modified/drivers/spi/Kconfig	2025-08-08 10:40:35.453925990 +0530
@@ -192,6 +192,11 @@
 	  This selects the Cadence SPI controller master driver
 	  used by Xilinx Zynq and ZynqMP.
 
+config SPI_CDAC
+	tristate "cdac SPI controller"
+	help
+	  This selects the cdac SPI controller master driver.
+
 config SPI_CLPS711X
 	tristate "CLPS711X host SPI controller"
 	depends on ARCH_CLPS711X || COMPILE_TEST
diff -Naur linux-5.4.1/drivers/spi/Makefile linux-5.4.1_modified/drivers/spi/Makefile
--- linux-5.4.1/drivers/spi/Makefile	2019-11-29 14:40:32.000000000 +0530
+++ linux-5.4.1_modified/drivers/spi/Makefile	2025-08-08 10:40:35.456169879 +0530
@@ -29,6 +29,7 @@
 obj-$(CONFIG_SPI_BITBANG)		+= spi-bitbang.o
 obj-$(CONFIG_SPI_BUTTERFLY)		+= spi-butterfly.o
 obj-$(CONFIG_SPI_CADENCE)		+= spi-cadence.o
+obj-$(CONFIG_SPI_CDAC)			+= spi-cdac.o
 obj-$(CONFIG_SPI_CLPS711X)		+= spi-clps711x.o
 obj-$(CONFIG_SPI_COLDFIRE_QSPI)		+= spi-coldfire-qspi.o
 obj-$(CONFIG_SPI_DAVINCI)		+= spi-davinci.o
diff -Naur linux-5.4.1/drivers/spi/spi-cdac.c linux-5.4.1_modified/drivers/spi/spi-cdac.c
--- linux-5.4.1/drivers/spi/spi-cdac.c	1970-01-01 05:30:00.000000000 +0530
+++ linux-5.4.1_modified/drivers/spi/spi-cdac.c	2025-08-08 10:40:35.456312116 +0530
@@ -0,0 +1,487 @@
+/*
+ * CDAC SPI controller driver (master mode only)
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License version 2 as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/gpio.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/of_irq.h>
+#include <linux/of_address.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/spi/spi.h>
+
+/* Name of this driver */
+#define CDAC_SPI_NAME		"cdac-spi"
+
+/* Register offset definitions */
+#define CDAC_SPI_CR		0x00 /* Control Register */
+#define CDAC_SPI_CS		BIT(8)
+#define CDAC_SPI_TX_INTR	BIT(7)
+#define CDAC_SPI_RX_INTR        BIT(6)
+#define CDAC_SPI_CPOL           BIT(5)
+#define CDAC_SPI_CPHA           BIT(4)
+#define CDAC_SPI_LSB		BIT(3)
+#define CDAC_SPI_DEFAULT_CHIP   0x00000004
+#define CDAC_SPI_CR_DEFAULT	(CDAC_SPI_DEFAULT_CHIP)
+
+#define CDAC_SPI_STAT			0x04 /* Status Register */
+#define CDAC_SPI_TX_STAT		BIT(7)
+#define CDAC_SPI_RX_STAT BIT(6)
+#define CDAC_SPI_OVERRUN		BIT(5)
+#define CDAC_SPI_TX_BUSY		BIT(4)
+#define CDAC_SPI_TX_INT_STAT		BIT(3)
+#define CDAC_SPI_RX_INT_STAT		BIT(2)
+
+#define CDAC_SPI_BAUD			0x08 /* Baud Rate Register */
+#define CDAC_SPI_DEFAULT_BAUD		0    /* Divisor is 4 */
+#define CDAC_SPI_TXD			0x0C /* Transmit Data Register */
+
+#define CDAC_SPI_RXD			0x10 /* Receive Data Register */
+
+/* Default number of chip select lines */
+#define CDAC_SPI_DEFAULT_NUM_CS		4
+#define SPI_CHIP_SEL_MASK 0xFFFC
+#define SPI_AUTOSUSPEND_TIMEOUT		6000
+/*
+ * struct cdac_spi - This definition defines spi driver instance
+ */
+struct cdac_spi {
+	struct spi_transfer *current_transfer;
+	void __iomem *regs;
+	struct clk *spi_clock;
+	u32 speed_hz;
+	spinlock_t lock;
+	unsigned int tx_bytes_rem;
+	unsigned int rx_bytes_rem;
+	u32 is_decoded_cs;
+	u32 status;
+	bool transfer_failed;
+};
+
+struct cdac_spi_device_data {
+	bool gpio_requested;
+};
+
+/* Macros for the SPI controller read/write */
+static inline u32 cdac_spi_read(struct cdac_spi *xspi, u32 offset)
+{
+	u32 val;
+	val = readl(xspi->regs + offset);
+	return val;
+}
+
+static inline void cdac_spi_write(struct cdac_spi *xspi, u32 offset, u32 val)
+{
+	writel(val, xspi->regs + offset);
+}
+
+/**
+ * cdac_spi_init_hw - Initialize the hardware and configure the SPI controller
+ * @xspi:	Pointer to the cdac_spi structure
+ *
+ */
+static void cdac_spi_init_hw(struct cdac_spi *xspi)
+{
+	u32 ctrl_reg;
+
+	ctrl_reg = CDAC_SPI_CR_DEFAULT;
+
+	if (xspi->is_decoded_cs)
+		ctrl_reg |= ctrl_reg;//CDAC_SPI_CR_PERI_SEL;
+
+	cdac_spi_write(xspi, CDAC_SPI_CR, ctrl_reg); // setting control reg
+	cdac_spi_write(xspi, CDAC_SPI_BAUD, CDAC_SPI_DEFAULT_BAUD); // setting baud reg
+
+	/* Clear the RX FIFO */
+	while (cdac_spi_read(xspi, CDAC_SPI_STAT) & CDAC_SPI_RX_STAT){
+			cdac_spi_read(xspi, CDAC_SPI_RXD);
+	}
+}
+
+/**
+ * set the logic level of the chip select line. May be called from interrupt context.
+ * cdac_spi_chipselect - Select or deselect the chip select line
+ * @spi:	Pointer to the spi_device structure
+ * @is_high:	Select(0) or deselect (1) the chip select line
+ */
+static void cdac_spi_chipselect(struct spi_device *spi, bool is_high)
+{
+	struct cdac_spi *xspi ;
+	u32 ctrl_reg;
+
+
+	xspi = spi_master_get_devdata(spi->master);
+	ctrl_reg = cdac_spi_read(xspi, CDAC_SPI_CR);
+
+	if (is_high){
+		/* deselect */
+		ctrl_reg &= ~CDAC_SPI_CS;
+	}
+	else{
+		/*select*/
+		ctrl_reg |= CDAC_SPI_CS;
+	}
+
+	cdac_spi_write(xspi, CDAC_SPI_CR, ctrl_reg);
+}
+
+/**
+ * cdac_spi_config_clock_freq - Sets clock frequency
+ * Sets the requested clock frequency.
+ */
+static void cdac_spi_config_clock_freq(struct spi_device *spi,
+				       struct spi_transfer *transfer)
+{
+	struct cdac_spi *xspi = spi_master_get_devdata(spi->master);
+	u32 baud_rate_val = 0, frequency, baud_divisor = 4;
+
+	if (xspi->speed_hz != transfer->speed_hz) {
+		frequency = clk_get_rate(xspi->spi_clock);
+		// Set the clock frequency
+	  while(baud_divisor < 2048){  /* C-DAC SPI Clock Frequency Divisor ranges from 4 to 2048 */
+			if(transfer->speed_hz >= (frequency / baud_divisor)){
+				break;
+			}
+			baud_rate_val++;
+			baud_divisor = baud_divisor << 1;  /* Clock Frequency Divisor increses as powers of 2 */
+		}
+		xspi->speed_hz = transfer->speed_hz;
+		cdac_spi_write(xspi, CDAC_SPI_BAUD, baud_rate_val << 4);
+	}
+}
+
+static inline void cdac_spi_rx(struct cdac_spi *xspi)
+{
+	unsigned int len = xspi->current_transfer->len;
+	unsigned int remaining = xspi->rx_bytes_rem;
+	u8  *rx_buf = xspi->current_transfer->rx_buf;
+
+	if (!remaining)
+		return;
+
+	rx_buf[len - remaining] = cdac_spi_read(xspi, CDAC_SPI_RXD);
+	xspi->rx_bytes_rem--;
+}
+
+/**
+ * cdac_spi_irq - Interrupt service routine of the SPI controller
+ * Return:	IRQ_HANDLED when handled; IRQ_NONE otherwise.
+ */
+static irqreturn_t cdac_spi_irq(int irq, void *dev_id)
+{
+	struct spi_master *master;
+	struct cdac_spi *xspi;
+	u32 ctrl_reg;
+
+	master = dev_id; // controller
+	xspi = spi_master_get_devdata(master);
+
+	spin_lock(&xspi->lock);
+	xspi->status = cdac_spi_read(xspi, CDAC_SPI_STAT);
+
+	if (xspi->status & CDAC_SPI_OVERRUN) {
+		xspi->transfer_failed = true;
+		ctrl_reg = cdac_spi_read(xspi, CDAC_SPI_CR);
+		cdac_spi_write(xspi, CDAC_SPI_CR, ctrl_reg & ~CDAC_SPI_RX_INTR); // Disable RX interrupt.
+		spin_unlock(&xspi->lock);
+		return IRQ_HANDLED;
+	}
+
+	if (xspi->status & CDAC_SPI_RX_INT_STAT) {
+		cdac_spi_rx(xspi);
+		spin_unlock(&xspi->lock);
+		return IRQ_HANDLED;
+	}
+
+	spin_unlock(&xspi->lock);
+	return IRQ_NONE;
+}
+
+//set up the controller to transfer a single message.
+static int cdac_prepare_message(struct spi_master *master,
+				struct spi_message *msg)
+{
+	u32 ctrl_reg;
+	struct cdac_spi *xspi = spi_master_get_devdata(master);
+	struct spi_device *spi = msg->spi;
+	u32 *controller_state = spi->controller_state;
+	/* Wait while SPI busy */
+	do {
+		xspi->status = cdac_spi_read(xspi, CDAC_SPI_STAT);
+	} while (xspi->status & CDAC_SPI_TX_BUSY);
+
+	ctrl_reg = (*controller_state | CDAC_SPI_RX_INTR);
+	cdac_spi_write(xspi, CDAC_SPI_CR, ctrl_reg);
+	return 0;
+}
+//undo any work done by prepare_message.
+static int cdac_unprepare_message(struct spi_master *master,
+				struct spi_message *msg)
+{
+	u32 ctrl_reg;
+	struct cdac_spi *xspi = spi_master_get_devdata(master);
+	struct spi_device *spi = msg->spi;
+	u32 *controller_state = spi->controller_state;
+	ctrl_reg = (*controller_state & ~CDAC_SPI_RX_INTR);
+	cdac_spi_write(xspi, CDAC_SPI_CR, ctrl_reg);
+	return 0;
+}
+
+
+static inline void cdac_spi_tx(struct cdac_spi *xspi)
+{
+	unsigned int len = xspi->current_transfer->len;
+	unsigned int remaining = xspi->tx_bytes_rem;
+	const u8  *tx_buf = xspi->current_transfer->tx_buf;
+	if (!remaining){
+		return;
+	}
+
+	if (((xspi->status & CDAC_SPI_TX_BUSY)==0) && (xspi->status & CDAC_SPI_TX_STAT)){
+			cdac_spi_write(xspi, CDAC_SPI_TXD, tx_buf[len - remaining]);
+			xspi->tx_bytes_rem--;
+	}
+}
+
+/**
+ * cdac_transfer_one -
+ */
+static int cdac_transfer_one(struct spi_master *master,
+			     struct spi_device *spi,
+			     struct spi_transfer *transfer)
+{
+	struct cdac_spi *xspi = spi_master_get_devdata(master);
+
+	cdac_spi_config_clock_freq(spi, transfer);
+
+	xspi->transfer_failed = false;
+	xspi->current_transfer = transfer;
+	xspi->tx_bytes_rem = transfer->len;
+	xspi->rx_bytes_rem = transfer->len;
+
+	while ((xspi->tx_bytes_rem || xspi->rx_bytes_rem) && !xspi->transfer_failed) {
+		xspi->status = cdac_spi_read(xspi, CDAC_SPI_STAT);
+		if (xspi->status & CDAC_SPI_OVERRUN) {
+			xspi->transfer_failed = true;
+		}
+		if (xspi->status & CDAC_SPI_RX_STAT) {
+			cdac_spi_rx(xspi);
+		}
+		cdac_spi_tx(xspi);
+		cpu_relax();
+	}
+
+	if (xspi->transfer_failed) {
+		return -EIO;
+	}
+
+	return 0;
+}
+/*
+updates the device mode and clocking records used by a device’s SPI controller; protocol code may call this.
+This must fail if an unrecognized or unsupported mode is requested.
+It’s always safe to call this unless transfers are pending on the device whose settings are being modified.
+*/
+static int cdac_spi_setup(struct spi_device *spi)
+{
+	u32 ctrl_reg;
+	int ret = -EINVAL;
+	u32 *cdac_controller_state = spi->controller_state;
+	struct cdac_spi *xspi = spi_master_get_devdata(spi->master);
+
+	ctrl_reg = cdac_spi_read(xspi, CDAC_SPI_CR);
+
+	if (spi->mode & SPI_CPOL)
+		ctrl_reg |= CDAC_SPI_CPOL;
+	else
+		ctrl_reg &= ~CDAC_SPI_CPOL;
+
+	if (spi->mode & SPI_CPHA)
+		ctrl_reg |= CDAC_SPI_CPHA;
+	else
+		ctrl_reg &= ~CDAC_SPI_CPHA;
+	if (spi->mode & SPI_LSB_FIRST)
+		ctrl_reg |= CDAC_SPI_LSB;
+	else
+		ctrl_reg &= ~CDAC_SPI_LSB;
+
+	if (spi->mode & SPI_LOOP){
+		return ret;
+	}
+
+	/* setting chip select */
+	ctrl_reg = (ctrl_reg & SPI_CHIP_SEL_MASK) | (spi->chip_select & 0x3);
+
+	// this seems to be the first time we're here
+	if (!cdac_controller_state) {
+		cdac_controller_state = kzalloc(sizeof(*cdac_controller_state), GFP_KERNEL);
+		if (!cdac_controller_state)
+			return -ENOMEM;
+		spi->controller_state = cdac_controller_state;
+	}
+	*cdac_controller_state = ctrl_reg;
+	cdac_spi_write(xspi, CDAC_SPI_CR, ctrl_reg);
+	return 0;
+}
+
+static void cdac_spi_cleanup(struct spi_device *spi)
+{
+	struct cdac_spi_device_data *cdac_spi_data = spi_get_ctldata(spi);
+	if (cdac_spi_data) {
+		if (cdac_spi_data->gpio_requested)
+			gpio_free(spi->cs_gpio);
+		kfree(cdac_spi_data);
+		spi_set_ctldata(spi, NULL);
+	}
+}
+
+/*
+ * cdac_spi_probe - Probe method for the SPI driver
+ * This function initializes the driver data structures and the hardware.
+ */
+static int cdac_spi_probe(struct platform_device *pdev)
+{
+	int ret = 0, irq;
+	struct spi_master *master;
+	struct cdac_spi *xspi;
+	struct resource *res;
+	u32 num_cs,max_freq;
+
+	master = spi_alloc_master(&pdev->dev, sizeof(*xspi));
+	if (!master)
+		return -ENOMEM;
+
+	xspi = spi_master_get_devdata(master);
+	master->dev.of_node = pdev->dev.of_node;
+	platform_set_drvdata(pdev, master);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	xspi->regs = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(xspi->regs)) {
+		ret = PTR_ERR(xspi->regs);
+		goto remove_master;
+	}
+
+	xspi->spi_clock = devm_clk_get(&pdev->dev, "spi_clock");
+	if (IS_ERR(xspi->spi_clock)) {
+		dev_err(&pdev->dev, "spi_clock clock not found.\n");
+		ret = PTR_ERR(xspi->spi_clock);
+		goto remove_master;
+	}
+
+	ret = clk_prepare_enable(xspi->spi_clock);
+	if (ret) {
+		dev_err(&pdev->dev, "Unable to enable device clock.\n");
+		goto remove_master;
+	}
+
+	xspi->speed_hz = clk_get_rate(xspi->spi_clock) / 4;
+
+	/* This is optional parameter */
+	if (of_property_read_u32(pdev->dev.of_node, "spi-max-frequency", &max_freq))
+		max_freq = xspi->speed_hz;
+
+	if (max_freq >  xspi->speed_hz) {
+			dev_err(&pdev->dev, "invalid clock frequency %d\n", max_freq);
+			return -ENXIO;
+	}
+
+	ret = of_property_read_u32(pdev->dev.of_node, "num-cs", &num_cs);
+	if (ret < 0)
+		master->num_chipselect = CDAC_SPI_DEFAULT_NUM_CS;
+	else
+		master->num_chipselect = num_cs;
+
+	ret = of_property_read_u32(pdev->dev.of_node, "is-decoded-cs",
+				   &xspi->is_decoded_cs);
+	if (ret < 0)
+		xspi->is_decoded_cs = 0;
+
+	/* SPI controller initializations */
+	cdac_spi_init_hw(xspi);
+
+	irq = platform_get_irq(pdev, 0);
+	if (irq <= 0) {
+		ret = -ENXIO;
+		dev_err(&pdev->dev, "irq number is invalid\n");
+		goto clk_dis_all;
+	}
+
+	ret = devm_request_irq(&pdev->dev, irq, cdac_spi_irq,
+			       0, pdev->name, master);
+	if (ret != 0) {
+		ret = -ENXIO;
+		dev_err(&pdev->dev, "request_irq failed\n");
+		goto clk_dis_all;
+	}
+	master->prepare_message = cdac_prepare_message;
+	master->unprepare_message = cdac_unprepare_message;
+	master->transfer_one = cdac_transfer_one;
+	master->set_cs = cdac_spi_chipselect;
+	master->setup = cdac_spi_setup;
+	master->cleanup = cdac_spi_cleanup;
+	master->auto_runtime_pm = true;
+	master->mode_bits = SPI_CPOL | SPI_CPHA;
+	master->flags = SPI_MASTER_MUST_RX | SPI_MASTER_MUST_TX;
+	master->max_speed_hz = max_freq;
+	master->bits_per_word_mask = SPI_BPW_MASK(8);
+
+	ret = spi_register_master(master);
+	if (ret) {
+		dev_err(&pdev->dev, "spi_register_master failed\n");
+		goto clk_dis_all;
+	}
+
+	dev_info(&pdev->dev, "CDAC SPI Master Controller at 0x%08lx (irq %d)\n",(unsigned long)res->start, irq);
+	return ret;
+
+clk_dis_all:
+	clk_disable_unprepare(xspi->spi_clock);
+remove_master:
+	spi_master_put(master);
+	return ret;
+}
+
+/**
+ * cdac_spi_remove - Remove method for the SPI driver
+ * @pdev:	Pointer to the platform_device structure
+ * Return:	0 on success and error value on error
+ */
+static int cdac_spi_remove(struct platform_device *pdev)
+{
+	struct spi_master *master = platform_get_drvdata(pdev);
+	struct cdac_spi *xspi = spi_master_get_devdata(master);
+	clk_disable_unprepare(xspi->spi_clock);
+	spi_unregister_master(master);
+	return 0;
+}
+
+static const struct of_device_id cdac_spi_of_match[] = {
+	{ .compatible = "cdac,spi" },
+	{ /* end of table */ }
+};
+MODULE_DEVICE_TABLE(of, cdac_spi_of_match);
+
+/* cdac_spi_driver - This structure defines the SPI subsystem platform driver */
+static struct platform_driver cdac_spi_driver = {
+	.probe	= cdac_spi_probe,
+	.remove	= cdac_spi_remove,
+	.driver = {
+		.name = CDAC_SPI_NAME,
+		.of_match_table = cdac_spi_of_match,
+	},
+};
+
+module_platform_driver(cdac_spi_driver);
+
+MODULE_DESCRIPTION("C-DAC Thiruvananthapuram SPI Controller Driver");
+MODULE_AUTHOR("Anoop Varghese <vanoop@cdac.in>");
+MODULE_LICENSE("GPL v2");
diff -Naur linux-5.4.1/drivers/spi/spidev.c linux-5.4.1_modified/drivers/spi/spidev.c
--- linux-5.4.1/drivers/spi/spidev.c	2019-11-29 14:40:32.000000000 +0530
+++ linux-5.4.1_modified/drivers/spi/spidev.c	2025-08-08 10:40:35.456589085 +0530
@@ -665,6 +665,7 @@
 	{ .compatible = "lwn,bk4" },
 	{ .compatible = "dh,dhcom-board" },
 	{ .compatible = "menlo,m53cpld" },
+	{ .compatible = "cdac,spidev" },
 	{},
 };
 MODULE_DEVICE_TABLE(of, spidev_dt_ids);
diff -Naur linux-5.4.1/drivers/usb/Kconfig linux-5.4.1_modified/drivers/usb/Kconfig
--- linux-5.4.1/drivers/usb/Kconfig	2019-11-29 14:40:32.000000000 +0530
+++ linux-5.4.1_modified/drivers/usb/Kconfig	2025-08-08 10:40:35.456811603 +0530
@@ -125,6 +125,8 @@
 
 source "drivers/usb/isp1760/Kconfig"
 
+source "drivers/usb/vega/Kconfig"
+
 comment "USB port drivers"
 
 if USB
diff -Naur linux-5.4.1/drivers/usb/Makefile linux-5.4.1_modified/drivers/usb/Makefile
--- linux-5.4.1/drivers/usb/Makefile	2019-11-29 14:40:32.000000000 +0530
+++ linux-5.4.1_modified/drivers/usb/Makefile	2025-08-08 10:40:35.456931327 +0530
@@ -12,6 +12,7 @@
 obj-$(CONFIG_USB_DWC3)		+= dwc3/
 obj-$(CONFIG_USB_DWC2)		+= dwc2/
 obj-$(CONFIG_USB_ISP1760)	+= isp1760/
+obj-$(CONFIG_USB_VEGA)		+= vega/
 
 obj-$(CONFIG_USB_CDNS3)		+= cdns3/
 
diff -Naur linux-5.4.1/drivers/usb/vega/Kconfig linux-5.4.1_modified/drivers/usb/vega/Kconfig
--- linux-5.4.1/drivers/usb/vega/Kconfig	1970-01-01 05:30:00.000000000 +0530
+++ linux-5.4.1_modified/drivers/usb/vega/Kconfig	2025-08-08 10:40:35.457073444 +0530
@@ -0,0 +1,31 @@
+config USB_VEGA
+	tristate "VEGA USB support"	
+	select USB_COMMON
+	---help---
+
+	  If unsure, say N.
+
+config USB_VEGA_HCD
+	tristate "VEGA USB HCD Supported"
+	depends on USB_VEGA && USB 
+	help
+	  Say Y or M here if your system as an VEGA USB host controller
+	 
+	  To compile this driver as a module, choose M here: the
+	  module will be called vega-usb-hcd.
+	  
+config USB_VEGA_UDC
+	tristate "VEGA USB UDC Supported"
+	depends on USB_VEGA && USB_GADGET
+	help
+	  Say Y or M here if your system as an VEGA USB device controller
+	 
+	  To compile this driver as a module, choose M here: the
+	  module will be called vega-usb-udc.
+	  
+	  
+
+	  
+
+
+
diff -Naur linux-5.4.1/drivers/usb/vega/Makefile linux-5.4.1_modified/drivers/usb/vega/Makefile
--- linux-5.4.1/drivers/usb/vega/Makefile	1970-01-01 05:30:00.000000000 +0530
+++ linux-5.4.1_modified/drivers/usb/vega/Makefile	2025-08-08 10:40:35.457132965 +0530
@@ -0,0 +1,12 @@
+# SPDX-License-Identifier: GPL-2.0
+
+
+obj-$(CONFIG_USB_VEGA) += usb-vega-core.o
+usb-vega-core-y :=vega-core.o
+
+obj-$(CONFIG_USB_VEGA_HCD) += usb-vega-hcd.o
+usb-vega-hcd-y :=vega-hcd.o
+
+obj-$(CONFIG_USB_VEGA_UDC) += usb-vega-udc.o
+usb-vega-udc-y :=vega-udc.o
+
diff -Naur linux-5.4.1/drivers/usb/vega/vega-core.c linux-5.4.1_modified/drivers/usb/vega/vega-core.c
--- linux-5.4.1/drivers/usb/vega/vega-core.c	1970-01-01 05:30:00.000000000 +0530
+++ linux-5.4.1_modified/drivers/usb/vega/vega-core.c	2025-08-08 10:40:35.457201414 +0530
@@ -0,0 +1,154 @@
+#include <linux/err.h>
+#include <linux/signal.h>
+#include <linux/usb.h>
+#include <linux/usb/hcd.h>
+#include <linux/of.h>
+#include <linux/of_platform.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+#include <linux/gpio/consumer.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <asm/unaligned.h>
+#include <asm/cacheflush.h>
+
+#include "vega-regs.h"
+#include "vega-hcd.h"
+#include "vega-udc.h"
+#include "vega-core.h"
+
+
+int vega_usb_register(struct resource *mem, int irq, unsigned long irqflags,
+		     struct device *dev, unsigned int devflags)
+{
+	struct vega_device *vega_usb;
+
+	int ret;
+
+	
+	/* prevent usb-core allocating DMA pages */
+	dev->dma_mask = NULL;
+
+	vega_usb = devm_kzalloc(dev, sizeof(*vega_usb), GFP_KERNEL);
+	if (!vega_usb)
+		return -ENOMEM;
+
+	vega_usb->dev = dev;
+	vega_usb->devflags = devflags;
+
+	vega_usb->rst_gpio = devm_gpiod_get_optional(dev, NULL, GPIOD_OUT_HIGH);
+	if (IS_ERR(vega_usb->rst_gpio))
+		return PTR_ERR(vega_usb->rst_gpio);
+
+	vega_usb->regs = devm_ioremap_resource(dev, mem);
+	if (IS_ERR(vega_usb->regs))
+		return PTR_ERR(vega_usb->regs);
+
+	vega_init_core(vega_usb);
+	
+	//ret = vega_hcd_register(&vega_host->hcd, vega_host->regs, mem, irq,
+		//			irqflags | IRQF_SHARED, dev);
+
+	
+    
+    	if (IS_ENABLED(CONFIG_USB_VEGA_HCD) && !usb_disabled()) {
+		ret = vega_hcd_register(&vega_usb->hcd, vega_usb->regs, mem, irq,
+					   irqflags | IRQF_SHARED, dev);
+		if (ret < 0)
+			return ret;
+	}
+
+	if (IS_ENABLED(CONFIG_USB_VEGA_UDC) && !udc_disabled) {
+		ret = vega_udc_register(&vega_usb->udc, irq, irqflags);
+		if (ret < 0) {
+			vega_hcd_unregister(&vega_usb->hcd);
+			return ret;
+		}
+	}
+
+
+
+
+
+
+	if (ret < 0)
+		return ret;	
+
+	dev_set_drvdata(dev, vega_host);
+
+	return 0;
+}
+
+
+
+
+static int vega_usb_probe(struct platform_device *pdev)
+{
+	unsigned long irqflags;
+	unsigned int devflags = 0;
+	struct resource *mem_res;
+	struct resource *irq_res;
+	int ret;
+	
+
+	vega_dbg(&pdev->dev, "<***********************vega_usb_probe***********************>\n");
+
+	mem_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+
+	irq_res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	if (!irq_res) {
+		pr_warn("vega: IRQ resource not available\n");
+		return -ENODEV;
+	}
+	irqflags = irq_res->flags & IRQF_TRIGGER_MASK;
+	
+	
+
+	ret = vega_register(mem_res, irq_res->start, irqflags, &pdev->dev,
+			       devflags);
+	if (ret < 0)
+		return ret;
+
+
+	pr_info("VEGA USB device initialised\n");
+
+	return 0;
+}
+
+
+
+
+
+static int vega_usb_remove(struct platform_device *op)
+{
+	struct usb_hcd *hcd = platform_get_drvdata(op);
+
+	pr_err( "Stopping VEGA USB Controller\n");
+
+	usb_remove_hcd(hcd);
+
+	usb_put_hcd(hcd);
+
+	return 0;
+}
+
+
+
+
+
+static const struct of_device_id vega_usb_of_match[] = {
+		{.compatible = "cdac,vega-usb",},
+	{},
+};
+MODULE_DEVICE_TABLE(of, vega_hcd_of_match);
+
+static struct platform_driver vega_usb_of_driver = {
+	.probe		= vega_usb_probe,
+	.remove	= vega_usb_remove,
+	.shutdown	= usb_hcd_platform_shutdown,
+	.driver = {
+		.name = "vega-usb",
+		.of_match_table = vega_usb_of_match,
+	},
+};
diff -Naur linux-5.4.1/drivers/usb/vega/vega-core.h linux-5.4.1_modified/drivers/usb/vega/vega-core.h
--- linux-5.4.1/drivers/usb/vega/vega-core.h	1970-01-01 05:30:00.000000000 +0530
+++ linux-5.4.1_modified/drivers/usb/vega/vega-core.h	2025-08-08 10:40:35.457290200 +0530
@@ -0,0 +1,46 @@
+#ifndef _VEGA_CORE_H_
+#define _VEGA_CORE_H_
+
+#include "vega-hcd.h"
+#include "vega-udc.h"
+
+struct vega_hcd;
+
+
+struct vega_device {
+	struct device *dev;
+
+	void __iomem *regs;
+	unsigned int devflags;
+	struct gpio_desc *rst_gpio;
+
+	struct vega_hcd hcd;
+	struct vega_udc udc;
+};
+
+
+int vega_usb_register(struct resource *mem, int irq, unsigned long irqflags,
+		     struct device *dev, unsigned int devflags);
+
+
+
+
+static int vega_usb_probe(struct platform_device *pdev);
+
+
+
+
+
+static int vega_usb_remove(struct platform_device *op);
+
+
+
+
+
+
+#endif /* _VEGA_CORE_H_ */
+
+
+
+
+
diff -Naur linux-5.4.1/drivers/usb/vega/vega-hcd_1time_not_ok.c linux-5.4.1_modified/drivers/usb/vega/vega-hcd_1time_not_ok.c
--- linux-5.4.1/drivers/usb/vega/vega-hcd_1time_not_ok.c	1970-01-01 05:30:00.000000000 +0530
+++ linux-5.4.1_modified/drivers/usb/vega/vega-hcd_1time_not_ok.c	2025-08-08 10:40:35.457363588 +0530
@@ -0,0 +1,3442 @@
+#include <linux/err.h>
+#include <linux/signal.h>
+#include <linux/usb.h>
+#include <linux/usb/hcd.h>
+#include <linux/of.h>
+#include <linux/of_platform.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+#include <linux/gpio/consumer.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <asm/unaligned.h>
+#include <asm/cacheflush.h>
+
+#include "vega-regs.h"
+#include "vega-hcd.h"
+
+unsigned int atl_skipmap_global;
+unsigned int int_skipmap_global;
+unsigned int iso_skipmap_global;
+//#define DEBUG_VEGA
+
+#ifdef DEBUG_VEGA
+	#define vega_dbg(...)		dev_err(__VA_ARGS__)
+	#define vega_pr_err(...) 	pr_err(__VA_ARGS__)
+	#define vega_dbg1(...)		dev_err(__VA_ARGS__)
+	#define vega_dbg2(...)		dev_err(__VA_ARGS__)
+	#define vega_dbg3(...)		dev_err(__VA_ARGS__)
+	#define vega_dbg4(...)		dev_err(__VA_ARGS__)
+	#define vega_dbg5(...)		dev_err(__VA_ARGS__)
+	#define vega_probe_dbg(...)	dev_err(__VA_ARGS__)
+#else
+	#define vega_dbg(...)		//dev_err(__VA_ARGS__)
+	#define vega_pr_err(...) 	 //pr_err(__VA_ARGS__)
+	#define vega_dbg1(...)		//dev_err(__VA_ARGS__)
+	#define vega_dbg2(...)		//dev_err(__VA_ARGS__)
+	#define vega_dbg3(...)		//dev_err(__VA_ARGS__)
+	#define vega_dbg4(...)		//dev_err(__VA_ARGS__)
+	#define vega_dbg5(...)		//dev_err(__VA_ARGS__)
+	#define vega_hub_cotrol_dbg(...)	//dev_err(__VA_ARGS__)
+	#define vega_hub_cotrol_dbg1(...)	dev_err(__VA_ARGS__)
+	#define vega_handle_ptd_dbg(...)	//dev_err(__VA_ARGS__)
+	#define vega_probe_dbg(...)		//dev_err(__VA_ARGS__)
+	#define vega_mem_io_dbg(...) 		//pr_err(__VA_ARGS__)
+
+	//#define dev_err(...)	(0)
+	//#define pr_err(...)	(0)
+#endif
+
+//int unskip_check=0; //cdac-test-pid
+//int done_check=0; //cdac-test-pid
+//int stall_check=0; ////cdac-test-pid
+//int stall_count=0; ////cdac-test-pid
+
+volatile int device_disconnected=0;
+
+u32 gframe_index;
+
+int vega_hub_speed;
+
+
+static inline struct vega_hcd *hcd_to_priv(struct usb_hcd *hcd)
+{
+	return *(struct vega_hcd **)hcd->hcd_priv;
+}
+
+/* Philips Proprietary Transfer Descriptor (PTD) */
+typedef __u32 __bitwise __dw;
+struct ptd {
+	__dw dw0;
+	__dw dw1;
+	__dw dw2;
+	__dw dw3;
+	__dw dw4;
+	__dw dw5;
+	__dw dw6;
+	__dw dw7;
+};
+#define PTD_OFFSET		0x0400
+#define ISO_PTD_OFFSET		0x0400
+#define INT_PTD_OFFSET		0x0800
+#define ATL_PTD_OFFSET		0x0c00
+#define PAYLOAD_OFFSET		0x1000
+
+static struct kmem_cache *qtd_cachep;
+static struct kmem_cache *qh_cachep;
+static struct kmem_cache *urb_listitem_cachep;
+
+struct urb_listitem {
+	struct list_head urb_list;
+	struct urb *urb;
+};
+
+struct vega_qtd {
+	u8 packet_type;
+	void *data_buffer;
+	u32 payload_addr;
+
+	/* the rest is HCD-private */
+	struct list_head qtd_list;
+	struct urb *urb;
+	size_t length;
+	size_t actual_length;
+
+	/* QTD_ENQUEUED:	waiting for transfer (inactive) */
+	/* QTD_PAYLOAD_ALLOC:	chip mem has been allocated for payload */
+	/* QTD_XFER_STARTED:	valid ptd has been written to isp176x - only
+				interrupt handler may touch this qtd! */
+	/* QTD_XFER_COMPLETE:	payload has been transferred successfully */
+	/* QTD_RETIRE:		transfer error/abort qtd */
+#define QTD_ENQUEUED		0
+#define QTD_PAYLOAD_ALLOC	1
+#define QTD_XFER_STARTED	2
+#define QTD_XFER_COMPLETE	3
+#define QTD_RETIRE		4
+	u32 status;
+};
+
+/* Queue head, one for each active endpoint */
+struct vega_qh {
+	struct list_head qh_list;
+	struct list_head qtd_list;
+	u32 toggle;
+	u32 ping;
+	int slot;
+	int tt_buffer_dirty;	/* See USB2.0 spec section 11.17.5 */
+};
+
+#define PTD_STATE_QTD_DONE	1
+#define PTD_STATE_QTD_RELOAD	2
+#define PTD_STATE_URB_RETIRE	3
+
+/* ATL */
+/* DW0 */
+#define DW0_VALID_BIT			DW0_ACTIVE_BIT
+#define FROM_DW0_VALID(x)		FROM_DW0_ACTIVE(x)
+#define TO_DW1_LENGTH(x)		(((u32) x) << 3)
+#define TO_DW1_MAXPACKET(x)		(((u32) x) << 17)
+//#define TO_DW0_MULTI(x)		(((u32) x) << 29)
+#define TO_DW1_ENDPOINT_0(x)		(((u32)	x) << 31) //Bit [0]
+#define FROM_DW1_ENDPOINT_0(x)	((((u32)	x) >> 31) & 1) //Bit [0]
+
+#define TO_DW0_ENDPOINT_1_3(x)	(((u32)	x) << 0) //Bits [1:3]
+#define FROM_DW0_ENDPOINT_1_3(x)	((((u32)	x) >> 0) & 7) //Bits [1:3]
+
+/* DW1 */
+#define TO_DW0_DEVICE_ADDR(x)		(((u32) x) << 3)
+#define TO_DW0_PID_TOKEN(x)		(((u32) x) << 10)
+#define FROM_DW0_PID_TOKEN(x)		((((u32) x) >> 10) & 3)
+#define DW2_TRANS_ISO			((u32) 1 << 15)
+#define DW2_TRANS_BULK			((u32) 2 << 15)
+#define DW2_TRANS_INT			((u32) 3 << 15)
+
+#define FROM_DW2_EP_TYPE(x)		((((u32) x) >> 15) & 3)
+
+
+#define DW3_TRANS_SPLIT		((u32) 1 << 0)
+#define DW3_SE_USB_LOSPEED		((u32) 2 << 2)
+#define TO_DW3_PORT_NUM(x)		(((u32) x) << 4)
+#define TO_DW3_HUB_NUM(x)		(((u32) x) << 11)
+
+
+/* DW2 */
+#define TO_DW2_DATA_START_ADDR(x)	(((u32) x) << 0)
+#define TO_DW0_RL(x)			((x) << 16)
+#define FROM_DW0_RL(x)			(((x) >> 16) & 0xf)
+/* DW3 */
+#define FROM_DW2_NRBYTESTRANSFERRED(x)		(((x)>> 17) & 0x3FFF)
+#define FROM_DW2_SCS_NRBYTESTRANSFERRED(x)	(((x)>> 17) & 0x07ff)
+#define TO_DW0_NAKCOUNT(x)		((x) << 12)
+#define FROM_DW0_NAKCOUNT(x)		(((x) >> 12) & 0xf)
+#define TO_DW1_CERR(x)			((x) << 0)
+#define FROM_DW1_CERR(x)		(((x) >> 0) & 0x3)
+#define TO_DW2_DATA_TOGGLE(x)		((x) << 31)
+#define FROM_DW2_DATA_TOGGLE(x)	(((x) >> 31) & 0x1)
+#define TO_DW0_PING(x)			((x) << 24)
+#define FROM_DW0_PING(x)		(((x) >> 24) & 0x1)
+#define DW0_ERROR_BIT			(1 << 28)
+//#define DW3_BABBLE_BIT			(1 << 29)
+#define DW0_HALT_BIT			(1 << 30)
+#define DW0_ACTIVE_BIT			(1 << 31)
+#define FROM_DW0_ACTIVE(x)		(((x) >> 31) & 0x01)
+
+#define INT_UNDERRUN			(1 << 2)
+#define INT_BABBLE			(1 << 1)
+#define INT_EXACT			(1 << 0)
+
+#define SETUP_PID	(2)
+#define IN_PID		(1)
+#define OUT_PID	(0)
+
+/* Errata 1 */
+#define RL_COUNTER	(0)
+#define NAK_COUNTER	(0)
+
+#define RL_COUNTER_ATL		(10)
+#define NAK_COUNTER_ATL	(10)
+
+#define ERR_COUNTER	(3)
+
+
+#define SLOT_TIMEOUT 300
+#define SLOT_CHECK_PERIOD 10000
+static struct timer_list errata2_timer;
+static struct usb_hcd *errata2_timer_hcd;
+
+static void handle_done_ptds(struct usb_hcd *hcd);
+
+/*
+ * Access functions for isp176x memory (offset >= 0x0400).
+ *
+ * bank_reads8() reads memory locations prefetched by an earlier write to
+ * HC_MEMORY_REG (see isp176x datasheet). Unless you want to do fancy multi-
+ * bank optimizations, you should use the more generic mem_reads8() below.
+ *
+ * For access to ptd memory, use the specialized ptd_read() and ptd_write()
+ * below.
+ *
+ * These functions copy via MMIO data to/from the device. memcpy_{to|from}io()
+ * doesn't quite work because some people have to enforce 32-bit access
+ */
+static void bank_reads8(void __iomem *src_base, u32 src_offset, u32 bank_addr,
+							__u32 *dst, u32 bytes)
+{
+	__u32 __iomem *src;
+	u32 val;
+	__u8 *src_byteptr;
+	__u8 *dst_byteptr;
+
+	//pr_err("bank_reads8\n");
+	/*vega_pr_err("src_base : %lx\n",src_base);
+	vega_pr_err("src_offset : %x\n",src_offset);
+	vega_pr_err("mem_reads8 : %lx\n", dst);*/
+
+	src = src_base + (src_offset);
+
+	if (src_offset < PAYLOAD_OFFSET) { //TDs area
+		while (bytes >= 4) {
+			*dst = le32_to_cpu(__raw_readl(src));
+			bytes -= 4;
+			//vega_mem_io_dbg("bank_reads8 : %x\n",*dst);
+			src++;
+			dst++;
+			
+		}
+	} else { //Payload area
+		while (bytes >= 4) {
+	
+			*dst = __raw_readl(src);
+			bytes -= 4;
+			//vega_mem_io_dbg("bank_reads8 : %x\n",*dst);
+			src++;
+			dst++;
+		}
+	}
+
+	if (!bytes)
+		return;
+
+	/* in case we have 3, 2 or 1 by left. The dst buffer may not be fully
+	 * allocated.
+	 */
+	if (src_offset < PAYLOAD_OFFSET)
+		val = le32_to_cpu(__raw_readl(src)); //TDs
+	else
+		val = __raw_readl(src); //Payload
+
+	dst_byteptr = (void *) dst;
+	src_byteptr = (void *) &val;
+	while (bytes > 0) {
+		*dst_byteptr = *src_byteptr;
+
+		//vega_mem_io_dbg("bank_reads8 : %x\n",*dst_byteptr);
+		dst_byteptr++;
+		src_byteptr++;
+		bytes--;
+	}
+}
+
+static void mem_reads8(void __iomem *src_base, u32 src_offset, void *dst,
+								u32 bytes)
+{
+
+	/*vega_pr_err("src_base : %lx\n",src_base);
+	vega_pr_err("src_offset : %x\n",src_offset);
+	vega_pr_err("mem_reads8 : %lx\n", dst);*/
+	//pr_err("mem_reads8\n");
+
+	//vega_write32(src_base, HC_MEMORY_REG, src_offset + ISP_BANK(0));
+	//ndelay(90);
+	bank_reads8(src_base, src_offset, ISP_BANK(0), dst, bytes);
+}
+
+static void mem_writes8(void __iomem *dst_base, u32 dst_offset,
+						__u32 const *src, u32 bytes)
+{
+	__u32 __iomem *dst;
+
+	dst = dst_base + dst_offset;
+
+	//pr_err("mem_writes8\n");
+	//vega_pr_err("dst_base : %lx\n",dst_base);
+	//pr_err("dst_offset : %x\n",dst_offset);
+
+	if (dst_offset < PAYLOAD_OFFSET) {
+		while (bytes >= 4) {
+			//__raw_writel(cpu_to_le32(*src), dst);
+			__raw_writel(*src, dst);//FIXME
+			bytes -= 4;
+			//vega_mem_io_dbg("mem_writes8 : %x\n",*src);
+			src++;
+			dst++;
+		}
+	} else {
+	
+		if(bytes>8192)
+			pr_err("bytes >8K\n");
+		while (bytes >= 4) {
+			__raw_writel(*src, dst);
+			//vega_mem_io_dbg("mem_writes8 : %x\n",*src);
+			bytes -= 4;
+			
+			
+			src++;
+			dst++;
+		}
+	}
+
+	if (!bytes)
+		return;
+	/* in case we have 3, 2 or 1 bytes left. The buffer is allocated and the
+	 * extra bytes should not be read by the HW.
+	 */
+
+	if (dst_offset < PAYLOAD_OFFSET){
+		//__raw_writel(cpu_to_le32(*src), dst);
+		__raw_writel(*src, dst);//FIXME
+		}
+	else
+		__raw_writel(*src, dst);
+}
+
+/*
+ * Read and write ptds. 'ptd_offset' should be one of ISO_PTD_OFFSET,
+ * INT_PTD_OFFSET, and ATL_PTD_OFFSET. 'slot' should be less than 32.
+ */
+static void ptd_read(void __iomem *base, u32 ptd_offset, u32 slot,
+								struct ptd *ptd)
+{
+	//vega_write32(base, HC_MEMORY_REG,	ISP_BANK(0) + ptd_offset + slot*sizeof(*ptd));
+
+	//ndelay(90);
+	bank_reads8(base, ptd_offset + slot*sizeof(*ptd), ISP_BANK(0),
+						(void *) ptd, sizeof(*ptd));
+
+	if(slot>7)
+	{
+		pr_err("SLOT > 7\n");
+	}	
+	if(slot!=0)
+	{
+		//pr_err("W-SLOT ! 0\n");
+		//while(1);
+	}	
+	
+	/*pr_err("------------RD------------\n");
+	pr_err("Slot : %d\n",slot);
+	pr_err("dw0 : %x\n",ptd->dw0);
+	pr_err("dw1 : %x\n",ptd->dw1);
+	pr_err("dw2 : %x\n",ptd->dw2);
+	pr_err("dw3 : %x\n",ptd->dw3);
+	pr_err("dw4 : %x\n",ptd->dw4);
+	pr_err("dw5 : %x\n",ptd->dw5);
+	pr_err("dw6 : %x\n",ptd->dw6);
+	pr_err("dw7 : %x\n",ptd->dw7);
+	pr_err("++++++++++++RD++++++++++++\n");*/
+}
+
+static void ptd_write(void __iomem *base, u32 ptd_offset, u32 slot,
+								struct ptd *ptd)
+{
+
+	//if(unskip_check)	
+	//	pr_err("> unskip_check ptd_write\n");
+	/*if(ptd->dw3 !=0){
+		pr_err("------------WR------------\n");
+		pr_err("Slot : %d\n",slot);
+		pr_err("dw0 : %x\n",ptd->dw0);
+		pr_err("dw1 : %x\n",ptd->dw1);
+		pr_err("dw2 : %x\n",ptd->dw2);		
+		pr_err("dw3 : %x\n",ptd->dw3);
+		pr_err("dw4 : %x\n",ptd->dw4);
+		pr_err("dw5 : %x\n",ptd->dw5);
+		pr_err("dw6 : %x\n",ptd->dw6);
+		pr_err("dw7 : %x\n",ptd->dw7);
+		pr_err("++++++++++++WR++++++++++++\n");
+	}*/
+	mem_writes8(base, ptd_offset + slot*sizeof(*ptd) + sizeof(ptd->dw0),
+						&ptd->dw1, 7*sizeof(ptd->dw1));
+						
+						
+	//pr_err("W-SLOT %d\n", slot);					
+
+	if(slot>7)
+	{
+		pr_err("W-SLOT > 7\n");
+	}
+	
+	if(slot!=0)
+	{
+		//pr_err("W-SLOT ! 0\n");
+		//while(1);
+	}		
+	/* Make sure dw0 gets written last (after other dw's and after payload)
+	   since it contains the enable bit */
+	wmb();
+	mem_writes8(base, ptd_offset + slot*sizeof(*ptd), &ptd->dw0,
+							sizeof(ptd->dw0));
+}
+
+static void errata2_function(struct timer_list *unused)
+{
+	struct usb_hcd *hcd = errata2_timer_hcd;
+	struct vega_hcd *priv = hcd_to_priv(hcd);
+	int slot;
+	struct ptd ptd;
+	unsigned long spinflags;
+	
+	spin_lock_irqsave(&priv->lock, spinflags);
+	pr_err("ERRATA\n");
+	/*for (slot = 0; slot < 32; slot++)
+		if (priv->atl_slots[slot].qh && time_after(jiffies,
+					priv->atl_slots[slot].timestamp +
+					msecs_to_jiffies(SLOT_TIMEOUT))) {
+			ptd_read(hcd->regs, ATL_PTD_OFFSET, slot, &ptd);
+			if (!FROM_DW0_ACTIVE(ptd.dw0)) //!FROM_DW0_VALID(ptd.dw0) && FIXME
+				priv->atl_done_map |= 1 << slot;
+		}
+
+	if (priv->atl_done_map)
+		handle_done_ptds(hcd);*/
+
+	slot =0;
+	ptd_read(hcd->regs, ATL_PTD_OFFSET, slot, &ptd);
+
+
+	/*	priv->int_done_map |= 1; //vega_read32(hcd->regs, HC_INT_PTD_DONEMAP_REG);
+		priv->atl_done_map |= 1; //vega_read32(hcd->regs, HC_ATL_PTD_DONEMAP_REG);
+		vega_dbg1(hcd->self.controller,"priv->int_done_map %x >>>>>\n",priv->int_done_map);
+		vega_dbg1(hcd->self.controller,"priv->atl_done_map %x >>>>>\n",priv->atl_done_map);
+	*/
+
+		int temp = vega_read32(hcd->regs, HC_ATL_PTD_SKIPMAP_REG);
+		//dev_err(hcd->self.controller,"HC_ATL_PTD_SKIPMAP_REG %x >>>>>\n",temp);
+	
+		vega_write32(hcd->regs, HC_ATL_PTD_SKIPMAP_REG, 0xff);
+
+		ptd.dw0 = 0;
+		ptd_write(hcd->regs, ATL_PTD_OFFSET, slot, &ptd);
+
+		priv->atl_done_map |= 1; //vega_read32(hcd->regs, HC_ATL_PTD_DONEMAP_REG);
+		handle_done_ptds(hcd);
+
+	spin_unlock_irqrestore(&priv->lock, spinflags);
+
+	//errata2_timer.expires = jiffies + msecs_to_jiffies(SLOT_CHECK_PERIOD);
+	//add_timer(&errata2_timer);
+}
+
+
+
+/* memory management of the 15kb on the chip from 0x1000 to 0x4C00 */
+static void init_memory(struct vega_hcd *priv)
+{
+	int i, curr;
+	u32 payload_addr;
+
+	payload_addr = PAYLOAD_OFFSET;
+	for (i = 0; i < BLOCK_1_NUM; i++) {
+		priv->memory_pool[i].start = payload_addr;
+		priv->memory_pool[i].size = BLOCK_1_SIZE;
+		priv->memory_pool[i].free = 1;
+		payload_addr += priv->memory_pool[i].size;
+	}
+
+	curr = i;
+	for (i = 0; i < BLOCK_2_NUM; i++) {
+		priv->memory_pool[curr + i].start = payload_addr;
+		priv->memory_pool[curr + i].size = BLOCK_2_SIZE;
+		priv->memory_pool[curr + i].free = 1;
+		payload_addr += priv->memory_pool[curr + i].size;
+	}
+
+	curr = i;
+	for (i = 0; i < BLOCK_3_NUM; i++) {
+		priv->memory_pool[curr + i].start = payload_addr;
+		priv->memory_pool[curr + i].size = BLOCK_3_SIZE;
+		priv->memory_pool[curr + i].free = 1;
+		payload_addr += priv->memory_pool[curr + i].size;
+	}
+
+	WARN_ON(payload_addr - priv->memory_pool[0].start > PAYLOAD_AREA_SIZE);
+}
+
+static void alloc_mem(struct usb_hcd *hcd, struct vega_qtd *qtd)
+{
+	struct vega_hcd *priv = hcd_to_priv(hcd);
+	int i;
+
+	WARN_ON(qtd->payload_addr);
+
+	if (!qtd->length)
+		return;
+
+	for (i = 0; i < BLOCKS; i++) {
+		if (priv->memory_pool[i].size >= qtd->length &&
+				priv->memory_pool[i].free) {
+			priv->memory_pool[i].free = 0;
+			qtd->payload_addr = priv->memory_pool[i].start;
+			return;
+		}
+	}
+}
+
+static void free_mem(struct usb_hcd *hcd, struct vega_qtd *qtd)
+{
+	struct vega_hcd *priv = hcd_to_priv(hcd);
+	int i;
+
+	if (!qtd->payload_addr)
+		return;
+
+	for (i = 0; i < BLOCKS; i++) {
+		if (priv->memory_pool[i].start == qtd->payload_addr) {
+			WARN_ON(priv->memory_pool[i].free);
+			priv->memory_pool[i].free = 1;
+			qtd->payload_addr = 0;
+			return;
+		}
+	}
+
+	vega_dbg(hcd->self.controller, "%s: Invalid pointer: %08x\n",
+						__func__, qtd->payload_addr);
+	WARN_ON(1);
+	qtd->payload_addr = 0;
+}
+
+
+/*static u32 base_to_chip(u32 base)
+{
+	return ((base - 0x400) >> 3);
+}*/
+
+static int last_qtd_of_urb(struct vega_qtd *qtd, struct vega_qh *qh)
+{
+	struct urb *urb;
+
+	if (list_is_last(&qtd->qtd_list, &qh->qtd_list))
+		return 1;
+
+	urb = qtd->urb;
+	qtd = list_entry(qtd->qtd_list.next, typeof(*qtd), qtd_list);
+	return (qtd->urb != urb);
+}
+
+
+/* magic numbers that can affect system performance */
+#define	EHCI_TUNE_CERR		3	/* 0-3 qtd retries; 0 == don't stop */
+#define	EHCI_TUNE_RL_HS		4	/* nak throttle; see 4.9 */
+#define	EHCI_TUNE_RL_TT		0
+#define	EHCI_TUNE_MULT_HS	1	/* 1-3 transactions/uframe; 4.10.3 */
+#define	EHCI_TUNE_MULT_TT	1
+#define	EHCI_TUNE_FLS		2	/* (small) 256 frame schedule */
+
+static void create_ptd_atl(struct vega_qh *qh,
+			struct vega_qtd *qtd, struct ptd *ptd)
+{
+	u32 maxpacket;
+	u32 multi;
+	u32 rl = RL_COUNTER;
+	u32 nak = NAK_COUNTER;
+	
+	
+	if (usb_pipebulk(qtd->urb->pipe) || usb_pipecontrol(qtd->urb->pipe)){
+		rl = RL_COUNTER_ATL;
+		nak = NAK_COUNTER_ATL;
+	}
+	
+	//if(unskip_check)
+	//	pr_err("check create_ptd_atl\n");
+
+	memset(ptd, 0, sizeof(*ptd));
+
+	vega_pr_err("create_ptd_atl\n");
+	
+	/* according to 3.6.2, max packet len can not be > 0x400 */
+	maxpacket = usb_maxpacket(qtd->urb->dev, qtd->urb->pipe,
+						usb_pipeout(qtd->urb->pipe));
+	vega_pr_err("maxpacket : %x , multi : %x\n",maxpacket, multi);
+	multi =  1 + ((maxpacket >> 11) & 0x3);
+	maxpacket &= 0x7ff;
+
+	//pr_err("maxpacket : %x , multi : %x\n",maxpacket, multi);
+
+	/* DW0 */
+	ptd->dw0 = DW0_ACTIVE_BIT;
+	ptd->dw0 |= (usb_pipeendpoint(qtd->urb->pipe) >> 1); // Bits [1:3] of endpoint number
+	ptd->dw0 |= TO_DW0_DEVICE_ADDR(usb_pipedevice(qtd->urb->pipe));
+	ptd->dw0 |= TO_DW0_PID_TOKEN(qtd->packet_type);
+	vega_pr_err("\n--------------------------------\n");
+	/*if(qtd->packet_type == 0)
+		pr_err("<OUT>\n");
+	else if(qtd->packet_type == 1)
+		pr_err("<IN>\n");
+	else if(qtd->packet_type == 2)
+		vega_pr_err("<SETUP>\n");
+	else
+		pr_err("<PING>\n");*/
+	ptd->dw0 |= TO_DW0_RL(rl);
+	ptd->dw0 |= TO_DW0_NAKCOUNT(nak);
+	
+	/*pr_err("------bDeviceClass----------\n");
+	//pr_err("dev num: %08lx\n",qtd->urb->dev->tt->hub->devnum);
+	//pr_err("maxchild: %08lx\n",qtd->urb->dev->maxchild);
+	pr_err("bDeviceClass: %08lx\n",qtd->urb->dev->descriptor.bDeviceClass);
+	pr_err("bDeviceSubClass: %08lx\n",qtd->urb->dev->descriptor.bDeviceSubClass);*/
+	
+	
+	if (vega_hub_speed == HUB_SPEED_HIGH){
+		if (qtd->urb->dev->speed != USB_SPEED_HIGH) {
+			//FIXME printf("SPLIT bit not in VEGA\n");
+			//vega_dbg(hcd->self.controller,"SPLIT bit not in VEGA\n");
+			/* split transaction */
+			//if (usb_pipeint(qtd->urb->pipe))
+			//	pr_err("Split\n");
+			ptd->dw3 = 0;
+
+			ptd->dw3 |= DW3_TRANS_SPLIT;
+			
+			
+			
+			if (qtd->urb->dev->speed == USB_SPEED_LOW)
+				ptd->dw3 |= DW3_SE_USB_LOSPEED;
+
+			ptd->dw3 |= TO_DW3_PORT_NUM(qtd->urb->dev->ttport);
+			ptd->dw3 |= TO_DW3_HUB_NUM(qtd->urb->dev->tt->hub->devnum);
+			
+			/* SE bit for Split INT transfers */
+			if (usb_pipeint(qtd->urb->pipe) &&
+					(qtd->urb->dev->speed == USB_SPEED_LOW))
+				ptd->dw3 |= 2 << 2;
+
+		} else {
+			
+			//FIXME 
+			///pr_err("MULTI bit not in VEGA\n");
+			/*ptd->dw0 |= TO_DW0_MULTI(multi);*/
+			//pr_err("High speed device\n");
+
+			if (usb_pipecontrol(qtd->urb->pipe)){
+				ptd->dw0 &= ~TO_DW0_PING(1);
+				//pr_err("CTL PING=0\n");
+			}
+			else if (usb_pipebulk(qtd->urb->pipe))
+			{
+
+				if(qtd->packet_type == 0) //OUT Transfer
+				{
+					ptd->dw0 |= TO_DW0_PING(qh->ping);
+					//pr_err("BLK OUT PING=%x\n",qh->ping);
+				}
+				else
+				{
+					ptd->dw0 &= ~TO_DW0_PING(1);
+					//pr_err("BLK IN PING=0\n");
+				}
+				
+			}
+			ptd->dw3 = 0;
+			//pr_err("ping :%x\n",qh->ping);
+		}
+	}else{
+
+		//pr_err("Full speed hub\n");
+
+
+		ptd->dw3 = 0;
+		
+		if (qtd->urb->dev->speed == USB_SPEED_LOW)
+			ptd->dw3 |= DW3_SE_USB_LOSPEED;
+
+		//ptd->dw3 |= TO_DW3_PORT_NUM(qtd->urb->dev->ttport);
+		//ptd->dw3 |= TO_DW3_HUB_NUM(qtd->urb->dev->tt->hub->devnum);
+		
+	}
+
+	/* DW1 */
+	ptd->dw1 = TO_DW1_LENGTH(qtd->length);
+	
+	
+	if(qtd->length>8192)
+		pr_err("qtd->length : %d\n",qtd->length);
+	//pr_err("qtd->length : %d\n",qtd->length);
+	ptd->dw1 |= TO_DW1_MAXPACKET(maxpacket);
+	ptd->dw1 |= TO_DW1_ENDPOINT_0(usb_pipeendpoint(qtd->urb->pipe) & 1); // Bit[0] of endpoint number	
+
+	if  (!usb_pipeisoc(qtd->urb->pipe))
+		ptd->dw1 |= TO_DW1_CERR(ERR_COUNTER); 	/* Cerr */
+	//pr_err("ptd->dw1 : %lx\n",ptd->dw1);
+	/* DW2 */
+	ptd->dw2 = 0;
+	ptd->dw2 |= TO_DW2_DATA_START_ADDR(qtd->payload_addr);
+	
+	//ptd->dw2 &= ~TO_DW2_DATA_TOGGLE(1); //|= TO_DW2_DATA_TOGGLE(qh->toggle); FIXME
+	if  (!usb_pipeisoc(qtd->urb->pipe))
+		ptd->dw2 |= TO_DW2_DATA_TOGGLE(qh->toggle);// FIXME
+	
+
+	//pr_err("qh->toggle : %x,ptd->dw2 %x \n",qh->toggle, ptd->dw2);
+
+	if (usb_pipebulk(qtd->urb->pipe)){
+		ptd->dw2 |= DW2_TRANS_BULK;
+		//if((qtd->length == 13) && (qtd->packet_type == IN_PID))
+			//pr_err("bulk len==13\n");
+	}
+	else if  (usb_pipeint(qtd->urb->pipe)){
+		ptd->dw2 |= DW2_TRANS_INT;
+		//pr_err("usb_pipeint\n");
+	}
+	else if  (usb_pipeisoc(qtd->urb->pipe)){
+		ptd->dw2 |= DW2_TRANS_ISO;
+		//pr_err("usb_pipeisoc\n");
+	}
+
+	//vega_pr_err("qh->toggle : %x, qtd->urb->pipe : %x\n",qh->toggle,qtd->urb->pipe);
+	
+
+	if (usb_pipecontrol(qtd->urb->pipe)) {
+		if (qtd->data_buffer == qtd->urb->setup_packet){
+			ptd->dw2 &= ~TO_DW2_DATA_TOGGLE(1);
+			//vega_pr_err("TO_DW2_DATA_TOGGLE CLEAR\n");
+		}
+		else //if (last_qtd_of_urb(qtd, qh)) //FIXME
+		{
+			ptd->dw2 |= TO_DW2_DATA_TOGGLE(1);
+			//vega_pr_err("TO_DW2_DATA_TOGGLE \n");
+		}
+	}
+
+	//pr_err("qh->toggle : %x,ptd->dw2 %x \n",qh->toggle, ptd->dw2);
+
+	/* DW3 */
+	
+		
+	ptd->dw4 = 0;
+	ptd->dw5 = 0;
+	ptd->dw6 = 0;
+	ptd->dw7 = 0;
+	
+	//Reserved
+
+}
+
+static void transform_add_int(struct vega_qh *qh,
+			struct vega_qtd *qtd, struct ptd *ptd)
+{
+	u32 usof, frame_index;
+	u32 uFrame_7_3, uFrame, frame_interval;
+
+	/*
+	 * Most of this is guessing. ISP1761 datasheet is quite unclear, and
+	 * the algorithm from the original Philips driver code, which was
+	 * pretty much used in this driver before as well, is quite horrendous
+	 * and, i believe, incorrect. The code below follows the datasheet and
+	 * USB2.0 spec as far as I can tell, and plug/unplug seems to be much
+	 * more reliable this way (fingers crossed...).
+	 */
+
+
+	if(qtd->urb->dev->descriptor.bDeviceClass != 0x09){ //Device class is not a hub
+		
+		if  (usb_pipeint(qtd->urb->pipe)){
+		
+			if (qtd->urb->dev->speed == USB_SPEED_HIGH) { //vega_hub_speed //HUB_SPEED_HIGH
+			
+				/* urb->interval is in units of microframes (1/8 ms) */
+
+				if (qtd->urb->interval > 8) {//2^(bInterval-1)
+					usof = 0x01; /* One bit set*/
+					
+					if(qtd->urb->interval > 256)
+						qtd->urb->interval = 256; //Host controller supports only upto 32 ms
+					uFrame_7_3 = qtd->urb->interval / 16; /* uFrame[7:3] = 1, period = 2ms for interval = 16;  uFrame[7:3] = 2, period = 4ms for interval = 32 etc.*/
+				}
+				else if (qtd->urb->interval > 4) //bInterval
+				{
+					usof = 0x01;
+					if (qtd->urb->interval == 5)
+						uFrame_7_3 = 0x1; 
+					else if (qtd->urb->interval == 6)
+						uFrame_7_3 = 0x2;
+					else if (qtd->urb->interval == 7)
+						uFrame_7_3 = 0x4;
+					else if (qtd->urb->interval == 8)
+						uFrame_7_3 = 0x8;
+				
+				}
+				else //bInterval
+				{
+					if (qtd->urb->interval == 1)
+						usof = 0xff; /* All bits set => interval 125us */
+					else if (qtd->urb->interval == 2)
+						usof = 0xaa; /* 4 bits set => interval 250us */
+					else if (qtd->urb->interval == 3)
+						usof = 0x11; /* 2 bits set => interval 500us */
+					else if (qtd->urb->interval == 4)
+						usof = 0x01; /* 1 bit set => interval 1ms */
+					uFrame_7_3 = 0;
+				}
+				
+				
+				//if (qtd->urb->dev->speed != USB_SPEED_HIGH)
+				//	usof = 0x1d; //For Split transfer
+				//pr_err("HIGH p : %x u : %x interval :%x >>>>>\n", uFrame_7_3, usof, qtd->urb->interval);	
+				
+			} else {
+				/* urb->interval is in units of frames (1 ms) */
+				
+				usof = 0x1d; //For Split transfer
+				
+				if(qtd->urb->interval > 32)
+					qtd->urb->interval = 32; //Host controller supports only upto 32 ms
+				uFrame_7_3 = qtd->urb->interval / 2; //uFrame_7_3 = 0 for 1ms, 1 for 2ms, 2 for 4ms, 4 for 8ms etc..
+				//usof = 0x01; /* One bit set*/
+				
+				//pr_err("USB_SPEED_full period : %x usof : %x qtd->urb->interval :%x >>>>>\n", uFrame_7_3, usof, qtd->urb->interval);	
+				
+			}
+
+		}
+		else if  (usb_pipeisoc(qtd->urb->pipe)){
+			
+			if (vega_hub_speed == HUB_SPEED_HIGH) {
+			
+				if (qtd->urb->interval > 4) {
+					usof = 0x01; /* One bit set*/
+				}
+				else{
+					if (qtd->urb->interval == 1)
+						usof = 0xff; /* All bits set => interval 125us */
+					else if (qtd->urb->interval == 2)
+						usof = 0xaa; /* 4 bits set => interval 250us */
+					else if (qtd->urb->interval == 3)
+						usof = 0x11; /* 2 bits set => interval 500us */
+					else if (qtd->urb->interval == 4)
+						usof = 0x01; /* 1 bit set => interval 1ms */
+				}
+				
+				
+				frame_index = gframe_index >> 3; //Frame Number
+				uFrame_7_3 = frame_index; //Next Frame after 2 Frames (2ms)
+			
+			} else {
+			
+				frame_interval = 1 << (qtd->urb->interval - 1); //ms
+				
+				//frame_index = frame_index >> 3; //Frame Number
+				uFrame_7_3 = gframe_index + frame_interval; //Next Frame after (2 + frame_interval) Frames
+			}
+		}
+	} else { //Device class is a Hub
+	
+		//pr_err("Hub Class : %d\n",qtd->urb->dev->descriptor.bDeviceClass);
+	
+		if  (usb_pipeint(qtd->urb->pipe)){
+
+			/* urb->interval is in units of frames (1 ms) */
+			
+			usof = 0x1d; //For Split transfer
+			
+			if(qtd->urb->interval > 32)
+				qtd->urb->interval = 32; //Host controller supports only upto 32 ms
+			uFrame_7_3 = qtd->urb->interval / 2; //uFrame_7_3 = 0 for 1ms, 1 for 2ms, 2 for 4ms, 4 for 8ms etc..
+
+
+		}
+		else if  (usb_pipeisoc(qtd->urb->pipe)){
+			
+
+			frame_interval = 1 << (qtd->urb->interval - 1); //ms
+			
+			//frame_index = frame_index >> 3; //Frame Number
+			uFrame_7_3 = gframe_index + frame_interval; //Next Frame after (2 + frame_interval) Frames
+		}
+
+	}
+
+	uFrame = uFrame_7_3 << 3;
+
+	ptd->dw0 |= (uFrame<<12);
+	ptd->dw0 |= (usof<<20);
+	//pr_err(" dw0 : %x  \n", ptd->dw0);
+}
+
+static void create_ptd_int(struct vega_qh *qh,
+			struct vega_qtd *qtd, struct ptd *ptd)
+{
+	//vega_dbg(hcd->self.controller,"create_ptd_int>>>>\n");
+	create_ptd_atl(qh, qtd, ptd);
+	transform_add_int(qh, qtd, ptd);
+}
+
+
+static void create_ptd_iso(struct vega_qh *qh,
+			struct vega_qtd *qtd, struct ptd *ptd)
+{
+	//pr_err("create_ptd_iso : same as int>>>>\n");
+	create_ptd_atl(qh, qtd, ptd);
+	transform_add_int(qh, qtd, ptd);
+}
+
+
+
+static void vega_urb_done(struct usb_hcd *hcd, struct urb *urb)
+__releases(priv->lock)
+__acquires(priv->lock)
+{
+	struct vega_hcd *priv = hcd_to_priv(hcd);
+
+	if (!urb->unlinked) {
+		if (urb->status == -EINPROGRESS)
+			urb->status = 0;
+	}
+
+	if (usb_pipein(urb->pipe) && usb_pipetype(urb->pipe) != PIPE_CONTROL) {
+		void *ptr;
+		for (ptr = urb->transfer_buffer;
+		     ptr < urb->transfer_buffer + urb->transfer_buffer_length;
+		     ptr += PAGE_SIZE)
+			flush_dcache_page(virt_to_page(ptr)); 
+	}
+
+	/* complete() can reenter this HCD */
+	usb_hcd_unlink_urb_from_ep(hcd, urb);
+	spin_unlock(&priv->lock);
+	usb_hcd_giveback_urb(hcd, urb, urb->status);
+	spin_lock(&priv->lock);
+}
+
+static struct vega_qtd *qtd_alloc(gfp_t flags, struct urb *urb,
+								u8 packet_type)
+{
+	struct vega_qtd *qtd;
+
+	qtd = kmem_cache_zalloc(qtd_cachep, flags);
+	if (!qtd)
+		return NULL;
+
+	INIT_LIST_HEAD(&qtd->qtd_list);
+	qtd->urb = urb;
+	qtd->packet_type = packet_type;
+	qtd->status = QTD_ENQUEUED;
+	qtd->actual_length = 0;
+
+	return qtd;
+}
+
+static void qtd_free(struct vega_qtd *qtd)
+{
+	WARN_ON(qtd->payload_addr);
+	kmem_cache_free(qtd_cachep, qtd);
+}
+
+static void start_bus_transfer(struct usb_hcd *hcd, u32 ptd_offset, int slot,
+				struct vega_slotinfo *slots,
+				struct vega_qtd *qtd, struct vega_qh *qh,
+				struct ptd *ptd)
+{
+	struct vega_hcd *priv = hcd_to_priv(hcd);
+	int skip_map;
+	int temp;
+	
+	vega_dbg(hcd->self.controller,"start_bus_transfer>>>>\n");
+
+	WARN_ON((slot < 0) || (slot > 31));
+	WARN_ON(qtd->length && !qtd->payload_addr);
+	WARN_ON(slots[slot].qtd);
+	WARN_ON(slots[slot].qh);
+	WARN_ON(qtd->status != QTD_PAYLOAD_ALLOC);
+
+	/* Make sure done map has not triggered from some unlinked transfer */
+	if (ptd_offset == ATL_PTD_OFFSET) {
+		priv->atl_done_map |= vega_read32(hcd->regs,
+						HC_ATL_PTD_DONEMAP_REG);
+		priv->atl_done_map &= ~(1 << slot);
+	} else if (ptd_offset == ISO_PTD_OFFSET) {
+		priv->iso_done_map |= vega_read32(hcd->regs, HC_ISO_PTD_DONEMAP_REG);
+		priv->iso_done_map &= ~(1 << slot);
+	}	
+	 else {
+		priv->int_done_map |= vega_read32(hcd->regs,
+						HC_INT_PTD_DONEMAP_REG);
+		priv->int_done_map &= ~(1 << slot);
+	}
+
+	qh->slot = slot;
+	qtd->status = QTD_XFER_STARTED;
+	slots[slot].timestamp = jiffies;
+	slots[slot].qtd = qtd;
+	slots[slot].qh = qh;
+	ptd_write(hcd->regs, ptd_offset, slot, ptd);
+
+	vega_dbg1(hcd->self.controller,"start_bus_transfer \n");
+
+	if (ptd_offset == ATL_PTD_OFFSET) {
+		skip_map = atl_skipmap_global; //vega_read32(hcd->regs, HC_ATL_PTD_SKIPMAP_REG);
+		vega_dbg(hcd->self.controller,"skip_map wr %x >>>>>\n",skip_map);
+		skip_map &= ~(1 << qh->slot);
+		
+		//if(skip_map !=0xfffffffe)
+		//	pr_err("skip_map atl %x >>>>>\n",skip_map);
+			
+		atl_skipmap_global = skip_map;
+		vega_write32(hcd->regs, HC_ATL_PTD_SKIPMAP_REG, skip_map);
+		
+		/*if((qtd->length == 13) && (qtd->packet_type == IN_PID)){
+			//pr_err("bulk len==13 unskip\n");
+			unskip_check = 1;
+			if(stall_check){//cdac-test-pid
+				stall_check = 0;
+				temp =  stall_count | (stall_count << 8) | (stall_count << 16) | (stall_count << 24);
+				vega_write32(hcd->regs, HC_SCRATCH_REG, temp);
+				stall_count++;
+			}
+			
+							
+					pr_err("------------unskip---td wr val---------\n");
+					pr_err("Slot : %d\n",slot);
+					pr_err("dw0 : %x\n",ptd->dw0);
+					pr_err("dw1 : %x\n",ptd->dw1);
+					pr_err("dw2 : %x\n",ptd->dw2);		
+					pr_err("dw3 : %x\n",ptd->dw3);
+					pr_err("dw4 : %x\n",ptd->dw4);
+					pr_err("dw5 : %x\n",ptd->dw5);
+					pr_err("dw6 : %x\n",ptd->dw6);
+					pr_err("dw7 : %x\n",ptd->dw7);
+					pr_err("++++++++++++unskip++++++++++++\n");
+		
+		}*/
+		
+		
+		//pr_err("unskip\n");
+		
+	
+		vega_dbg1(hcd->self.controller,"skip_map wr %x >>>>>\n",skip_map);
+		skip_map = vega_read32(hcd->regs, HC_ATL_PTD_SKIPMAP_REG); //FIXME
+		
+		//pr_err("unskip_map \n");
+
+	/*	while(1){
+			if(vega_read32(hcd->regs, HC_ATL_PTD_DONEMAP_REG)==1)
+				break;
+		}*/
+		vega_dbg1(hcd->self.controller,"done_map set\n");
+	} else if(ptd_offset == ISO_PTD_OFFSET) {
+		skip_map = iso_skipmap_global; //vega_read32(hcd->regs, HC_INT_PTD_SKIPMAP_REG);
+		skip_map &= ~(1 << qh->slot);
+		
+		//if(skip_map !=0xfe)
+		//pr_err("skip_map iso %x >>>>>\n",skip_map);
+		iso_skipmap_global=skip_map;
+		vega_write32(hcd->regs, HC_ISO_PTD_SKIPMAP_REG, skip_map);
+		skip_map = vega_read32(hcd->regs, HC_ISO_PTD_SKIPMAP_REG); //FIXME
+	}
+	
+	
+	 else {
+		skip_map = int_skipmap_global; //vega_read32(hcd->regs, HC_INT_PTD_SKIPMAP_REG);
+		skip_map &= ~(1 << qh->slot);
+		
+		//if(skip_map !=0xfffffffe)
+		//	pr_err("skip_map int %x >>>>>\n",skip_map);
+
+		//if(skip_map !=0xfe)
+		//pr_err("skip_map int %x >>>>>\n",skip_map);
+		int_skipmap_global=skip_map;
+		vega_write32(hcd->regs, HC_INT_PTD_SKIPMAP_REG, skip_map);
+		skip_map = vega_read32(hcd->regs, HC_INT_PTD_SKIPMAP_REG); //FIXME
+	}
+}
+
+static int is_short_bulk(struct vega_qtd *qtd)
+{
+	return (usb_pipebulk(qtd->urb->pipe) &&
+					(qtd->actual_length < qtd->length));
+}
+
+static void collect_qtds(struct usb_hcd *hcd, struct vega_qh *qh,
+						struct list_head *urb_list)
+{
+	int last_qtd;
+	struct vega_qtd *qtd, *qtd_next;
+	struct urb_listitem *urb_listitem;
+
+	int k=0;
+	
+	
+	//if(done_check){
+		//pr_err("collect_qtds \n");
+	//}//cdac-test-pid
+	
+	
+
+	list_for_each_entry_safe(qtd, qtd_next, &qh->qtd_list, qtd_list) {
+		vega_dbg1(hcd->self.controller,"collect_qtds status %x, length %x, pkt typ %x\n",qtd->status,qtd->actual_length,qtd->packet_type);
+		if (qtd->status < QTD_XFER_COMPLETE)
+			break;
+			
+		//if(done_check){
+			//pr_err("collect_qtds 1 \n");
+		//}	
+
+		last_qtd = last_qtd_of_urb(qtd, qh);
+
+		if ((!last_qtd) && (qtd->status == QTD_RETIRE))
+			qtd_next->status = QTD_RETIRE;
+
+		if (qtd->status == QTD_XFER_COMPLETE) {
+		
+			/*if(done_check){//cdac-test-pid
+				//pr_err("collect_qtds 2 \n");
+				
+				if (qtd->actual_length == 0){
+
+					vega_write32(hcd->regs, HC_SCRATCH_REG, 0x12345678);
+					pr_err("td error \n"); 
+				}
+				
+			}*/
+		
+		
+			if (qtd->actual_length) {
+			
+				//if(done_check){ //cdac-test-pid
+					//pr_err("collect_qtds 3\n");
+				//}
+			
+			
+				switch (qtd->packet_type) {
+				case IN_PID:
+					//vega_pr_err("<<<<<IN payload : %d\n", qtd->actual_length);
+					mem_reads8(hcd->regs, qtd->payload_addr,
+							qtd->data_buffer,
+							qtd->actual_length);
+							
+							
+					//if(done_check){ //cdac-test-pid
+						//pr_err("bulk len==13 , data copied qtd->actual_length = %x\n", qtd->actual_length);
+						//done_check = 0;
+					//}
+					
+						
+							
+							
+					//unsigned char *	mem_data = (unsigned char  *)(qtd->data_buffer);
+						//vega_mem_io_dbg("------------IN payload %lx------------\n",qtd->payload_addr);
+						//for(k=0;k<qtd->actual_length;k++){
+							//vega_pr_err("%d: %x\n",k,mem_data[k]);
+							
+						//}
+						//vega_mem_io_dbg("------------IN payload-over------------\n");
+					/* Fall through (?) */
+				case OUT_PID:
+					qtd->urb->actual_length +=
+							qtd->actual_length;
+					/* Fall through ... */
+				case SETUP_PID:
+					break;
+				}
+			}
+
+			if (is_short_bulk(qtd)) {
+				if (qtd->urb->transfer_flags & URB_SHORT_NOT_OK)
+					qtd->urb->status = -EREMOTEIO;
+				if (!last_qtd)
+					qtd_next->status = QTD_RETIRE;
+			}
+		}
+
+		if (qtd->payload_addr)
+			free_mem(hcd, qtd);
+
+		if (last_qtd) {
+			if ((qtd->status == QTD_RETIRE) &&
+					(qtd->urb->status == -EINPROGRESS))
+				qtd->urb->status = -EPIPE;
+			/* Defer calling of urb_done() since it releases lock */
+			urb_listitem = kmem_cache_zalloc(urb_listitem_cachep,
+								GFP_ATOMIC);
+			if (unlikely(!urb_listitem))
+				break; /* Try again on next call */
+			urb_listitem->urb = qtd->urb;
+			list_add_tail(&urb_listitem->urb_list, urb_list);
+		}
+
+		list_del(&qtd->qtd_list);
+		qtd_free(qtd);
+	}
+}
+
+#define ENQUEUE_DEPTH	2
+static void enqueue_qtds(struct usb_hcd *hcd, struct vega_qh *qh)
+{
+	struct vega_hcd *priv = hcd_to_priv(hcd);
+	int ptd_offset;
+	struct vega_slotinfo *slots;
+	int curr_slot, free_slot;
+	int n;
+	struct ptd ptd;
+	struct vega_qtd *qtd;
+	int k=0;
+	//unsigned int  *mem_data;
+	
+	vega_dbg1(hcd->self.controller,"enqueue_qtds>>>>\n");
+
+	if (unlikely(list_empty(&qh->qtd_list))) {
+		WARN_ON(1);
+		return;
+	}
+
+	/* Make sure this endpoint's TT buffer is clean before queueing ptds */
+	if (qh->tt_buffer_dirty){
+		pr_err(">>>>>>Buffer dirty \n");
+		return;
+	}
+
+	if (usb_pipeint(list_entry(qh->qtd_list.next, struct vega_qtd,
+							qtd_list)->urb->pipe)) {
+		ptd_offset = INT_PTD_OFFSET;
+		slots = priv->int_slots;
+	} else if(usb_pipeisoc(list_entry(qh->qtd_list.next, struct vega_qtd,
+							qtd_list)->urb->pipe)) {
+		ptd_offset = ISO_PTD_OFFSET;
+		slots = priv->iso_slots;
+	}
+	   else{
+		ptd_offset = ATL_PTD_OFFSET;
+		slots = priv->atl_slots;
+	}
+
+	free_slot = -1;
+	for (curr_slot = 0; curr_slot < 32; curr_slot++) {
+		if ((free_slot == -1) && (slots[curr_slot].qtd == NULL))
+			free_slot = curr_slot;
+		if (slots[curr_slot].qh == qh)
+			break;
+	}
+
+	n = 0;
+	list_for_each_entry(qtd, &qh->qtd_list, qtd_list) {
+		if (qtd->status == QTD_ENQUEUED) {
+			WARN_ON(qtd->payload_addr);
+			alloc_mem(hcd, qtd);
+			if ((qtd->length) && (!qtd->payload_addr))
+				break;
+				vega_mem_io_dbg("qtd->length: %x, qtd->packet_type: %x \n",qtd->length, qtd->packet_type);
+
+			if ((qtd->length) &&
+			    ((qtd->packet_type == SETUP_PID) ||
+			     (qtd->packet_type == OUT_PID))) {
+
+				mem_writes8(hcd->regs, qtd->payload_addr,
+						qtd->data_buffer, qtd->length);
+						//mem_data = (unsigned int  *)(qtd->data_buffer);
+						//vega_pr_err(">>>>>OUT Payload :%d \n",qtd->length);
+						//vega_mem_io_dbg("------------payload------------\n");
+
+				//for(k=0;k<qtd->length;k++){
+					//vega_pr_err("%d: %x\n",k,mem_data[k]);
+					
+				//}
+				//vega_mem_io_dbg("------------payload-over------------\n");
+			}
+
+			qtd->status = QTD_PAYLOAD_ALLOC;
+		}
+
+		if (qtd->status == QTD_PAYLOAD_ALLOC) {
+/*
+			if ((curr_slot > 31) && (free_slot == -1))
+				vega_dbg(hcd->self.controller, "%s: No slot "
+					"available for transfer\n", __func__);
+*/
+			/* Start xfer for this endpoint if not already done */
+			
+			
+			if ((curr_slot > 31) && (free_slot > -1)) {
+				if (usb_pipeint(qtd->urb->pipe))
+					create_ptd_int(qh, qtd, &ptd);
+				else if (usb_pipeisoc(qtd->urb->pipe)){
+					gframe_index = vega_read32(hcd->regs, HC_FRINDEX); //uFrame Number
+					create_ptd_iso(qh, qtd, &ptd);
+				}
+				else
+					create_ptd_atl(qh, qtd, &ptd);
+				//pr_err("enqueue_qtds -> start_bus_transfer >>>>>\n");
+				start_bus_transfer(hcd, ptd_offset, free_slot,
+							slots, qtd, qh, &ptd);
+				curr_slot = free_slot;
+			}
+
+			n++;
+			if (n >= ENQUEUE_DEPTH)
+				break;
+		}
+	}
+}
+
+static void schedule_ptds(struct usb_hcd *hcd)
+{
+	struct vega_hcd *priv;
+	struct vega_qh *qh, *qh_next;
+	struct list_head *ep_queue;
+	LIST_HEAD(urb_list);
+	struct urb_listitem *urb_listitem, *urb_listitem_next;
+	int i;
+
+	//pr_err("schedule_ptds\n");
+
+	if (!hcd) {
+		WARN_ON(1);
+		return;
+	}
+
+	priv = hcd_to_priv(hcd);
+
+	/*
+	 * check finished/retired xfers, transfer payloads, call urb_done()
+	 */
+	for (i = 0; i < QH_END; i++) {
+		ep_queue = &priv->qh_list[i];
+		list_for_each_entry_safe(qh, qh_next, ep_queue, qh_list) {
+			collect_qtds(hcd, qh, &urb_list);
+			if (list_empty(&qh->qtd_list))
+				list_del(&qh->qh_list);
+		}
+	}
+
+	list_for_each_entry_safe(urb_listitem, urb_listitem_next, &urb_list,
+								urb_list) {
+		vega_urb_done(hcd, urb_listitem->urb);
+		kmem_cache_free(urb_listitem_cachep, urb_listitem);
+	}
+	
+	//unskip_check = 0; //cdac-test-pid
+
+	/*
+	 * Schedule packets for transfer.
+	 *
+	 * According to USB2.0 specification:
+	 *
+	 * 1st prio: interrupt xfers, up to 80 % of bandwidth
+	 * 2nd prio: control xfers
+	 * 3rd prio: bulk xfers
+	 *
+	 * ... but let's use a simpler scheme here (mostly because ISP1761 doc
+	 * is very unclear on how to prioritize traffic):
+	 *
+	 * 1) Enqueue any queued control transfers, as long as payload chip mem
+	 *    and PTD ATL slots are available.
+	 * 2) Enqueue any queued INT transfers, as long as payload chip mem
+	 *    and PTD INT slots are available.
+	 * 3) Enqueue any queued bulk transfers, as long as payload chip mem
+	 *    and PTD ATL slots are available.
+	 *
+	 * Use double buffering (ENQUEUE_DEPTH==2) as a compromise between
+	 * conservation of chip mem and performance.
+	 *
+	 * I'm sure this scheme could be improved upon!
+	 */
+	for (i = 0; i < QH_END; i++) {
+		ep_queue = &priv->qh_list[i];
+		list_for_each_entry_safe(qh, qh_next, ep_queue, qh_list)
+			enqueue_qtds(hcd, qh);
+	}
+	//pr_err("schedule_ptds over\n");
+}
+
+#define PTD_STATE_QTD_DONE	1
+#define PTD_STATE_QTD_RELOAD	2
+#define PTD_STATE_URB_RETIRE	3
+
+static int check_int_transfer(struct usb_hcd *hcd, struct ptd *ptd,
+								struct urb *urb)
+{
+	int mode_ctl, ep_num, ep_dir;
+	
+	if (ptd->dw0 & DW0_HALT_BIT) {
+
+		urb->status = -EPIPE; //stall
+		
+		
+		ep_num = (FROM_DW0_ENDPOINT_1_3(ptd->dw0) << 1) | FROM_DW1_ENDPOINT_0(ptd->dw1);
+		
+		ep_dir = FROM_DW0_PID_TOKEN(ptd->dw0);
+		
+		mode_ctl = vega_read32(hcd->regs, HC_HW_MODE_CTRL);
+		
+		mode_ctl = mode_ctl | (ep_dir << 12) | (ep_num << 7) | HW_PID_RESET;
+		vega_write32(hcd->regs, HC_HW_MODE_CTRL, mode_ctl ); // Do PID reset
+		mdelay(10);
+		mode_ctl &= ~HW_PID_RESET;
+		vega_write32(hcd->regs, HC_HW_MODE_CTRL, mode_ctl ); // Clear PID reset
+		
+
+		return PTD_STATE_URB_RETIRE;
+	}
+	
+	if ((ptd->dw0 & DW0_ERROR_BIT)) {
+		
+		pr_err("int ERROR BIT, CERR %x \n",FROM_DW1_CERR(ptd->dw1));
+		u32 temp = vega_read32(hcd->regs, HC_PORTSC1);
+	
+		return PTD_STATE_URB_RETIRE;
+		
+	}
+	
+	//if (!FROM_DW0_NAKCOUNT(ptd->dw0) ) {
+		/*
+		 * NAKs are handled in HW by the chip. Usually if the
+		 * device is not able to send data fast enough.
+		 * This happens mostly on slower hardware.
+		 */
+		//pr_err("NACK COUNT OVER\n");
+		//return PTD_STATE_QTD_RELOAD;
+
+		//}
+
+	//if (!FROM_DW0_NAKCOUNT(ptd->dw0) && (ptd->dw0 & DW0_ACTIVE_BIT)) {
+		/*
+		 * NAKs are handled in HW by the chip. Usually if the
+		 * device is not able to send data fast enough.
+		 * This happens mostly on slower hardware.
+		 */
+	//	pr_err("NACK COUNT OVER\n");
+	//	return PTD_STATE_QTD_RELOAD;
+//	}
+
+	return PTD_STATE_QTD_DONE;
+}
+
+
+static int check_iso_transfer(struct usb_hcd *hcd, struct ptd *ptd,
+								struct urb *urb)
+{
+	int mode_ctl, ep_num, ep_dir;
+	
+	if (ptd->dw0 & DW0_HALT_BIT) {
+
+		urb->status = -EPIPE; //stall
+		
+		
+		ep_num = (FROM_DW0_ENDPOINT_1_3(ptd->dw0) << 1) | FROM_DW1_ENDPOINT_0(ptd->dw1);
+		
+		ep_dir = FROM_DW0_PID_TOKEN(ptd->dw0);
+		
+		mode_ctl = vega_read32(hcd->regs, HC_HW_MODE_CTRL);
+		
+		mode_ctl = mode_ctl | (ep_dir << 12) | (ep_num << 7) | HW_PID_RESET;
+		vega_write32(hcd->regs, HC_HW_MODE_CTRL, mode_ctl ); // Do PID reset
+		mdelay(10);
+		mode_ctl &= ~HW_PID_RESET;
+		vega_write32(hcd->regs, HC_HW_MODE_CTRL, mode_ctl ); // Clear PID reset
+		
+
+		return PTD_STATE_URB_RETIRE;
+	}
+
+	return PTD_STATE_QTD_DONE;
+}
+
+static int check_atl_transfer(struct usb_hcd *hcd, struct ptd *ptd,
+								struct urb *urb)
+{
+	WARN_ON(!ptd);
+	vega_dbg1(hcd->self.controller,"check_atl_transfer function>>>> %x\n",ptd->dw0);
+	int mode_ctl, ep_num, ep_dir;
+	static int qtd_reload_count = 0;
+
+	if (ptd->dw0 & DW0_HALT_BIT) {
+		
+
+		urb->status = -EPIPE; //stall
+		
+		ep_num = (FROM_DW0_ENDPOINT_1_3(ptd->dw0) << 1) | FROM_DW1_ENDPOINT_0(ptd->dw1);
+		
+		ep_dir = FROM_DW0_PID_TOKEN(ptd->dw0);
+		
+		mode_ctl = vega_read32(hcd->regs, HC_HW_MODE_CTRL);
+		
+		mode_ctl = mode_ctl | (ep_dir << 12) | (ep_num << 7) | HW_PID_RESET;
+		vega_write32(hcd->regs, HC_HW_MODE_CTRL, mode_ctl ); // Do PID reset
+		mdelay(10);
+		mode_ctl &= ~HW_PID_RESET;
+		vega_write32(hcd->regs, HC_HW_MODE_CTRL, mode_ctl ); // Clear PID reset
+	
+		return PTD_STATE_URB_RETIRE;
+	}
+	
+	if ((ptd->dw0 & DW0_ERROR_BIT)) {
+		
+		pr_err("atl ERROR BIT, CERR %x \n",FROM_DW1_CERR(ptd->dw1));
+		u32 temp = vega_read32(hcd->regs, HC_PORTSC1);
+
+		urb->status = -EPROTO;
+				/*	pr_err("------------CERR---td RD val---------\n");
+					pr_err("dw0 : %x\n",ptd->dw0);
+					pr_err("dw1 : %x\n",ptd->dw1);
+					pr_err("dw2 : %x\n",ptd->dw2);		
+					pr_err("dw3 : %x\n",ptd->dw3);
+					pr_err("dw4 : %x\n",ptd->dw4);
+					pr_err("dw5 : %x\n",ptd->dw5);
+					pr_err("dw6 : %x\n",ptd->dw6);
+					pr_err("dw7 : %x\n",ptd->dw7);
+					pr_err("++++++++++++CERR++++++++++++\n");*/
+
+
+	
+		return PTD_STATE_URB_RETIRE;
+
+	}
+
+	
+	if (!FROM_DW0_NAKCOUNT(ptd->dw0) ) {
+		/*
+		 * NAKs are handled in HW by the chip. Usually if the
+		 * device is not able to send data fast enough.
+		 * This happens mostly on slower hardware.
+		 */
+		//pr_err("NACK COUNT OVER\n");
+
+		//if(FROM_DW2_EP_TYPE(ptd->dw2) == 0) //Control transfer -- infinite retry on NAK
+		//	return PTD_STATE_QTD_DONE;
+		//else{ //Bulk transfer -- 5000 retry on NAK
+			qtd_reload_count++;
+			if(qtd_reload_count > 1000) {
+				qtd_reload_count = 0;
+				urb->status = -EPROTO;
+				pr_err("NACK  retry\n");
+				return PTD_STATE_URB_RETIRE;
+			} else
+				return PTD_STATE_QTD_RELOAD;
+		//}
+
+	}
+
+	//if (!FROM_DW0_NAKCOUNT(ptd->dw0) && (ptd->dw0 & DW0_ACTIVE_BIT)) {
+		/*
+		 * NAKs are handled in HW by the chip. Usually if the
+		 * device is not able to send data fast enough.
+		 * This happens mostly on slower hardware.
+		 */
+		//pr_err("NACK COUNT OVER\n");
+		//return PTD_STATE_QTD_RELOAD;
+	//}
+
+	return PTD_STATE_QTD_DONE;
+}
+
+
+static void handle_done_ptds(struct usb_hcd *hcd)
+{
+	struct vega_hcd *priv = hcd_to_priv(hcd);
+	struct ptd ptd;
+	struct vega_qh *qh;
+	int slot;
+	int state;
+	struct vega_slotinfo *slots;
+	u32 ptd_offset;
+	struct vega_qtd *qtd;
+	int modified;
+	int skip_map;
+	
+	vega_dbg1(hcd->self.controller,"handle_done_ptds>>>>\n");
+	//pr_err("priv->int_done_map %x >>>>>\n",priv->int_done_map);
+	//pr_err("priv->atl_done_map %x >>>>>\n",priv->atl_done_map);
+
+	//skip_map = int_skipmap_global; //vega_read32(hcd->regs, HC_INT_PTD_SKIPMAP_REG);
+	
+	//pr_err("skip_map 1 %x >>>>>\n",skip_map);
+	//pr_err("priv->int_done_map 1 %x >>>>>\n",priv->int_done_map);
+	
+	//skip_map = vega_read32(hcd->regs, HC_ATL_PTD_SKIPMAP_REG);
+	//pr_err("skip_map 2 %x >>>>>\n",skip_map);
+	//pr_err("priv->atl_done_map 2 %x >>>>>\n",priv->atl_done_map);
+	
+	skip_map = int_skipmap_global ; //vega_read32(hcd->regs, HC_ATL_PTD_SKIPMAP_REG); //FIXME
+	priv->int_done_map &= ~skip_map;
+	skip_map = atl_skipmap_global ; //vega_read32(hcd->regs, HC_ATL_PTD_SKIPMAP_REG);  //FIXME
+	priv->atl_done_map &= ~skip_map;
+
+	skip_map = iso_skipmap_global ; //vega_read32(hcd->regs, HC_ATL_PTD_SKIPMAP_REG);  //FIXME
+	priv->iso_done_map &= ~skip_map;
+
+	modified = priv->int_done_map || priv->atl_done_map ||priv->iso_done_map;
+	
+	//pr_err("priv->int_done_map %x >>>>>\n",priv->int_done_map);
+	//pr_err("priv->atl_done_map %x >>>>>\n",priv->atl_done_map);
+	
+
+
+	while (priv->int_done_map || priv->atl_done_map || priv->iso_done_map) {
+		//vega_pr_err(".");
+		if (priv->int_done_map) {
+			/* INT ptd */
+			slot = __ffs(priv->int_done_map);
+			priv->int_done_map &= ~(1 << slot);
+			slots = priv->int_slots;
+			/* This should not trigger, and could be removed if
+			   noone have any problems with it triggering: */
+			if (!slots[slot].qh) {
+				WARN_ON(1);
+				continue;
+			}
+			ptd_offset = INT_PTD_OFFSET;
+			ptd_read(hcd->regs, INT_PTD_OFFSET, slot, &ptd);
+			state = check_int_transfer(hcd, &ptd,
+							slots[slot].qtd->urb);
+		} else if(priv->iso_done_map)
+		{		
+			/* ISO ptd */
+			slot = __ffs(priv->iso_done_map);
+			priv->iso_done_map &= ~(1 << slot);
+			slots = priv->iso_slots;
+			/* This should not trigger, and could be removed if
+			   noone have any problems with it triggering: */
+			if (!slots[slot].qh) {
+				WARN_ON(1);
+				continue;
+			}
+			ptd_offset = ISO_PTD_OFFSET;
+			ptd_read(hcd->regs, ISO_PTD_OFFSET, slot, &ptd);
+			state = check_iso_transfer(hcd, &ptd,
+							slots[slot].qtd->urb);	
+
+		}		
+		 else {
+			 //pr_err("done\n");
+			/* ATL ptd */
+			//pr_err("ATL ptd>>>>\n");
+			//pr_err("priv->atl_done_map %x >>>>>\n",priv->atl_done_map);
+			slot = __ffs(priv->atl_done_map);
+			priv->atl_done_map &= ~(1 << slot);
+			slots = priv->atl_slots;
+			/* This should not trigger, and could be removed if
+			   noone have any problems with it triggering: */
+			if (!slots[slot].qh) {
+				WARN_ON(1);
+				continue;
+			}
+			ptd_offset = ATL_PTD_OFFSET;
+			ptd_read(hcd->regs, ATL_PTD_OFFSET, slot, &ptd);
+			//pr_err("done_map \n");
+			state = check_atl_transfer(hcd, &ptd,
+							slots[slot].qtd->urb);
+							
+							
+			//vega_dbg1(hcd->self.controller,"state: %x\n",state);				
+		}
+
+		vega_handle_ptd_dbg(hcd->self.controller,"ptd.dw0 :%x, ptd.dw1 :%x, ptd.dw2 :%x\n",ptd.dw0,ptd.dw1,ptd.dw2);
+
+		qtd = slots[slot].qtd;
+		slots[slot].qtd = NULL;
+		qh = slots[slot].qh;
+		slots[slot].qh = NULL;
+		qh->slot = -1;
+
+		WARN_ON(qtd->status != QTD_XFER_STARTED);
+
+		switch (state) {
+		case PTD_STATE_QTD_DONE:
+			if ((usb_pipeint(qtd->urb->pipe)) &&
+				       (qtd->urb->dev->speed != USB_SPEED_HIGH)) {
+				qtd->actual_length =
+				       FROM_DW2_SCS_NRBYTESTRANSFERRED(ptd.dw2);
+			//	pr_err("int qtd->actual_length:%x\n", qtd->actual_length);	   
+
+			}
+
+			else if ((usb_pipeisoc(qtd->urb->pipe)) &&
+				       (qtd->urb->dev->speed != USB_SPEED_HIGH)){
+				qtd->actual_length =
+				       FROM_DW2_SCS_NRBYTESTRANSFERRED(ptd.dw2);
+
+				//pr_err("iso qtd->actual_length:%x\n", qtd->actual_length);	   
+			}
+			else {
+				qtd->actual_length =
+					FROM_DW2_NRBYTESTRANSFERRED(ptd.dw2);
+							
+				/*if((qtd->actual_length == 0) || (qtd->actual_length == 13)){
+				
+					pr_err("bulk qtd->actual_length:%d\n", qtd->actual_length);	  
+				
+					pr_err("------------uc------------\n");
+					pr_err("Slot : %d\n",slot);
+					pr_err("dw0 : %x\n",ptd.dw0);
+					pr_err("dw1 : %x\n",ptd.dw1);
+					pr_err("dw2 : %x\n",ptd.dw2);		
+					pr_err("dw3 : %x\n",ptd.dw3);
+					pr_err("dw4 : %x\n",ptd.dw4);
+					pr_err("dw5 : %x\n",ptd.dw5);
+					pr_err("dw6 : %x\n",ptd.dw6);
+					pr_err("dw7 : %x\n",ptd.dw7);
+					pr_err("++++++++++++uc++++++++++++\n");
+				}*/
+				 
+			}
+					
+			/*if (usb_pipebulk(qtd->urb->pipe)){	//cdac-test-pid
+				if((qtd->length == 13) && (qtd->packet_type == IN_PID)){
+					//pr_err("bulk len==13 done, qtd->actual_length = %d\n", qtd->actual_length);
+					done_check=1;
+				}
+			}*/
+					
+					
+
+			vega_handle_ptd_dbg(hcd->self.controller,"qtd->actual_length:%x\n", qtd->actual_length);	
+			
+								
+
+			qtd->status = QTD_XFER_COMPLETE;
+			
+			if(qtd->packet_type == 0) {
+			
+				qh->ping = FROM_DW0_PING(ptd.dw0);
+				
+				//pr_err("aa qh->ping=%d\n", qh->ping);
+			}
+			
+			if (list_is_last(&qtd->qtd_list, &qh->qtd_list) ||
+							is_short_bulk(qtd))
+				qtd = NULL;
+			else
+				qtd = list_entry(qtd->qtd_list.next,
+							typeof(*qtd), qtd_list);
+
+			qh->toggle = FROM_DW2_DATA_TOGGLE(ptd.dw2);
+
+			break;
+
+		case PTD_STATE_QTD_RELOAD: /* QTD_RETRY, for atls only */
+			vega_pr_err("PTD_STATE_QTD_RELOAD\n");
+			qtd->status = QTD_PAYLOAD_ALLOC;
+			ptd.dw0 |= DW0_VALID_BIT;
+			/* RL counter = ERR counter */
+			ptd.dw0 &= ~TO_DW0_NAKCOUNT(0xf);
+			ptd.dw0 |= TO_DW0_NAKCOUNT(FROM_DW0_RL(ptd.dw0));
+			ptd.dw1 &= ~TO_DW1_CERR(3);
+			ptd.dw1 |= TO_DW1_CERR(ERR_COUNTER);
+			qh->toggle = FROM_DW2_DATA_TOGGLE(ptd.dw2);
+
+			if(qtd->packet_type == 0) {
+				qh->ping = FROM_DW0_PING(ptd.dw0);
+				//pr_err("bb qh->ping=%d\n", qh->ping);
+			}
+			break;
+
+		case PTD_STATE_URB_RETIRE:
+			qtd->status = QTD_RETIRE;
+			vega_pr_err("PTD_STATE_URB_RETIRE\n");
+			if(vega_hub_speed == HUB_SPEED_HIGH) {
+				if ((qtd->urb->dev->speed != USB_SPEED_HIGH) &&
+						(qtd->urb->status != -EPIPE) &&
+						(qtd->urb->status != -EREMOTEIO)) {
+					qh->tt_buffer_dirty = 1;
+					if (usb_hub_clear_tt_buffer(qtd->urb))
+						/* Clear failed; let's hope things work
+						anyway */
+						qh->tt_buffer_dirty = 0;
+				}
+			}
+			qtd = NULL;
+			qh->toggle = 0;
+			qh->ping = 0;		
+			break;
+
+		default:
+			WARN_ON(1);
+			continue;
+		}
+
+		if (qtd && (qtd->status == QTD_PAYLOAD_ALLOC)) {
+			if (slots == priv->int_slots) {
+				if (state == PTD_STATE_QTD_RELOAD)
+					vega_dbg(hcd->self.controller,
+						"%s: PTD_STATE_QTD_RELOAD on "
+						"interrupt packet\n", __func__);
+				if (state != PTD_STATE_QTD_RELOAD)
+					create_ptd_int(qh, qtd, &ptd);
+			}else if (slots == priv->iso_slots) {
+				if (state == PTD_STATE_QTD_RELOAD)
+					vega_dbg(hcd->self.controller,
+						"%s: PTD_STATE_QTD_RELOAD on "
+						"iso packet\n", __func__);
+				if (state != PTD_STATE_QTD_RELOAD)
+					create_ptd_iso(qh, qtd, &ptd);
+			} 
+			else {
+				if (state != PTD_STATE_QTD_RELOAD)
+					create_ptd_atl(qh, qtd, &ptd);
+			}
+			//pr_err("handle_done_ptds -> start_bus_transfer >>>>>\n");
+			start_bus_transfer(hcd, ptd_offset, slot, slots, qtd,
+				qh, &ptd);
+		}
+	}
+
+
+	if (modified) {
+
+		//if(done_check)
+			//pr_err("bulk len==13 schedule_ptds  \n");
+		schedule_ptds(hcd);
+		//pr_err("modified\n");
+	}
+
+	vega_dbg1(hcd->self.controller,"handle_done_ptds over>>>>\n");
+}
+
+
+
+static int handshake_hcd(struct usb_hcd *hcd, u32 reg,
+		      u32 mask, u32 done, int usec)
+{
+	u32 result;
+
+	do {
+		result = vega_read32(hcd->regs, reg);
+		
+		if (result == ~0)
+			return -ENODEV;
+		result &= mask;
+		if (result == done)
+			return 0;
+		udelay(1);
+		usec--;
+	} while (usec > 0);
+	return -ETIMEDOUT;
+}
+
+static int handshake(struct vega_device *hcd, u32 reg,
+		      u32 mask, u32 done, int usec)
+{
+	u32 result;
+
+	do {
+		result = vega_read32(hcd->regs, reg);
+		
+		if (result == ~0)
+			return -ENODEV;
+		result &= mask;
+		if (result == done)
+			return 0;
+		udelay(1);
+		usec--;
+	} while (usec > 0);
+	return -ETIMEDOUT;
+}
+
+/* one-time init, only for memory state */
+static int priv_init(struct usb_hcd *hcd)
+{
+	struct vega_hcd		*priv = hcd_to_priv(hcd);
+	u32			hcc_params;
+	int i;
+
+	spin_lock_init(&priv->lock);
+
+	for (i = 0; i < QH_END; i++)
+		INIT_LIST_HEAD(&priv->qh_list[i]);
+
+	/*
+	 * hw default: 1K periodic list heads, one per frame.
+	 * periodic_size can shrink by USBCMD update if hcc_params allows.
+	 */
+	priv->periodic_size = DEFAULT_I_TDPS;
+
+	/* controllers may cache some of the periodic schedule ... */
+	hcc_params = vega_read32(hcd->regs, HC_HCCPARAMS);
+	/* full frame cache */
+	if (HCC_ISOC_CACHE(hcc_params))
+		priv->i_thresh = 8;
+	else /* N microframes cached */
+		priv->i_thresh = 2 + HCC_ISOC_THRES(hcc_params);
+
+	return 0;
+}
+
+static struct vega_qh *qh_alloc(gfp_t flags)
+{
+	struct vega_qh *qh;
+
+	qh = kmem_cache_zalloc(qh_cachep, flags);
+	if (!qh)
+		return NULL;
+
+	INIT_LIST_HEAD(&qh->qh_list);
+	INIT_LIST_HEAD(&qh->qtd_list);
+	qh->slot = -1;
+
+	return qh;
+}
+
+static void qh_free(struct vega_qh *qh)
+{
+	WARN_ON(!list_empty(&qh->qtd_list));
+	WARN_ON(qh->slot > -1);
+	kmem_cache_free(qh_cachep, qh);
+}
+
+/* reset a non-running (STS_HALT == 1) controller */
+static int ehci_reset(struct usb_hcd *hcd)
+{
+	struct vega_hcd *priv = hcd_to_priv(hcd);
+	int ret =0;
+
+	u32 command = vega_read32(hcd->regs, HC_USBCMD);
+
+	command |= CMD_RESET;
+	vega_write32(hcd->regs, HC_USBCMD, command);
+	hcd->state = HC_STATE_HALT;
+	priv->next_statechange = jiffies;
+	
+	vega_write32(hcd->regs, HC_INTERRUPT_REG, 0xffffffff); //FIXME Clear interrupts	
+	vega_write32(hcd->regs, HC_INTERRUPT_ENABLE, 0); //FIXME Clear interrupt enable
+
+	
+	vega_dbg(hcd->self.controller, "HC_INTERRUPT_ENABLE : %x\n", vega_read32(hcd->regs, HC_INTERRUPT_ENABLE));
+	return 0;//FIXME
+	
+	ret = handshake_hcd(hcd, HC_USBCMD, CMD_RESET, 0, 250 * 1000);
+	vega_dbg(hcd->self.controller, "handshake : %d\n", ret);
+	return ret;
+}
+
+static void vega_init_core(struct vega_device *vega)
+{
+	u32 otgctrl = 0;
+	u32 hwmode;
+	u32 mode_ctl;
+
+	/* Low-level chip reset */
+	/*if (vega->rst_gpio) {
+		gpiod_set_value_cansleep(isp->rst_gpio, 1);
+		msleep(50);
+		gpiod_set_value_cansleep(isp->rst_gpio, 0);
+	}*/
+
+	/*
+	 * Reset the host controller, including the CPU interface
+	 * configuration.
+	 */
+	vega_dbg(vega->dev, "vega->regs : %lx \n",(long unsigned int)vega->regs);
+	
+	vega_write32(vega->regs, HC_PORT1_CTRL, 0);
+	 
+	vega_write32(vega->regs, HC_RESET_REG, SW_RESET_RESET_ALL); //FIXME
+	udelay(1000);
+	vega_write32(vega->regs, HC_RESET_REG, 0); //FIXME
+
+	vega_dbg(vega->dev,"SW Reset !! ");
+
+	vega_write32(vega->regs, DC_UNLOCKDEV, 0x00BC0064); //FIXME  75 mHz 
+	//vega_write32(vega->regs, DC_UNLOCKDEV, 0x003f0021); //FIXME  25 mHz
+
+
+	vega_dbg(vega->dev,"Time reg written !! ");
+	
+	//vega_write32(vega->regs, HC_SOF_COUNT, 0xcdb4); //SOF count for full speed hub
+	//vega_write32(vega->regs, HC_FULL_SPEED_SOF_COUNT, 0xcdb4); 
+
+	//vega_write32(vega->regs, HC_FULL_SPEED_TR_IPD, 0x5dc); 
+
+	//vega_write32(vega->regs, HC_FULL_SPEED_HUB_IPD, 0x87); 
+	
+	//dev_err(vega->dev,"HC_SOF_COUNT reg written !! ");
+		    
+   	otgctrl =  (HW_OTG_SE0_EN); 
+   	vega_write32(vega->regs, HC_PORT1_CTRL, otgctrl);
+	otgctrl |=  (HW_OTG_DISABLE);
+	vega_write32(vega->regs, HC_PORT1_CTRL, otgctrl);
+
+	//dev_err(vega->dev,"HC_OTG_STATUS !! %0x",vega_read32(vega->regs,HC_OTG_STATUS) );
+
+	otgctrl |=HW_VBUS_DRV;	 //Set for RPDP board, clear for VU440 board
+	vega_write32(vega->regs, HC_PORT1_CTRL, otgctrl);
+
+	//Wail for VBUS VALID
+	handshake(vega,HC_OTG_STATUS, HW_VBUS_VLD, HW_VBUS_VLD , 250 * 1000 );
+
+	vega_dbg(vega->dev, "HC_OTG_STATUS : %x", vega_read32(vega->regs,HC_OTG_STATUS) );
+
+	otgctrl |=  (HW_DM_PULLDOWN | HW_DP_PULLDOWN);
+	
+	vega_write32(vega->regs, HC_PORT1_CTRL, otgctrl);
+
+	/* Setup HW Mode Control: This assumes a level active-low interrupt */
+	//hwmode = HW_DATA_BUS_32BIT;
+	hwmode = HW_INTR_HIGH_ACT;
+
+
+	/*
+	 * We have to set this first in case we're in 16-bit mode.
+	 * Write it twice to ensure correct upper bits if switching
+	 * to 16-bit mode.
+	 */
+	vega_write32(vega->regs, HC_HW_MODE_CTRL, hwmode);
+	//vega_write32(vega->regs, HC_HW_MODE_CTRL, hwmode);
+	
+	vega_dbg(vega->dev, "HC_HW_MODE_CTRL : %x", hwmode);
+	
+	mode_ctl = vega_read32(vega->regs, HC_HW_MODE_CTRL);
+	
+	vega_dbg(vega->dev, "mode_ctl : %x ",mode_ctl);
+
+
+	dev_info(vega->dev, "bus width: %u, oc: %s",
+		 vega->devflags & VEGA_FLAG_BUS_WIDTH_16 ? 16 : 32,
+		 vega->devflags & VEGA_FLAG_ANALOG_OC ? "analog" : "digital");
+}
+
+int first_interrupt=1;
+
+static irqreturn_t vega_irq(struct usb_hcd *hcd)
+{
+	struct vega_hcd *priv = hcd_to_priv(hcd);
+	u32 imask;
+	irqreturn_t irqret = IRQ_NONE;
+
+	//pr_err( "<***********************vega_irq***********************>\n");
+	
+						
+	spin_lock(&priv->lock);
+
+	vega_dbg1(hcd->self.controller, "HC_HW_MODE_CTRL : %x\n", vega_read32(hcd->regs, HC_HW_MODE_CTRL));
+	
+	imask = vega_read32(hcd->regs, HC_INTERRUPT_REG);
+	vega_dbg1(hcd->self.controller,"HC_INTERRUPT_REG >>>>> %x \n",imask);
+	
+	if (!(hcd->state & HC_STATE_RUNNING))
+		goto leave;
+
+	imask = vega_read32(hcd->regs, HC_INTERRUPT_REG);
+	
+	
+	//pr_err("isr INTR status: %0x\n",imask);
+	
+	vega_dbg1(hcd->self.controller,"HC_INTERRUPT_REG >>>>> %x \n",imask);
+	if (unlikely(imask==0))
+		goto leave;
+	vega_write32(hcd->regs, HC_INTERRUPT_REG, imask); /* Clear */
+	if(imask & (HC_INTL_INT | HC_ATL_INT | HC_ISO_INT))//Checking int/iso/atl interrupts
+	{
+		vega_dbg1(hcd->self.controller,"USB IRQ CLEAR>>>>>\n");
+		vega_dbg1(hcd->self.controller,"priv->int_done_map %x >>>>>\n",priv->int_done_map);
+		vega_dbg1(hcd->self.controller,"priv->atl_done_map %x >>>>>\n",priv->atl_done_map);
+		vega_dbg1(hcd->self.controller,"priv->iso_done_map %x >>>>>\n",priv->iso_done_map);
+		priv->int_done_map |= vega_read32(hcd->regs, HC_INT_PTD_DONEMAP_REG);
+		priv->atl_done_map |= vega_read32(hcd->regs, HC_ATL_PTD_DONEMAP_REG);
+		priv->iso_done_map |= vega_read32(hcd->regs, HC_ISO_PTD_DONEMAP_REG);
+		vega_dbg1(hcd->self.controller,"priv->int_done_map %x >>>>>\n",priv->int_done_map);
+		vega_dbg1(hcd->self.controller,"priv->atl_done_map %x >>>>>\n",priv->atl_done_map);
+		vega_dbg1(hcd->self.controller,"priv->iso_done_map %x >>>>>\n",priv->iso_done_map);
+		
+		//del_timer(&errata2_timer);
+
+		handle_done_ptds(hcd);
+	}
+	
+	if(imask &  HC_DISCONNECT_INT)
+	{
+		device_disconnected = 1;
+		//msleep(10); //Debounce time
+		handshake_hcd(hcd, HC_PORTSC1, PORT_CONNECT, PORT_CONNECT , 100*1000); //Debounce time
+	} 
+	
+	
+	if(imask &  HC_CONNECT_INT)
+	{
+		//msleep(10); //Debounce time
+		handshake_hcd(hcd, HC_PORTSC1, PORT_CONNECT, PORT_CONNECT , 100*1000); //Debounce time
+	} 
+			
+
+	if(imask &  (HC_DISCONNECT_INT | HC_CONNECT_INT))
+	{
+		pr_err("DISCONNECT/CONNECT INTR : %0x\n",imask);
+		
+		//if(first_interrupt)
+		//	first_interrupt = 0;
+		//else
+			usb_hcd_poll_rh_status(hcd);
+	}
+	
+
+	irqret = IRQ_HANDLED;
+leave:
+	spin_unlock(&priv->lock);
+
+	vega_probe_dbg(hcd->self.controller, "<***********************vega_irq over %x***********************>\n", irqret);
+	
+	
+	//pr_err("isr INTR return: \n");
+
+	return irqret;
+	
+}
+
+static int vega_setup(struct usb_hcd *hcd)
+{	
+	struct vega_hcd *priv = hcd_to_priv(hcd);
+	int result;
+	u32 scratch;
+
+	vega_probe_dbg(hcd->self.controller, "<***********************vega_setup***********************>\n");
+	/* Change bus pattern */
+	scratch = vega_read32(hcd->regs, HC_CHIP_ID_REG);
+	
+	vega_dbg(hcd->self.controller, "HC_CHIP_ID_REG %x\n",scratch);
+	
+		/*
+	 * The RESET_HC bit in the SW_RESET register is supposed to reset the
+	 * host controller without touching the CPU interface registers, but at
+	 * least on the ISP1761 it seems to behave as the RESET_ALL bit and
+	 * reset the whole device. We thus can't use it here, so let's reset
+	 * the host controller through the EHCI USB Command register. The device
+	 * has been reset in core code anyway, so this shouldn't matter.
+	 */
+	vega_write32(hcd->regs, HC_BUFFER_STATUS_REG, 0);
+	atl_skipmap_global=NO_TRANSFER_ACTIVE;
+	vega_write32(hcd->regs, HC_ATL_PTD_SKIPMAP_REG, NO_TRANSFER_ACTIVE);
+	int_skipmap_global=NO_TRANSFER_ACTIVE;
+	iso_skipmap_global=NO_TRANSFER_ACTIVE;
+	vega_write32(hcd->regs, HC_INT_PTD_SKIPMAP_REG, NO_TRANSFER_ACTIVE);
+	vega_write32(hcd->regs, HC_ISO_PTD_SKIPMAP_REG, NO_TRANSFER_ACTIVE);
+
+	vega_dbg(hcd->self.controller, "b4 ehci_reset\n");
+
+	result = ehci_reset(hcd);
+	
+	vega_dbg(hcd->self.controller, "after ehci_reset %d\n", result);
+	
+	if (result)
+		return result;
+		
+	vega_dbg(hcd->self.controller, "reset success%d\n", result);
+
+	vega_write32(hcd->regs, HC_INTERRUPT_ENABLE, INTERRUPT_ENABLE_MASK);
+	
+	//pr_err("INTERRUPT_ENABLE_MASK\n\r");
+
+	vega_dbg(hcd->self.controller, "HC_HW_MODE_CTRL : %x\n", vega_read32(hcd->regs, HC_HW_MODE_CTRL));
+	vega_dbg(hcd->self.controller, "HC_INTERRUPT_ENABLE : %x\n", vega_read32(hcd->regs, HC_INTERRUPT_ENABLE));
+	
+	priv->hcs_params = 0x0101; //vega_read32(hcd->regs, HC_HCSPARAMS); FIXME only one port
+
+	vega_probe_dbg(hcd->self.controller, "<***********************vega_setup over***********************>\n");
+
+	return priv_init(hcd);
+	return 0;
+}
+
+
+
+
+static int vega_run(struct usb_hcd *hcd)
+{
+	int retval;
+	u32 temp;
+	u32 command;
+	u32 chipid;
+	vega_probe_dbg(hcd->self.controller, "<***********************vega_run***********************>\n");
+	vega_dbg(hcd->self.controller, "HC_HW_MODE_CTRL : %x\n", vega_read32(hcd->regs, HC_HW_MODE_CTRL));
+	hcd->uses_new_polling = 1;
+
+	hcd->state = HC_STATE_RUNNING;
+
+	/* Set PTD interrupt AND & OR maps */
+	vega_write32(hcd->regs, HC_ATL_IRQ_MASK_AND_REG, 0);
+	vega_write32(hcd->regs, HC_ATL_IRQ_MASK_OR_REG, 0xffffffff);
+	vega_write32(hcd->regs, HC_INT_IRQ_MASK_AND_REG, 0);
+	vega_write32(hcd->regs, HC_INT_IRQ_MASK_OR_REG, 0xffffffff);
+	vega_write32(hcd->regs, HC_ISO_IRQ_MASK_AND_REG, 0);
+	vega_write32(hcd->regs, HC_ISO_IRQ_MASK_OR_REG, 0xffffffff);
+	/* step 23 passed */
+
+	temp = vega_read32(hcd->regs, HC_HW_MODE_CTRL);
+	vega_write32(hcd->regs, HC_HW_MODE_CTRL, temp | HW_GLOBAL_INTR_EN);
+	
+	vega_dbg(hcd->self.controller, "HC_HW_MODE_CTRL : %x\n", vega_read32(hcd->regs, HC_HW_MODE_CTRL));
+
+	command = vega_read32(hcd->regs, HC_USBCMD);
+	command &= ~(CMD_LRESET|CMD_RESET);
+	//command |= CMD_RUN;
+	vega_write32(hcd->regs, HC_USBCMD, command);
+	//while(1);
+	//retval = handshake_hcd(hcd, HC_USBCMD, CMD_RUN, CMD_RUN, 250 * 1000);
+	vega_dbg(hcd->self.controller, "handshake : %x\n",retval);
+	if (retval)
+		return retval;
+
+	/*
+	 * XXX
+	 * Spec says to write FLAG_CF as last config action, priv code grabs
+	 * the semaphore while doing so.
+	 */
+	down_write(&ehci_cf_port_reset_rwsem);
+	/*vega_write32(hcd->regs, HC_CONFIGFLAG, FLAG_CF);
+
+	retval = handshake(hcd, HC_CONFIGFLAG, FLAG_CF, FLAG_CF, 250 * 1000);*/
+	up_write(&ehci_cf_port_reset_rwsem);
+	/*vega_dbg(hcd->self.controller, "handshake : %x\n",retval);
+	if (retval)
+		return retval;*/
+
+	/*errata2_timer_hcd = hcd;
+	timer_setup(&errata2_timer, errata2_function, 0);
+	errata2_timer.expires = jiffies + msecs_to_jiffies(SLOT_CHECK_PERIOD);
+	add_timer(&errata2_timer);*/
+
+	chipid = vega_read32(hcd->regs, HC_CHIP_ID_REG);
+	dev_info(hcd->self.controller, "USB ISP %04x HW rev. %d started\n",
+					chipid & 0xffff, chipid >> 16);
+
+	/* PTD Register Init Part 2, Step 28 */
+
+	/* Setup registers controlling PTD checking */
+	vega_write32(hcd->regs, HC_ATL_PTD_LASTPTD_REG, 0x80000000);
+	vega_write32(hcd->regs, HC_INT_PTD_LASTPTD_REG, 0x80000000);
+	vega_write32(hcd->regs, HC_ISO_PTD_LASTPTD_REG, 0x80000000);
+	atl_skipmap_global=0xffffffff;
+	vega_write32(hcd->regs, HC_ATL_PTD_SKIPMAP_REG, 0xffffffff);
+	int_skipmap_global=0xffffffff;
+	iso_skipmap_global=0xffffffff;
+	vega_write32(hcd->regs, HC_INT_PTD_SKIPMAP_REG, 0xffffffff);
+	vega_write32(hcd->regs, HC_ISO_PTD_SKIPMAP_REG, 0xffffffff);
+	vega_write32(hcd->regs, HC_BUFFER_STATUS_REG,
+						ATL_BUF_FILL | INT_BUF_FILL | ISO_BUF_FILL);
+
+	/* GRR this is run-once init(), being done every time the HC starts.
+	 * So long as they're part of class devices, we can't do it init()
+	 * since the class device isn't created that early.
+	 */
+	vega_probe_dbg(hcd->self.controller, "<***********************vega_run over***********************>\n");
+
+	return 0;	
+}
+
+static int qtd_fill(struct vega_qtd *qtd, void *databuffer, size_t len)
+{
+	qtd->data_buffer = databuffer;
+
+	if (len > MAX_PAYLOAD_SIZE)
+		len = MAX_PAYLOAD_SIZE;
+	qtd->length = len;
+
+	return qtd->length;
+}
+
+static void qtd_list_free(struct list_head *qtd_list)
+{
+	struct vega_qtd *qtd, *qtd_next;
+
+	list_for_each_entry_safe(qtd, qtd_next, qtd_list, qtd_list) {
+		list_del(&qtd->qtd_list);
+		qtd_free(qtd);
+	}
+}
+
+/*
+ * Packetize urb->transfer_buffer into list of packets of size wMaxPacketSize.
+ * Also calculate the PID type (SETUP/IN/OUT) for each packet.
+ */
+#define max_packet(wMaxPacketSize) ((wMaxPacketSize) & 0x07ff)
+static void packetize_urb(struct usb_hcd *hcd,
+		struct urb *urb, struct list_head *head, gfp_t flags)
+{
+	struct vega_qtd *qtd;
+	void *buf;
+	int len, maxpacketsize;
+	u8 packet_type;
+
+	/*
+	 * URBs map to sequences of QTDs:  one logical transaction
+	 */
+
+	if (!urb->transfer_buffer && urb->transfer_buffer_length) {
+		/* XXX This looks like usb storage / SCSI bug */
+		vega_dbg1(hcd->self.controller,
+				"buf is null, dma is %08lx len is %d\n",
+				(long unsigned)urb->transfer_dma,
+				urb->transfer_buffer_length);
+		WARN_ON(1);
+	}
+
+	if (usb_pipein(urb->pipe))
+		packet_type = IN_PID;
+	else
+		packet_type = OUT_PID;
+
+	if (usb_pipecontrol(urb->pipe)) {
+		qtd = qtd_alloc(flags, urb, SETUP_PID);
+		if (!qtd)
+			goto cleanup;
+		qtd_fill(qtd, urb->setup_packet, sizeof(struct usb_ctrlrequest));
+		list_add_tail(&qtd->qtd_list, head);
+
+		/* for zero length DATA stages, STATUS is always IN */
+		if (urb->transfer_buffer_length == 0)
+			packet_type = IN_PID;
+	}
+
+	maxpacketsize = max_packet(usb_maxpacket(urb->dev, urb->pipe,
+						usb_pipeout(urb->pipe)));
+
+	/*
+	 * buffer gets wrapped in one or more qtds;
+	 * last one may be "short" (including zero len)
+	 * and may serve as a control status ack
+	 */
+	buf = urb->transfer_buffer;
+	len = urb->transfer_buffer_length;
+
+	for (;;) {
+		int this_qtd_len;
+
+		qtd = qtd_alloc(flags, urb, packet_type);
+		if (!qtd)
+			goto cleanup;
+		this_qtd_len = qtd_fill(qtd, buf, len);
+		list_add_tail(&qtd->qtd_list, head);
+
+		len -= this_qtd_len;
+		buf += this_qtd_len;
+
+		if (len <= 0)
+			break;
+	}
+
+	/*
+	 * control requests may need a terminating data "status" ack;
+	 * bulk ones may need a terminating short packet (zero length).
+	 */
+	if (urb->transfer_buffer_length != 0) {
+		int one_more = 0;
+
+		if (usb_pipecontrol(urb->pipe)) {
+			one_more = 1;
+			if (packet_type == IN_PID)
+				packet_type = OUT_PID;
+			else
+				packet_type = IN_PID;
+		} else if (usb_pipebulk(urb->pipe)
+				&& (urb->transfer_flags & URB_ZERO_PACKET)
+				&& !(urb->transfer_buffer_length %
+							maxpacketsize)) {
+			one_more = 1;
+		}
+		if (one_more) {
+			qtd = qtd_alloc(flags, urb, packet_type);
+			if (!qtd)
+				goto cleanup;
+
+			/* never any data in such packets */
+			qtd_fill(qtd, NULL, 0);
+			list_add_tail(&qtd->qtd_list, head);
+		}
+	}
+
+	return;
+
+cleanup:
+	qtd_list_free(head);
+}
+
+static void vega_stop(struct usb_hcd *hcd)
+{
+	dev_err(hcd->self.controller, "<***********************vega_stop***********************>\n");
+	
+	
+}
+
+static void vega_shutdown(struct usb_hcd *hcd)
+{
+	dev_err(hcd->self.controller, "<***********************vega_shutdown***********************>\n");
+	
+	
+}
+
+
+
+static int vega_urb_enqueue(struct usb_hcd *hcd, struct urb *urb,
+		gfp_t mem_flags)
+{
+	struct vega_hcd *priv = hcd_to_priv(hcd);
+	struct list_head *ep_queue;
+	struct vega_qh *qh, *qhit;
+	unsigned long spinflags;
+	LIST_HEAD(new_qtds);
+	int retval;
+	int qh_in_queue;
+	
+	//pr_err("vega_urb_enqueue\n");
+	
+	vega_probe_dbg(hcd->self.controller, "<***********************vega_urb_enqueue***********************>\n");
+
+	vega_dbg2(hcd->self.controller,"urb->pipe : %x\n",urb->pipe);
+
+	switch (usb_pipetype(urb->pipe)) {
+	case PIPE_CONTROL:
+		ep_queue = &priv->qh_list[QH_CONTROL];
+		vega_dbg2(hcd->self.controller,"PIPE_CONTROL\n");
+		break;
+	case PIPE_BULK:
+		ep_queue = &priv->qh_list[QH_BULK];
+		vega_dbg2(hcd->self.controller,"PIPE_BULK\n");
+		break;
+	case PIPE_INTERRUPT:
+		if (urb->interval < 0)
+			return -EINVAL;
+		/* FIXME: Check bandwidth  */
+		ep_queue = &priv->qh_list[QH_INTERRUPT];
+		vega_dbg1(hcd->self.controller,"PIPE_INTERRUPT\n");
+		break;
+	case PIPE_ISOCHRONOUS:		
+		vega_dbg1(hcd->self.controller,"PIPE_ISOCHRONOUS\n");		
+		if (urb->interval < 0)
+			return -EINVAL;
+		/* FIXME: Check bandwidth  */
+		ep_queue = &priv->qh_list[QH_ISOCHRONOUS];			
+		break;
+	default:
+		vega_dbg1(hcd->self.controller, "%s: unknown pipe type\n",
+							__func__);
+		vega_dbg1(hcd->self.controller,"unknown pipe type\n");						
+		return -EPIPE;
+	}
+
+	if (usb_pipein(urb->pipe))
+		urb->actual_length = 0;
+
+	packetize_urb(hcd, urb, &new_qtds, mem_flags);
+	if (list_empty(&new_qtds))
+		return -ENOMEM;
+
+	retval = 0;
+	spin_lock_irqsave(&priv->lock, spinflags);
+
+	if (!test_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags)) {
+		retval = -ESHUTDOWN;
+		qtd_list_free(&new_qtds);
+		goto out;
+	}
+	retval = usb_hcd_link_urb_to_ep(hcd, urb);
+	if (retval) {
+		qtd_list_free(&new_qtds);
+		goto out;
+	}
+
+	qh = urb->ep->hcpriv;
+	if (qh) {
+		qh_in_queue = 0;
+		list_for_each_entry(qhit, ep_queue, qh_list) {
+			if (qhit == qh) {
+				qh_in_queue = 1;
+				break;
+			}
+		}
+		if (!qh_in_queue)
+			list_add_tail(&qh->qh_list, ep_queue);
+	} else {
+		qh = qh_alloc(GFP_ATOMIC);
+		if (!qh) {
+			retval = -ENOMEM;
+			usb_hcd_unlink_urb_from_ep(hcd, urb);
+			qtd_list_free(&new_qtds);
+			goto out;
+		}
+		list_add_tail(&qh->qh_list, ep_queue);
+		urb->ep->hcpriv = qh;
+	}
+
+	list_splice_tail(&new_qtds, &qh->qtd_list);
+	schedule_ptds(hcd);
+
+	int imask = vega_read32(hcd->regs, HC_INTERRUPT_ENABLE);
+	//pr_err("HC_INTERRUPT_ENABLE >>>>> %x \n",imask);
+
+
+	//vega_dbg1(hcd->self.controller,"priv->int_done_map %x >>>>>\n",	vega_read32(hcd->regs, HC_ATL_PTD_DONEMAP_REG));
+
+	vega_dbg1(hcd->self.controller,"vega_urb_enqueue OVER %x\n",retval);
+	/*	errata2_timer_hcd = hcd;
+		timer_setup(&errata2_timer, errata2_function, 0);
+		errata2_timer.expires = jiffies + msecs_to_jiffies(SLOT_CHECK_PERIOD);
+		add_timer(&errata2_timer);*/
+
+out:
+	spin_unlock_irqrestore(&priv->lock, spinflags);
+	return retval;
+
+}
+
+
+static void kill_transfer(struct usb_hcd *hcd, struct urb *urb,
+		struct vega_qh *qh)
+{
+	struct vega_hcd *priv = hcd_to_priv(hcd);
+	int skip_map;
+
+	WARN_ON(qh->slot == -1);
+
+	/* We need to forcefully reclaim the slot since some transfers never
+	   return, e.g. interrupt transfers and NAKed bulk transfers. */
+	if (usb_pipecontrol(urb->pipe) || usb_pipebulk(urb->pipe)) {
+		skip_map = atl_skipmap_global; //vega_read32(hcd->regs, HC_ATL_PTD_SKIPMAP_REG);
+		skip_map |= (1 << qh->slot);
+		atl_skipmap_global=skip_map;
+		vega_write32(hcd->regs, HC_ATL_PTD_SKIPMAP_REG, skip_map);
+		priv->atl_slots[qh->slot].qh = NULL;
+		priv->atl_slots[qh->slot].qtd = NULL;
+	} 
+	else if (usb_pipeisoc(urb->pipe))
+	{
+		skip_map = iso_skipmap_global; //vega_read32(hcd->regs, HC_INT_PTD_SKIPMAP_REG);
+		skip_map |= (1 << qh->slot);
+		iso_skipmap_global=skip_map;
+		vega_write32(hcd->regs, HC_ISO_PTD_SKIPMAP_REG, skip_map);
+		priv->iso_slots[qh->slot].qh = NULL;
+		priv->iso_slots[qh->slot].qtd = NULL;
+	}
+	else {
+		skip_map = int_skipmap_global; //vega_read32(hcd->regs, HC_INT_PTD_SKIPMAP_REG);
+		skip_map |= (1 << qh->slot);
+		int_skipmap_global=skip_map;
+		vega_write32(hcd->regs, HC_INT_PTD_SKIPMAP_REG, skip_map);
+		priv->int_slots[qh->slot].qh = NULL;
+		priv->int_slots[qh->slot].qtd = NULL;
+	}
+
+	qh->slot = -1;
+}
+
+/*
+ * Retire the qtds beginning at 'qtd' and belonging all to the same urb, killing
+ * any active transfer belonging to the urb in the process.
+ */
+static void dequeue_urb_from_qtd(struct usb_hcd *hcd, struct vega_qh *qh,
+						struct vega_qtd *qtd)
+{
+	struct urb *urb;
+	int urb_was_running;
+
+	urb = qtd->urb;
+	urb_was_running = 0;
+	list_for_each_entry_from(qtd, &qh->qtd_list, qtd_list) {
+		if (qtd->urb != urb)
+			break;
+
+		if (qtd->status >= QTD_XFER_STARTED)
+			urb_was_running = 1;
+		if (last_qtd_of_urb(qtd, qh) &&
+					(qtd->status >= QTD_XFER_COMPLETE))
+			urb_was_running = 0;
+
+		if (qtd->status == QTD_XFER_STARTED)
+			kill_transfer(hcd, urb, qh);
+		qtd->status = QTD_RETIRE;
+	}
+
+	if(vega_hub_speed == HUB_SPEED_HIGH) {
+		if ((urb->dev->speed != USB_SPEED_HIGH) && urb_was_running) {
+			qh->tt_buffer_dirty = 1;
+			
+				if (usb_hub_clear_tt_buffer(urb))
+					/* Clear failed; let's hope things work anyway */
+					qh->tt_buffer_dirty = 0;
+		}
+		
+	}
+
+	// if ((urb->dev->speed != USB_SPEED_HIGH) && urb_was_running) {
+	// 	qh->tt_buffer_dirty = 1;
+	// 	//pr_err("#####################clear tt\n");
+	// 	if(vega_hub_speed == HUB_SPEED_HIGH) {
+	// 		if (usb_hub_clear_tt_buffer(urb))
+	// 			/* Clear failed; let's hope things work anyway */
+	// 			qh->tt_buffer_dirty = 0;
+	// 	}
+	// }
+}
+
+static int vega_urb_dequeue(struct usb_hcd *hcd, struct urb *urb,
+		int status)
+{
+	struct vega_hcd *priv = hcd_to_priv(hcd);
+	unsigned long spinflags;
+	struct vega_qh *qh;
+	struct vega_qtd *qtd;
+	int retval = 0;
+
+	vega_probe_dbg(hcd->self.controller, "<***********************vega_urb_dequeue***********************>\n");
+	//pr_err("vega_urb_dequeue schedule_ptds\n");
+	
+	spin_lock_irqsave(&priv->lock, spinflags);
+	retval = usb_hcd_check_unlink_urb(hcd, urb, status);
+	if (retval)
+		goto out;
+
+	qh = urb->ep->hcpriv;
+	if (!qh) {
+		retval = -EINVAL;
+		goto out;
+	}
+
+	list_for_each_entry(qtd, &qh->qtd_list, qtd_list)
+		if (qtd->urb == urb) {
+			dequeue_urb_from_qtd(hcd, qh, qtd);
+			list_move(&qtd->qtd_list, &qh->qtd_list);
+			break;
+		}
+
+	urb->status = status;
+
+	
+	schedule_ptds(hcd);
+	
+	//pr_err("vega_urb_dequeue\n");
+	vega_dbg1(hcd->self.controller, "<***********************vega_urb_dequeue OVER %x***********************>\n",retval);
+
+
+out:
+	spin_unlock_irqrestore(&priv->lock, spinflags);
+	return retval;
+}
+
+static void vega_endpoint_disable(struct usb_hcd *hcd,
+		struct usb_host_endpoint *ep)
+{
+	
+	struct vega_hcd *priv = hcd_to_priv(hcd);
+	unsigned long spinflags;
+	struct vega_qh *qh, *qh_iter;
+	int i;
+	vega_probe_dbg(hcd->self.controller, "<***********************vega_endpoint_disable***********************>\n");
+	spin_lock_irqsave(&priv->lock, spinflags);
+
+	qh = ep->hcpriv;
+	if (!qh)
+		goto out;
+		
+	schedule_ptds(hcd);	
+
+	WARN_ON(!list_empty(&qh->qtd_list));
+
+	for (i = 0; i < QH_END; i++)
+		list_for_each_entry(qh_iter, &priv->qh_list[i], qh_list)
+			if (qh_iter == qh) {
+				list_del(&qh_iter->qh_list);
+				i = QH_END;
+				break;
+			}
+	qh_free(qh);
+	ep->hcpriv = NULL;
+	
+
+	//pr_err("vega_endpoint_disable schedule_ptds\n");
+
+
+out:
+
+	//pr_err("vega_endpoint_disable\n");
+	
+	
+	spin_unlock_irqrestore(&priv->lock, spinflags);
+	vega_dbg1(hcd->self.controller, "<***********************vega_endpoint_disable over***********************>\n");
+
+}
+
+static int vega_get_frame(struct usb_hcd *hcd)
+{
+	dev_err(hcd->self.controller, "<***********************vega_get_frame***********************>\n");
+	
+	return 0;
+}
+
+static int vega_hub_status_data(struct usb_hcd *hcd, char *buf)
+{
+	struct vega_hcd *priv = hcd_to_priv(hcd);
+	u32 temp, status = 0;
+	u32 mask;
+	int retval = 1;
+	unsigned long flags;
+	
+	pr_err("vega_hub_status_data\n");
+	/* if !PM, root hub timers won't get shut down ... */
+	/*if (!HC_IS_RUNNING(hcd->state))
+		return 0;*/
+
+	/* init status to no-changes */
+	buf[0] = 0;
+	//mask = PORT_CSC;
+
+	//spin_lock_irqsave(&priv->lock, flags);
+	/*temp = vega_read32(hcd->regs, HC_PORTSC1);
+
+	if (temp & PORT_OWNER) {
+		if (temp & PORT_CSC) {
+			temp &= ~PORT_CSC;
+			vega_write32(hcd->regs, HC_PORTSC1, temp);
+			vega_dbg4(hcd->self.controller, "<***********************HC_PORTSC1 write %x***********************>\n",temp);
+
+			goto done;
+		}
+	}*/
+
+	/*
+	 * Return status information even for ports with OWNER set.
+	 * Otherwise hub_wq wouldn't see the disconnect event when a
+	 * high-speed device is switched over to the companion
+	 * controller by the user.
+	 */
+
+	/*if ((temp & mask) != 0
+			|| ((temp & PORT_RESUME) != 0
+				&& time_after_eq(jiffies,
+					priv->reset_done))) {*/
+		buf [0] |= 1 << (0 + 1);
+		status = STS_PCD;
+		
+		
+		//buf [0] = 0x03;
+	//}
+	/* FIXME autosuspend idle root hubs */
+//done:
+	//spin_unlock_irqrestore(&priv->lock, flags);
+	//pr_err("<***********************vega_hub_status_data over status %x, retval %x***********************>\n",status,retval);
+
+	return 1 ;//status ? retval : 0;
+}
+
+static void vega_hub_descriptor(struct vega_hcd *priv,
+		struct usb_hub_descriptor *desc)
+{
+	int ports = HCS_N_PORTS(priv->hcs_params);
+	u16 temp;
+
+	desc->bDescriptorType = USB_DT_HUB;
+	/* priv 1.0, 2.3.9 says 20ms max */
+	desc->bPwrOn2PwrGood = 10;
+	desc->bHubContrCurrent = 0;
+
+	desc->bNbrPorts = ports;
+	temp = 1 + (ports / 8);
+	desc->bDescLength = 7 + 2 * temp;
+
+	/* ports removable, and usb 1.0 legacy PortPwrCtrlMask */
+	memset(&desc->u.hs.DeviceRemovable[0], 0, temp);
+	memset(&desc->u.hs.DeviceRemovable[temp], 0xff, temp);
+
+	/* per-port overcurrent reporting */
+	temp = HUB_CHAR_INDV_PORT_OCPM;
+	if (HCS_PPC(priv->hcs_params))
+		/* per-port power control */
+		temp |= HUB_CHAR_INDV_PORT_LPSM;
+	else
+		/* no power switching */
+		temp |= HUB_CHAR_NO_LPSM;
+
+	if(vega_hub_speed == HUB_SPEED_HIGH)
+		temp |= USB_HUB_PR_HS_MULTI_TT; //FIXME 
+
+	desc->wHubCharacteristics = cpu_to_le16(temp);
+}
+
+#define	PORT_WAKE_BITS	(PORT_WKOC_E|PORT_WKDISC_E|PORT_WKCONN_E)
+
+static int check_reset_complete(struct usb_hcd *hcd, int index,
+		int port_status)
+{
+	//if (!(port_status & PORT_CONNECT))
+	///	return port_status;
+	
+
+	int ret = handshake_hcd(hcd, HC_PORTSC1 , PORT_PE, PORT_PE , 100*1000);
+	if(ret != 0) {
+		pr_err("error!!!!!port not enabled\n");
+		return 0;
+	}
+	
+	//pr_err("++++++++++++++++++++++++++port  enabled  \n");	
+	
+	port_status = vega_read32(hcd->regs, HC_PORTSC1);
+
+	vega_write32(hcd->regs, HC_USBCMD, CMD_RUN); //FIXME
+
+	vega_dbg4(hcd->self.controller, "check_reset_complete, HC_USBCMD %x +++++ \n",CMD_RUN);
+
+	/* if reset finished and it's still not enabled -- handoff */
+	if (!(port_status & PORT_HIGH_SPEED)) {
+	
+		dev_info(hcd->self.controller,
+					"port %d full speed --> companion\n",
+					index + 1);
+					
+		vega_hub_speed = HUB_SPEED_FULL;
+
+		//port_status |= PORT_OWNER;
+		//port_status &= ~PORT_RWC_BITS;
+		//vega_write32(hcd->regs, HC_PORTSC1, port_status);
+		vega_dbg4(hcd->self.controller, "check_reset_complete, HC_PORTSC1 Wr %x +++++ \n",port_status);
+
+
+	} else {
+		dev_info(hcd->self.controller, "port %d high speed\n",
+								index + 1);
+		vega_hub_speed = HUB_SPEED_HIGH;
+	}
+
+	return port_status;
+}
+
+static int vega_hub_control(struct usb_hcd *hcd, u16 typeReq,
+		u16 wValue, u16 wIndex, char *buf, u16 wLength)
+{
+	
+	struct vega_hcd *priv = hcd_to_priv(hcd);
+	int ports = HCS_N_PORTS(priv->hcs_params);
+	u32 temp, status;
+	unsigned long flags;
+	int retval = 0;
+	int i=0;
+	unsigned selector;
+	
+	vega_hub_cotrol_dbg1( "<***********************vega_hub_control wValue =%x, wIndex =%x, wLength =%x, typeReqn =%x\n", wValue, wIndex, wLength, typeReq);
+
+	/*
+	 * FIXME:  support SetPortFeatures USB_PORT_FEAT_INDICATOR.
+	 * HCS_INDICATOR may say we can change LEDs to off/amber/green.
+	 * (track current state ourselves) ... blink for diagnostics,
+	 * power, "this is the one", etc.  EHCI spec supports this.
+	 */
+
+	spin_lock_irqsave(&priv->lock, flags);
+	switch (typeReq) {
+	case ClearHubFeature:
+		vega_hub_cotrol_dbg(hcd->self.controller, "ClearHubFeature +++++ \n");
+		switch (wValue) {
+		case C_HUB_LOCAL_POWER:
+		case C_HUB_OVER_CURRENT:
+			/* no hub-wide feature/status flags */
+			break;
+		default:
+			goto error;
+		}
+		break;
+	case ClearPortFeature:
+		vega_hub_cotrol_dbg(hcd->self.controller, "ClearPortFeature +++++ \n");
+		if (!wIndex || wIndex > ports)
+			goto error;
+		wIndex--;
+		temp = vega_read32(hcd->regs, HC_PORTSC1);
+		vega_hub_cotrol_dbg(hcd->self.controller, "hub control HC_PORTSC1 read :%x, \n",temp);
+		/*
+		 * Even if OWNER is set, so the port is owned by the
+		 * companion controller, hub_wq needs to be able to clear
+		 * the port-change status bits (especially
+		 * USB_PORT_STAT_C_CONNECTION).
+		 */
+		vega_hub_cotrol_dbg(hcd->self.controller, "ClearPortFeature +++++, %d \n",wValue);
+		switch (wValue) {
+		case USB_PORT_FEAT_ENABLE:
+			//pr_err("++++++++clear++++++++USB_PORT_FEAT_ENABLE++++++++++++++++++++");
+			//vega_write32(hcd->regs, HC_PORTSC1, temp & ~PORT_PE);
+			vega_hub_cotrol_dbg(hcd->self.controller, "HC_PORTSC1 write :%x, \n",(temp & ~PORT_PE));
+
+			break;
+		case USB_PORT_FEAT_C_ENABLE:
+			vega_hub_cotrol_dbg(hcd->self.controller,"+++++++clear+++++++++USB_PORT_FEAT_C_ENABLE++++++++++++++++++++");
+			/* XXX error? */
+			break;
+		case USB_PORT_FEAT_SUSPEND:
+		
+			vega_hub_cotrol_dbg1(hcd->self.controller,"++++++++++CL++++++USB_PORT_FEAT_SUSPEND++++++++++++++++++++");
+			if (temp & PORT_RESET)
+				goto error;
+
+			if (temp & PORT_SUSPEND) {
+				if ((temp & PORT_PE) == 0)
+					goto error;
+				/* resume signaling for 20 msec */
+				vega_write32(hcd->regs, HC_PORTSC1,
+							temp | PORT_RESUME);
+				vega_hub_cotrol_dbg(hcd->self.controller, "HC_PORTSC1 write :%x, \n",(temp | PORT_RESUME));
+			
+				priv->reset_done = jiffies +
+					msecs_to_jiffies(USB_RESUME_TIMEOUT);
+			}
+			break;
+		case USB_PORT_FEAT_C_SUSPEND:
+			/* we auto-clear this feature */
+			break;
+		case USB_PORT_FEAT_POWER:
+			vega_hub_cotrol_dbg(hcd->self.controller,"++++++++++++++++USB_PORT_FEAT_POWER++++++++++++++++++++");
+			//if (HCS_PPC(priv->hcs_params))
+			//	vega_write32(hcd->regs, HC_PORTSC1,	temp & ~PORT_POWER);
+				vega_hub_cotrol_dbg(hcd->self.controller, "HC_PORTSC1 write :%x, \n",(temp & ~PORT_POWER));
+			
+			break;
+		case USB_PORT_FEAT_C_CONNECTION:
+		
+			vega_hub_cotrol_dbg(hcd->self.controller,"++++++++++++++++USB_PORT_FEAT_C_CONNECTION++++++++++++++++++++");
+			//vega_write32(hcd->regs, HC_PORTSC1, temp | PORT_CSC);
+			break;
+		case USB_PORT_FEAT_C_OVER_CURRENT:
+			vega_hub_cotrol_dbg(hcd->self.controller,"++++++++++++++++USB_PORT_FEAT_C_OVER_CURRENT++++++++++++++++++++");
+			/* XXX error ?*/
+			break;
+		case USB_PORT_FEAT_C_RESET:
+			vega_hub_cotrol_dbg(hcd->self.controller,"++++++++++++++++USB_PORT_FEAT_C_RESET++++++++++++++++++++");
+			/* GetPortStatus clears reset */
+			break;
+		default:
+			goto error;
+		}
+		//vega_read32(hcd->regs, HC_USBCMD);
+		break;
+	case GetHubDescriptor:
+		vega_hub_cotrol_dbg(hcd->self.controller, "GetHubDescriptor +++++ \n");
+		vega_hub_descriptor(priv, (struct usb_hub_descriptor *) buf);
+		break;
+	case GetHubStatus:
+		vega_hub_cotrol_dbg(hcd->self.controller, "GetHubStatus +++++ \n");
+		/* no hub-wide feature/status flags */
+		memset(buf, 0, 4);
+		break;
+	case GetPortStatus:			
+		vega_hub_cotrol_dbg(hcd->self.controller, "GetPortStatus +++++ \n");
+		if (!wIndex || wIndex > ports)
+			goto error;
+		wIndex--;
+		status = 0;
+		temp = handshake_hcd(hcd, HC_PORTSC1, PORT_CONNECT, PORT_CONNECT , 75*1000);
+		temp = vega_read32(hcd->regs, HC_PORTSC1);
+		vega_hub_cotrol_dbg(hcd->self.controller, "GetPortStatus %x +++++ \n",temp);
+		/* wPortChange bits */
+		if (device_disconnected){
+			status |= USB_PORT_STAT_C_CONNECTION << 16;
+			device_disconnected=0;			
+		}
+
+
+		/* whoever resumes must GetPortStatus to complete it!! */
+		if (temp & PORT_RESUME) {
+			vega_hub_cotrol_dbg1(hcd->self.controller, "Port resume should be skipped.\n");
+
+			/* Remote Wakeup received? */
+			if (!priv->reset_done) {
+				/* resume signaling for 20 msec */
+				priv->reset_done = jiffies
+						+ msecs_to_jiffies(20);
+				/* check the port again */
+				mod_timer(&hcd->rh_timer, priv->reset_done);
+			}
+
+			/* resume completed? */
+			else if (time_after_eq(jiffies,
+					priv->reset_done)) {
+				status |= USB_PORT_STAT_C_SUSPEND << 16;
+				priv->reset_done = 0;
+
+				/* stop resume signaling */
+				temp = vega_read32(hcd->regs, HC_PORTSC1);
+				vega_write32(hcd->regs, HC_PORTSC1,
+					temp & ~(PORT_RESUME));
+
+				retval = handshake_hcd(hcd, HC_PORTSC1,
+					   PORT_RESUME, 0, 2000 /* 2msec */);
+				vega_hub_cotrol_dbg(hcd->self.controller, "HC_PORTSC1 read :%x, \n",(vega_read32(hcd->regs, HC_PORTSC1)));
+
+				if (retval != 0) {
+					vega_hub_cotrol_dbg(hcd->self.controller,
+						"port %d resume error %d\n",
+						wIndex + 1, retval);
+					goto error;
+				}
+				temp &= ~(PORT_SUSPEND|PORT_RESUME|(3<<10));
+			}
+		}
+
+		/* whoever resets must GetPortStatus to complete it!! */
+		if ((temp & PORT_RESET)
+				&& time_after_eq(jiffies,
+					priv->reset_done)) {
+			vega_hub_cotrol_dbg(hcd->self.controller, "PORT_RESET\n");		
+			///status |= USB_PORT_STAT_C_RESET << 16;
+			priv->reset_done = 0;
+
+			/* force reset to complete */
+			vega_write32(hcd->regs, HC_PORTSC1, temp & ~PORT_RESET);
+			vega_dbg4(hcd->self.controller, "HC_PORTSC1 wr :%x, \n",(temp & ~PORT_RESET));
+
+			/* REVISIT:  some hardware needs 550+ usec to clear
+			 * this bit; seems too long to spin routinely...
+			 */
+			/*retval = handshake_hcd(hcd, HC_PORTSC1,
+					PORT_RESET, 0, 750);*/
+			retval=0;		
+			vega_hub_cotrol_dbg(hcd->self.controller, "HC_PORTSC1 wr :%x, \n",(vega_read32(hcd->regs, HC_PORTSC1)));
+
+			if (retval != 0) {
+				vega_hub_cotrol_dbg(hcd->self.controller, "port %d reset error %d\n",
+						wIndex + 1, retval);
+				goto error;
+			}
+
+			/* see what we found out */
+			temp = check_reset_complete(hcd, wIndex,	vega_read32(hcd->regs, HC_PORTSC1));
+			if(temp & PORT_HIGH_SPEED)
+				status |= USB_PORT_STAT_HIGH_SPEED;
+			//else
+				//vega_hub_cotrol_dbg1(hcd->self.controller, "**********************Full speed \n");
+			
+			
+		}
+		/*
+		 * Even if OWNER is set, there's no harm letting hub_wq
+		 * see the wPortStatus values (they should all be 0 except
+		 * for PORT_POWER anyway).
+		 */
+
+		/*if (temp & PORT_OWNER)
+			vega_hub_cotrol_dbg(hcd->self.controller, "PORT_OWNER is set\n");*/
+
+		if (temp & PORT_CONNECT) {
+			vega_hub_cotrol_dbg(hcd->self.controller, "++++++++++++++++++++PORT_CONNECT \n");
+			status |= USB_PORT_STAT_CONNECTION;
+			/* status may be from integrated TT */
+		
+		}else
+			status |= (USB_PORT_STAT_C_CONNECTION << 16);
+
+		if (temp & PORT_PE)
+			status |= USB_PORT_STAT_ENABLE;
+		if (temp & (PORT_SUSPEND|PORT_RESUME))
+			status |= USB_PORT_STAT_SUSPEND;
+		if (temp & PORT_RESET)
+			status |= USB_PORT_STAT_RESET;
+		if (temp & PORT_POWER)
+			status |= USB_PORT_STAT_POWER;
+			
+		vega_hub_cotrol_dbg1(hcd->self.controller, "**********************port status %x  \n", status);
+
+		put_unaligned(cpu_to_le32(status), (__le32 *) buf);
+		break;
+	case SetHubFeature:
+	
+		vega_hub_cotrol_dbg(hcd->self.controller,"++++++++++++++++SetHubFeature++++++++++++++++++++");
+		vega_hub_cotrol_dbg(hcd->self.controller, "SetHubFeature +++++ \n");
+		switch (wValue) {
+		case C_HUB_LOCAL_POWER:
+		case C_HUB_OVER_CURRENT:
+			/* no hub-wide feature/status flags */
+			break;
+		default:
+			goto error;
+		}
+		break;
+	case SetPortFeature:
+		vega_hub_cotrol_dbg(hcd->self.controller, "SetPortFeature +++++ \n");
+		selector = wIndex >> 8;
+		wIndex &= 0xff;
+		if (!wIndex || wIndex > ports)
+			goto error;
+		wIndex--;
+		temp = vega_read32(hcd->regs, HC_PORTSC1);
+		/*if (temp & PORT_OWNER)
+			break;*/
+
+/*		temp &= ~PORT_RWC_BITS; */
+		vega_hub_cotrol_dbg(hcd->self.controller, "SetPortFeature +++++ switch : %d \n",wValue);
+		switch (wValue) {
+		
+		case USB_PORT_FEAT_ENABLE:
+			vega_hub_cotrol_dbg1(hcd->self.controller,"++++++++++set++++++++++++++++USB_PORT_FEAT_ENABLE \n");
+			vega_write32(hcd->regs, HC_PORTSC1, temp | PORT_PE);
+			break;
+
+		case USB_PORT_FEAT_SUSPEND:
+			vega_hub_cotrol_dbg1(hcd->self.controller,"+++++++++++set+++++++++++++++USB_PORT_FEAT_SUSPEND \n");
+			if ((temp & PORT_PE) == 0
+					|| (temp & PORT_RESET) != 0)
+				goto error;
+
+			vega_write32(hcd->regs, HC_PORTSC1, temp | PORT_SUSPEND);
+			break;
+		case USB_PORT_FEAT_POWER:
+		vega_hub_cotrol_dbg(hcd->self.controller,"+++++++++++set+++++++++++++++USB_PORT_FEAT_POWER \n");
+			//if (HCS_PPC(priv->hcs_params))
+				//vega_write32(hcd->regs, HC_PORTSC1,	temp | PORT_POWER);
+			break;
+		case USB_PORT_FEAT_RESET:
+		
+		vega_hub_cotrol_dbg(hcd->self.controller,"+++++++++++set+++++++++++++++USB_PORT_FEAT_RESET \n");
+				if (temp & PORT_RESUME)
+				goto error;
+			/* line status bits may report this as low speed,
+			 * which can be fine if this root hub has a
+			 * transaction translator built in.
+			 */
+			/*if ((temp & (PORT_PE|PORT_CONNECT)) == PORT_CONNECT
+					&& PORT_USB11(temp)) {
+				temp |= PORT_OWNER;
+			} else {*/
+				temp |= PORT_RESET;
+				temp &= ~PORT_PE;
+				
+				//pr_err("PORT_RESET\n");
+
+				/*
+				 * caller must wait, then call GetPortStatus
+				 * usb 2.0 spec says 50 ms resets on root
+				 */
+				priv->reset_done = jiffies +
+					msecs_to_jiffies(50);
+			//}
+			vega_write32(hcd->regs, HC_USBCMD, 0);//Set Run/Stop bit zero
+			vega_write32(hcd->regs, HC_PORTSC1, temp);
+			break;
+		default:
+			goto error;
+		}
+		//vega_read32(hcd->regs, HC_USBCMD);
+		break;
+
+	default:
+error:
+		/* "stall" on error */
+		vega_dbg(hcd->self.controller, "error \n");
+		retval = -EPIPE;
+	}
+	spin_unlock_irqrestore(&priv->lock, flags);
+	vega_hub_cotrol_dbg(hcd->self.controller, "vega_hub_control over %x\n",retval);
+	vega_hub_cotrol_dbg(hcd->self.controller, "SetPortFeature +++++ HC_PORTSC1 : %x \n",temp);
+
+	return retval;
+	
+}
+
+static void vega_clear_tt_buffer_complete(struct usb_hcd *hcd,
+						struct usb_host_endpoint *ep)
+{
+	//dev_err(hcd->self.controller, "<***********************vega_clear_tt_buffer_complete***********************>\n");
+	
+	
+	struct vega_hcd *priv = hcd_to_priv(hcd);
+	struct vega_qh *qh = ep->hcpriv;
+	unsigned long spinflags;
+
+	if (!qh)
+		return;
+
+	spin_lock_irqsave(&priv->lock, spinflags);
+	qh->tt_buffer_dirty = 0;
+	
+	//pr_err("vega_clear_tt_buffer_complete schedule_ptds\n");
+	schedule_ptds(hcd);
+	spin_unlock_irqrestore(&priv->lock, spinflags);
+	
+}
+
+static const struct hc_driver vega_hc_driver = {
+	.description		= "VEGA HCD",
+	.product_desc		= "VEGA USB Host Cotroller Driver",
+	.hcd_priv_size		= sizeof(struct vega_hcd),
+
+	/*
+	 * generic hardware linkage
+	 */
+	.irq			= vega_irq,
+	.flags			= HCD_MEMORY | HCD_USB2 ,
+
+	/*
+	 * basic lifecycle operations
+	 */
+	.reset			= vega_setup,
+	.start			= vega_run,
+	.stop			= vega_stop,
+	.shutdown		= vega_shutdown,
+
+	/*
+	 * managing i/o requests and associated device resources
+	 */
+	.urb_enqueue		= vega_urb_enqueue,
+	.urb_dequeue		= vega_urb_dequeue,
+	.endpoint_disable	= vega_endpoint_disable,
+	//.endpoint_reset		= vega_endpoint_reset,
+
+	/*
+	 * scheduling support
+	 */
+	.get_frame_number	= vega_get_frame,
+
+	/*
+	 * root hub support
+	 */
+	.hub_status_data	= vega_hub_status_data,
+	.hub_control		= vega_hub_control,
+
+	.clear_tt_buffer_complete = vega_clear_tt_buffer_complete,
+};
+
+int vega_hcd_register(struct vega_hcd *priv, void __iomem *regs,
+			 struct resource *mem, int irq, unsigned long irqflags,
+			 struct device *dev)
+{
+	struct usb_hcd *hcd;
+	int ret;
+
+	hcd = usb_create_hcd(&vega_hc_driver, dev, dev_name(dev));
+	if (!hcd)
+		return -ENOMEM;
+
+	*(struct vega_hcd **)hcd->hcd_priv = priv;
+
+	priv->hcd = hcd;
+
+	init_memory(priv);
+
+	hcd->irq = irq;
+	hcd->regs = regs;
+	hcd->rsrc_start = mem->start;
+	hcd->rsrc_len = resource_size(mem);
+
+	hcd->has_tt = 1;
+	
+	/* This driver doesn't support wakeup requests */
+	hcd->cant_recv_wakeups = 1;
+
+	ret = usb_add_hcd(hcd, irq, irqflags);
+	if (ret)
+		goto error;
+
+	device_wakeup_enable(hcd->self.controller);
+
+	return 0;
+
+error:
+	usb_put_hcd(hcd);
+	return ret;
+}
+
+int vega_register(struct resource *mem, int irq, unsigned long irqflags,
+		     struct device *dev, unsigned int devflags)
+{
+	struct vega_device *vega_host;
+
+	int ret;
+
+	
+	/* prevent usb-core allocating DMA pages */
+	dev->dma_mask = NULL;
+
+	vega_host = devm_kzalloc(dev, sizeof(*vega_host), GFP_KERNEL);
+	if (!vega_host)
+		return -ENOMEM;
+
+	vega_host->dev = dev;
+	vega_host->devflags = devflags;
+
+	vega_host->rst_gpio = devm_gpiod_get_optional(dev, NULL, GPIOD_OUT_HIGH);
+	if (IS_ERR(vega_host->rst_gpio))
+		return PTR_ERR(vega_host->rst_gpio);
+
+	vega_host->regs = devm_ioremap_resource(dev, mem);
+	if (IS_ERR(vega_host->regs))
+		return PTR_ERR(vega_host->regs);
+
+	vega_init_core(vega_host);
+	
+	ret = vega_hcd_register(&vega_host->hcd, vega_host->regs, mem, irq,
+					irqflags | IRQF_SHARED, dev);
+	if (ret < 0)
+		return ret;	
+
+	dev_set_drvdata(dev, vega_host);
+
+	return 0;
+}
+
+
+
+
+int __init vega_init_kmem_once(void)
+{
+	urb_listitem_cachep = kmem_cache_create("vega_urb_listitem",
+			sizeof(struct urb_listitem), 0, SLAB_TEMPORARY |
+			SLAB_MEM_SPREAD, NULL);
+
+	if (!urb_listitem_cachep)
+		return -ENOMEM;
+
+	qtd_cachep = kmem_cache_create("vega_qtd",
+			sizeof(struct vega_qtd), 0, SLAB_TEMPORARY |
+			SLAB_MEM_SPREAD, NULL);
+
+	if (!qtd_cachep)
+		return -ENOMEM;
+
+	qh_cachep = kmem_cache_create("vega_qh", sizeof(struct vega_qh),
+			0, SLAB_TEMPORARY | SLAB_MEM_SPREAD, NULL);
+
+	if (!qh_cachep) {
+		kmem_cache_destroy(qtd_cachep);
+		return -ENOMEM;
+	}
+
+	return 0;
+}
+
+void vega_deinit_kmem_cache(void)
+{
+	kmem_cache_destroy(qtd_cachep);
+	kmem_cache_destroy(qh_cachep);
+	kmem_cache_destroy(urb_listitem_cachep);
+}
+
+/**
+ * vega_hcd_vega_of_probe - Probe method for the USB host controller
+ * @op:		pointer to the platform_device bound to the host controller
+ *
+ * This function requests resources and sets up appropriate properties for the
+ * host controller. Because the vega USB host controller can be configured
+ * as HS only or HS/FS only, it checks the configuration in the device tree
+ * entry, and sets an appropriate value for hcd->has_tt.
+ */
+static int vega_hcd_probe(struct platform_device *pdev)
+{
+	unsigned long irqflags;
+	unsigned int devflags = 0;
+	struct resource *mem_res;
+	struct resource *irq_res;
+	int ret;
+	
+
+	vega_dbg(&pdev->dev, "<***********************vega_hcd_probe***********************>\n");
+
+	mem_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+
+	irq_res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	if (!irq_res) {
+		pr_warn("vega: IRQ resource not available\n");
+		return -ENODEV;
+	}
+	irqflags = irq_res->flags & IRQF_TRIGGER_MASK;
+	
+	
+
+	ret = vega_register(mem_res, irq_res->start, irqflags, &pdev->dev,
+			       devflags);
+	if (ret < 0)
+		return ret;
+
+
+	pr_info("VEGA USB device initialised\n");
+
+	return 0;
+}
+
+/**
+ * vega_hcd_vega_of_remove - shutdown hcd and release resources
+ * @op:		pointer to platform_device structure that is to be removed
+ *
+ * Remove the hcd structure, and release resources that has been requested
+ * during probe.
+ */
+static int vega_hcd_remove(struct platform_device *op)
+{
+	struct usb_hcd *hcd = platform_get_drvdata(op);
+
+	pr_err( "Stopping VEGA USB Controller\n");
+
+	usb_remove_hcd(hcd);
+
+	usb_put_hcd(hcd);
+
+	return 0;
+}
+
+static const struct of_device_id vega_hcd_of_match[] = {
+		{.compatible = "cdac,vega-usb",},
+	{},
+};
+MODULE_DEVICE_TABLE(of, vega_hcd_of_match);
+
+static struct platform_driver vega_hcd_of_driver = {
+	.probe		= vega_hcd_probe,
+	.remove	= vega_hcd_remove,
+	.shutdown	= usb_hcd_platform_shutdown,
+	.driver = {
+		.name = "vega-usb",
+		.of_match_table = vega_hcd_of_match,
+	},
+};
+
+static int __init vega_init(void)
+{
+	int ret, any_ret = -ENODEV;
+
+	vega_init_kmem_once();
+
+	ret = platform_driver_register(&vega_hcd_of_driver);
+	if (!ret)
+		any_ret = 0;
+
+	if (any_ret)
+		vega_deinit_kmem_cache();
+	return any_ret;
+}
+module_init(vega_init);
+
+static void __exit vega_exit(void)
+{
+	platform_driver_unregister(&vega_hcd_of_driver);
+
+	vega_deinit_kmem_cache();
+}
+module_exit(vega_exit);
diff -Naur linux-5.4.1/drivers/usb/vega/vega-hcd.c linux-5.4.1_modified/drivers/usb/vega/vega-hcd.c
--- linux-5.4.1/drivers/usb/vega/vega-hcd.c	1970-01-01 05:30:00.000000000 +0530
+++ linux-5.4.1_modified/drivers/usb/vega/vega-hcd.c	2025-08-08 10:40:35.458064593 +0530
@@ -0,0 +1,3406 @@
+#include <linux/err.h>
+#include <linux/signal.h>
+#include <linux/usb.h>
+#include <linux/usb/hcd.h>
+#include <linux/of.h>
+#include <linux/of_platform.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+#include <linux/gpio/consumer.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <asm/unaligned.h>
+#include <asm/cacheflush.h>
+
+#include "vega-regs.h"
+#include "vega-hcd.h"
+#include "vega-udc.h"
+
+volatile unsigned int port_change_flag=0;
+
+unsigned int atl_skipmap_global;
+unsigned int int_skipmap_global;
+unsigned int iso_skipmap_global;
+//#define DEBUG_VEGA
+
+#ifdef DEBUG_VEGA
+	#define vega_dbg(...)		dev_err(__VA_ARGS__)
+	#define vega_pr_err(...) 	pr_err(__VA_ARGS__)
+	#define vega_dbg1(...)		dev_err(__VA_ARGS__)
+	#define vega_dbg2(...)		dev_err(__VA_ARGS__)
+	#define vega_dbg3(...)		dev_err(__VA_ARGS__)
+	#define vega_dbg4(...)		dev_err(__VA_ARGS__)
+	#define vega_dbg5(...)		dev_err(__VA_ARGS__)
+	#define vega_probe_dbg(...)	dev_err(__VA_ARGS__)
+#else
+	#define vega_dbg(...)		//dev_err(__VA_ARGS__)
+	#define vega_pr_err(...) 	//pr_err(__VA_ARGS__)
+	#define vega_dbg1(...)		//dev_err(__VA_ARGS__)
+	#define vega_dbg2(...)		//dev_err(__VA_ARGS__)
+	#define vega_dbg3(...)		//dev_err(__VA_ARGS__)
+	#define vega_dbg4(...)		//dev_err(__VA_ARGS__)
+	#define vega_dbg5(...)		//dev_err(__VA_ARGS__)
+	#define vega_hub_cotrol_dbg(...)	//dev_err(__VA_ARGS__)
+	#define vega_hub_cotrol_dbg1(...)	//(__VA_ARGS__)
+	#define vega_handle_ptd_dbg(...)	//dev_err(__VA_ARGS__)
+	#define vega_probe_dbg(...)		//dev_err(__VA_ARGS__)
+	#define vega_mem_io_dbg(...) 		//pr_err(__VA_ARGS__)
+
+	#define vega_init_dbg(...)		//pr_err(__VA_ARGS__)
+
+
+	//#define dev_err(...)	(0)
+	//#define pr_err(...)	(0)
+#endif
+
+//int unskip_check=0; //cdac-test-pid
+//int done_check=0; //cdac-test-pid
+//int stall_check=0; ////cdac-test-pid
+//int stall_count=0; ////cdac-test-pid
+
+volatile int device_disconnected = 0;
+volatile int device_connected = 0;
+
+u32 gframe_index;
+
+int vega_hub_speed;
+
+
+static inline struct vega_hcd *hcd_to_priv(struct usb_hcd *hcd)
+{
+	return *(struct vega_hcd **)hcd->hcd_priv;
+}
+
+/* Philips Proprietary Transfer Descriptor (PTD) */
+typedef __u32 __bitwise __dw;
+struct ptd {
+	__dw dw0;
+	__dw dw1;
+	__dw dw2;
+	__dw dw3;
+	__dw dw4;
+	__dw dw5;
+	__dw dw6;
+	__dw dw7;
+};
+
+#define PTD_OFFSET		0x0400
+#define ISO_PTD_OFFSET		0x0400
+#define INT_PTD_OFFSET		0x0800
+#define ATL_PTD_OFFSET		0x0c00
+#define PAYLOAD_OFFSET		0x1000
+
+static struct kmem_cache *qtd_cachep;
+static struct kmem_cache *qh_cachep;
+static struct kmem_cache *urb_listitem_cachep;
+
+struct urb_listitem {
+	struct list_head urb_list;
+	struct urb *urb;
+};
+
+struct vega_qtd {
+	u8 packet_type;
+	void *data_buffer;
+	u32 payload_addr;
+
+	/* the rest is HCD-private */
+	struct list_head qtd_list;
+	struct urb *urb;
+	size_t length;
+	size_t actual_length;
+
+	/* QTD_ENQUEUED:	waiting for transfer (inactive) */
+	/* QTD_PAYLOAD_ALLOC:	chip mem has been allocated for payload */
+	/* QTD_XFER_STARTED:	valid ptd has been written to isp176x - only
+				interrupt handler may touch this qtd! */
+	/* QTD_XFER_COMPLETE:	payload has been transferred successfully */
+	/* QTD_RETIRE:		transfer error/abort qtd */
+#define QTD_ENQUEUED		0
+#define QTD_PAYLOAD_ALLOC	1
+#define QTD_XFER_STARTED	2
+#define QTD_XFER_COMPLETE	3
+#define QTD_RETIRE		4
+	u32 status;
+};
+
+/* Queue head, one for each active endpoint */
+struct vega_qh {
+	struct list_head qh_list;
+	struct list_head qtd_list;
+	u32 toggle;
+	u32 ping;
+	int slot;
+	int tt_buffer_dirty;	/* See USB2.0 spec section 11.17.5 */
+};
+
+#define PTD_STATE_QTD_DONE	1
+#define PTD_STATE_QTD_RELOAD	2
+#define PTD_STATE_URB_RETIRE	3
+
+/* ATL */
+/* DW0 */
+#define DW0_VALID_BIT			DW0_ACTIVE_BIT
+#define FROM_DW0_VALID(x)		FROM_DW0_ACTIVE(x)
+#define TO_DW1_LENGTH(x)		(((u32) x) << 3)
+#define TO_DW1_MAXPACKET(x)		(((u32) x) << 17)
+//#define TO_DW0_MULTI(x)		(((u32) x) << 29)
+#define TO_DW1_ENDPOINT_0(x)		(((u32)	x) << 31) //Bit [0]
+#define FROM_DW1_ENDPOINT_0(x)	((((u32)	x) >> 31) & 1) //Bit [0]
+
+#define TO_DW0_ENDPOINT_1_3(x)	(((u32)	x) << 0) //Bits [1:3]
+#define FROM_DW0_ENDPOINT_1_3(x)	((((u32)	x) >> 0) & 7) //Bits [1:3]
+
+/* DW1 */
+#define TO_DW0_DEVICE_ADDR(x)		(((u32) x) << 3)
+#define TO_DW0_PID_TOKEN(x)		(((u32) x) << 10)
+#define FROM_DW0_PID_TOKEN(x)		((((u32) x) >> 10) & 3)
+#define DW2_TRANS_ISO			((u32) 1 << 15)
+#define DW2_TRANS_BULK			((u32) 2 << 15)
+#define DW2_TRANS_INT			((u32) 3 << 15)
+
+#define FROM_DW2_EP_TYPE(x)		((((u32) x) >> 15) & 3)
+
+
+#define DW3_TRANS_SPLIT		((u32) 1 << 0)
+#define DW3_SE_USB_LOSPEED		((u32) 2 << 2)
+#define TO_DW3_PORT_NUM(x)		(((u32) x) << 4)
+#define TO_DW3_HUB_NUM(x)		(((u32) x) << 11)
+
+
+/* DW2 */
+#define TO_DW2_DATA_START_ADDR(x)	(((u32) x) << 0)
+#define TO_DW0_RL(x)			((x) << 16)
+#define FROM_DW0_RL(x)			(((x) >> 16) & 0xf)
+/* DW3 */
+#define FROM_DW2_NRBYTESTRANSFERRED(x)		(((x)>> 17) & 0x3FFF)
+#define FROM_DW2_SCS_NRBYTESTRANSFERRED(x)	(((x)>> 17) & 0x07ff)
+#define TO_DW0_NAKCOUNT(x)		((x) << 12)
+#define FROM_DW0_NAKCOUNT(x)		(((x) >> 12) & 0xf)
+#define TO_DW1_CERR(x)			((x) << 0)
+#define FROM_DW1_CERR(x)		(((x) >> 0) & 0x3)
+#define TO_DW2_DATA_TOGGLE(x)		((x) << 31)
+#define FROM_DW2_DATA_TOGGLE(x)	(((x) >> 31) & 0x1)
+#define TO_DW0_PING(x)			((x) << 24)
+#define FROM_DW0_PING(x)		(((x) >> 24) & 0x1)
+#define DW0_ERROR_BIT			(1 << 28)
+//#define DW3_BABBLE_BIT			(1 << 29)
+#define DW0_HALT_BIT			(1 << 30)
+#define DW0_ACTIVE_BIT			(1 << 31)
+#define FROM_DW0_ACTIVE(x)		(((x) >> 31) & 0x01)
+
+#define INT_UNDERRUN			(1 << 2)
+#define INT_BABBLE			(1 << 1)
+#define INT_EXACT			(1 << 0)
+
+#define SETUP_PID	(2)
+#define IN_PID		(1)
+#define OUT_PID	(0)
+
+/* Errata 1 */
+#define RL_COUNTER	(0)
+#define NAK_COUNTER	(0)
+
+#define RL_COUNTER_ATL		(10)
+#define NAK_COUNTER_ATL	(10)
+
+#define ERR_COUNTER	(3)
+
+
+#define SLOT_TIMEOUT 300
+#define SLOT_CHECK_PERIOD 10000
+static struct timer_list errata2_timer;
+static struct usb_hcd *errata2_timer_hcd;
+
+static void handle_done_ptds(struct usb_hcd *hcd);
+
+/*
+ * Access functions for isp176x memory (offset >= 0x0400).
+ *
+ * bank_reads8() reads memory locations prefetched by an earlier write to
+ * HC_MEMORY_REG (see isp176x datasheet). Unless you want to do fancy multi-
+ * bank optimizations, you should use the more generic mem_reads8() below.
+ *
+ * For access to ptd memory, use the specialized ptd_read() and ptd_write()
+ * below.
+ *
+ * These functions copy via MMIO data to/from the device. memcpy_{to|from}io()
+ * doesn't quite work because some people have to enforce 32-bit access
+ */
+static void bank_reads8(void __iomem *src_base, u32 src_offset, u32 bank_addr,
+							__u32 *dst, u32 bytes)
+{
+	__u32 __iomem *src;
+	u32 val;
+	__u8 *src_byteptr;
+	__u8 *dst_byteptr;
+
+	//pr_err("bank_reads8\n");
+	/*vega_pr_err("src_base : %lx\n",src_base);
+	vega_pr_err("src_offset : %x\n",src_offset);
+	vega_pr_err("mem_reads8 : %lx\n", dst);*/
+
+	src = src_base + (src_offset);
+
+	if (src_offset < PAYLOAD_OFFSET) { //TDs area
+		while (bytes >= 4) {
+			*dst = le32_to_cpu(__raw_readl(src));
+			bytes -= 4;
+			//vega_mem_io_dbg("bank_reads8 : %x\n",*dst);
+			src++;
+			dst++;
+			
+		}
+	} else { //Payload area
+		while (bytes >= 4) {
+	
+			*dst = __raw_readl(src);
+			bytes -= 4;
+			//vega_mem_io_dbg("bank_reads8 : %x\n",*dst);
+			src++;
+			dst++;
+		}
+	}
+
+	if (!bytes)
+		return;
+
+	/* in case we have 3, 2 or 1 by left. The dst buffer may not be fully
+	 * allocated.
+	 */
+	if (src_offset < PAYLOAD_OFFSET)
+		val = le32_to_cpu(__raw_readl(src)); //TDs
+	else
+		val = __raw_readl(src); //Payload
+
+	dst_byteptr = (void *) dst;
+	src_byteptr = (void *) &val;
+	while (bytes > 0) {
+		*dst_byteptr = *src_byteptr;
+
+		//vega_mem_io_dbg("bank_reads8 : %x\n",*dst_byteptr);
+		dst_byteptr++;
+		src_byteptr++;
+		bytes--;
+	}
+}
+
+static void mem_reads8(void __iomem *src_base, u32 src_offset, void *dst,
+								u32 bytes)
+{
+
+	/*vega_pr_err("src_base : %lx\n",src_base);
+	vega_pr_err("src_offset : %x\n",src_offset);
+	vega_pr_err("mem_reads8 : %lx\n", dst);*/
+	//pr_err("mem_reads8\n");
+
+	//vega_write32(src_base, HC_MEMORY_REG, src_offset + ISP_BANK(0));
+	//ndelay(90);
+	bank_reads8(src_base, src_offset, ISP_BANK(0), dst, bytes);
+}
+
+static void mem_writes8(void __iomem *dst_base, u32 dst_offset,
+						__u32 const *src, u32 bytes)
+{
+	__u32 __iomem *dst;
+
+	dst = dst_base + dst_offset;
+
+	//pr_err("mem_writes8\n");
+	//vega_pr_err("dst_base : %lx\n",dst_base);
+	//pr_err("dst_offset : %x\n",dst_offset);
+
+	if (dst_offset < PAYLOAD_OFFSET) {
+		while (bytes >= 4) {
+			//__raw_writel(cpu_to_le32(*src), dst);
+			__raw_writel(*src, dst);//FIXME
+			bytes -= 4;
+			//vega_mem_io_dbg("mem_writes8 : %x\n",*src);
+			src++;
+			dst++;
+		}
+	} else {
+	
+		if(bytes>8192)
+			pr_err("bytes >8K\n");
+		while (bytes >= 4) {
+			__raw_writel(*src, dst);
+			//vega_mem_io_dbg("mem_writes8 : %x\n",*src);
+			bytes -= 4;
+			
+			
+			src++;
+			dst++;
+		}
+	}
+
+	if (!bytes)
+		return;
+	/* in case we have 3, 2 or 1 bytes left. The buffer is allocated and the
+	 * extra bytes should not be read by the HW.
+	 */
+
+	if (dst_offset < PAYLOAD_OFFSET){
+		//__raw_writel(cpu_to_le32(*src), dst);
+		__raw_writel(*src, dst);//FIXME
+		}
+	else
+		__raw_writel(*src, dst);
+}
+
+/*
+ * Read and write ptds. 'ptd_offset' should be one of ISO_PTD_OFFSET,
+ * INT_PTD_OFFSET, and ATL_PTD_OFFSET. 'slot' should be less than 32.
+ */
+static void ptd_read(void __iomem *base, u32 ptd_offset, u32 slot,
+								struct ptd *ptd)
+{
+	//vega_write32(base, HC_MEMORY_REG,	ISP_BANK(0) + ptd_offset + slot*sizeof(*ptd));
+
+	//ndelay(90);
+	bank_reads8(base, ptd_offset + slot*sizeof(*ptd), ISP_BANK(0),
+						(void *) ptd, sizeof(*ptd));
+
+	if(slot>7)
+	{
+		pr_err("SLOT > 7\n");
+	}	
+	if(slot!=0)
+	{
+		//pr_err("W-SLOT ! 0\n");
+		//while(1);
+	}	
+	
+	/*pr_err("------------RD------------\n");
+	pr_err("Slot : %d\n",slot);
+	pr_err("dw0 : %x\n",ptd->dw0);
+	pr_err("dw1 : %x\n",ptd->dw1);
+	pr_err("dw2 : %x\n",ptd->dw2);
+	pr_err("dw3 : %x\n",ptd->dw3);
+	pr_err("dw4 : %x\n",ptd->dw4);
+	pr_err("dw5 : %x\n",ptd->dw5);
+	pr_err("dw6 : %x\n",ptd->dw6);
+	pr_err("dw7 : %x\n",ptd->dw7);
+	pr_err("++++++++++++RD++++++++++++\n");*/
+}
+
+static void ptd_write(void __iomem *base, u32 ptd_offset, u32 slot,
+								struct ptd *ptd)
+{
+
+	//if(unskip_check)	
+	//	pr_err("> unskip_check ptd_write\n");
+	/*if(ptd->dw3 !=0){*/
+
+	/*	pr_err("------------WR------------\n");
+		pr_err("Slot : %d\n",slot);
+		pr_err("dw0 : %x\n",ptd->dw0);
+		pr_err("dw1 : %x\n",ptd->dw1);
+		pr_err("dw2 : %x\n",ptd->dw2);		
+		pr_err("dw3 : %x\n",ptd->dw3);
+		pr_err("dw4 : %x\n",ptd->dw4);
+		pr_err("dw5 : %x\n",ptd->dw5);
+		pr_err("dw6 : %x\n",ptd->dw6);
+		pr_err("dw7 : %x\n",ptd->dw7);
+		pr_err("++++++++++++WR++++++++++++\n");*/
+	//}
+	mem_writes8(base, ptd_offset + slot*sizeof(*ptd) + sizeof(ptd->dw0),
+						&ptd->dw1, 7*sizeof(ptd->dw1));
+						
+						
+	//pr_err("W-SLOT %d\n", slot);					
+
+	if(slot>7)
+	{
+		pr_err("W-SLOT > 7\n");
+	}
+	
+	if(slot!=0)
+	{
+		//pr_err("W-SLOT ! 0\n");
+		//while(1);
+	}		
+	/* Make sure dw0 gets written last (after other dw's and after payload)
+	   since it contains the enable bit */
+	wmb();
+	mem_writes8(base, ptd_offset + slot*sizeof(*ptd), &ptd->dw0,
+							sizeof(ptd->dw0));
+}
+
+static void errata2_function(struct timer_list *unused)
+{
+	struct usb_hcd *hcd = errata2_timer_hcd;
+	struct vega_hcd *priv = hcd_to_priv(hcd);
+	int slot;
+	struct ptd ptd;
+	unsigned long spinflags;
+	
+	spin_lock_irqsave(&priv->lock, spinflags);
+	pr_err("ERRATA\n");
+	/*for (slot = 0; slot < 32; slot++)
+		if (priv->atl_slots[slot].qh && time_after(jiffies,
+					priv->atl_slots[slot].timestamp +
+					msecs_to_jiffies(SLOT_TIMEOUT))) {
+			ptd_read(hcd->regs, ATL_PTD_OFFSET, slot, &ptd);
+			if (!FROM_DW0_ACTIVE(ptd.dw0)) //!FROM_DW0_VALID(ptd.dw0) && FIXME
+				priv->atl_done_map |= 1 << slot;
+		}
+
+	if (priv->atl_done_map)
+		handle_done_ptds(hcd);*/
+
+	slot =0;
+	ptd_read(hcd->regs, ATL_PTD_OFFSET, slot, &ptd);
+
+
+	/*	priv->int_done_map |= 1; //vega_read32(hcd->regs, HC_INT_PTD_DONEMAP_REG);
+		priv->atl_done_map |= 1; //vega_read32(hcd->regs, HC_ATL_PTD_DONEMAP_REG);
+		vega_dbg1(hcd->self.controller,"priv->int_done_map %x >>>>>\n",priv->int_done_map);
+		vega_dbg1(hcd->self.controller,"priv->atl_done_map %x >>>>>\n",priv->atl_done_map);
+	*/
+
+		int temp = vega_read32(hcd->regs, HC_ATL_PTD_SKIPMAP_REG);
+		//dev_err(hcd->self.controller,"HC_ATL_PTD_SKIPMAP_REG %x >>>>>\n",temp);
+	
+		vega_write32(hcd->regs, HC_ATL_PTD_SKIPMAP_REG, 0xff);
+
+		ptd.dw0 = 0;
+		ptd_write(hcd->regs, ATL_PTD_OFFSET, slot, &ptd);
+
+		priv->atl_done_map |= 1; //vega_read32(hcd->regs, HC_ATL_PTD_DONEMAP_REG);
+		handle_done_ptds(hcd);
+
+	spin_unlock_irqrestore(&priv->lock, spinflags);
+
+	//errata2_timer.expires = jiffies + msecs_to_jiffies(SLOT_CHECK_PERIOD);
+	//add_timer(&errata2_timer);
+}
+
+
+
+/* memory management of the 15kb on the chip from 0x1000 to 0x4C00 */
+static void init_memory(struct vega_hcd *priv)
+{
+	int i, curr;
+	u32 payload_addr;
+
+	payload_addr = PAYLOAD_OFFSET;
+	for (i = 0; i < BLOCK_1_NUM; i++) {
+		priv->memory_pool[i].start = payload_addr;
+		priv->memory_pool[i].size = BLOCK_1_SIZE;
+		priv->memory_pool[i].free = 1;
+		payload_addr += priv->memory_pool[i].size;
+	}
+
+	curr = i;
+	for (i = 0; i < BLOCK_2_NUM; i++) {
+		priv->memory_pool[curr + i].start = payload_addr;
+		priv->memory_pool[curr + i].size = BLOCK_2_SIZE;
+		priv->memory_pool[curr + i].free = 1;
+		payload_addr += priv->memory_pool[curr + i].size;
+	}
+
+	curr = i;
+	for (i = 0; i < BLOCK_3_NUM; i++) {
+		priv->memory_pool[curr + i].start = payload_addr;
+		priv->memory_pool[curr + i].size = BLOCK_3_SIZE;
+		priv->memory_pool[curr + i].free = 1;
+		payload_addr += priv->memory_pool[curr + i].size;
+	}
+
+	WARN_ON(payload_addr - priv->memory_pool[0].start > PAYLOAD_AREA_SIZE);
+}
+
+static void alloc_mem(struct usb_hcd *hcd, struct vega_qtd *qtd)
+{
+	struct vega_hcd *priv = hcd_to_priv(hcd);
+	int i;
+
+	WARN_ON(qtd->payload_addr);
+
+	if (!qtd->length)
+		return;
+
+	for (i = 0; i < BLOCKS; i++) {
+		if (priv->memory_pool[i].size >= qtd->length &&
+				priv->memory_pool[i].free) {
+			priv->memory_pool[i].free = 0;
+			qtd->payload_addr = priv->memory_pool[i].start;
+			return;
+		}
+	}
+}
+
+static void free_mem(struct usb_hcd *hcd, struct vega_qtd *qtd)
+{
+	struct vega_hcd *priv = hcd_to_priv(hcd);
+	int i;
+
+	if (!qtd->payload_addr)
+		return;
+
+	for (i = 0; i < BLOCKS; i++) {
+		if (priv->memory_pool[i].start == qtd->payload_addr) {
+			WARN_ON(priv->memory_pool[i].free);
+			priv->memory_pool[i].free = 1;
+			qtd->payload_addr = 0;
+			return;
+		}
+	}
+
+	vega_dbg(hcd->self.controller, "%s: Invalid pointer: %08x\n",
+						__func__, qtd->payload_addr);
+	WARN_ON(1);
+	qtd->payload_addr = 0;
+}
+
+
+/*static u32 base_to_chip(u32 base)
+{
+	return ((base - 0x400) >> 3);
+}*/
+
+static int last_qtd_of_urb(struct vega_qtd *qtd, struct vega_qh *qh)
+{
+	struct urb *urb;
+
+	if (list_is_last(&qtd->qtd_list, &qh->qtd_list))
+		return 1;
+
+	urb = qtd->urb;
+	qtd = list_entry(qtd->qtd_list.next, typeof(*qtd), qtd_list);
+	return (qtd->urb != urb);
+}
+
+
+/* magic numbers that can affect system performance */
+#define	EHCI_TUNE_CERR		3	/* 0-3 qtd retries; 0 == don't stop */
+#define	EHCI_TUNE_RL_HS		4	/* nak throttle; see 4.9 */
+#define	EHCI_TUNE_RL_TT		0
+#define	EHCI_TUNE_MULT_HS	1	/* 1-3 transactions/uframe; 4.10.3 */
+#define	EHCI_TUNE_MULT_TT	1
+#define	EHCI_TUNE_FLS		2	/* (small) 256 frame schedule */
+
+static void create_ptd_atl(struct vega_qh *qh,
+			struct vega_qtd *qtd, struct ptd *ptd)
+{
+	u32 maxpacket;
+	u32 multi;
+	u32 rl = RL_COUNTER;
+	u32 nak = NAK_COUNTER;
+	
+	if (vega_hub_speed != HUB_SPEED_HIGH){
+		if (usb_pipebulk(qtd->urb->pipe) || usb_pipecontrol(qtd->urb->pipe)){
+			rl = RL_COUNTER_ATL;
+			nak = NAK_COUNTER_ATL;
+		}
+	}
+	
+	memset(ptd, 0, sizeof(*ptd));
+
+	vega_pr_err("create_ptd_atl\n");
+	
+	/* according to 3.6.2, max packet len can not be > 0x400 */
+	maxpacket = usb_maxpacket(qtd->urb->dev, qtd->urb->pipe,
+						usb_pipeout(qtd->urb->pipe));
+	vega_pr_err("maxpacket : %x , multi : %x\n",maxpacket, multi);
+	multi =  1 + ((maxpacket >> 11) & 0x3);
+	maxpacket &= 0x7ff;
+
+	//pr_err("maxpacket : %x , multi : %x\n",maxpacket, multi);
+
+	/* DW0 */
+	ptd->dw0 = DW0_ACTIVE_BIT;
+	ptd->dw0 |= (usb_pipeendpoint(qtd->urb->pipe) >> 1); // Bits [1:3] of endpoint number
+	ptd->dw0 |= TO_DW0_DEVICE_ADDR(usb_pipedevice(qtd->urb->pipe));
+	ptd->dw0 |= TO_DW0_PID_TOKEN(qtd->packet_type);
+	vega_pr_err("\n--------------------------------\n");
+	/*if(qtd->packet_type == 0)
+		pr_err("<OUT>\n");
+	else if(qtd->packet_type == 1)
+		pr_err("<IN>\n");
+	else if(qtd->packet_type == 2)
+		vega_pr_err("<SETUP>\n");
+	else
+		pr_err("<PING>\n");*/
+	ptd->dw0 |= TO_DW0_RL(rl);
+	ptd->dw0 |= TO_DW0_NAKCOUNT(nak);
+	
+	/*pr_err("------bDeviceClass----------\n");
+	//pr_err("dev num: %08lx\n",qtd->urb->dev->tt->hub->devnum);
+	//pr_err("maxchild: %08lx\n",qtd->urb->dev->maxchild);
+	pr_err("bDeviceClass: %08lx\n",qtd->urb->dev->descriptor.bDeviceClass);
+	pr_err("bDeviceSubClass: %08lx\n",qtd->urb->dev->descriptor.bDeviceSubClass);*/
+	
+	
+	if (vega_hub_speed == HUB_SPEED_HIGH){
+		if (qtd->urb->dev->speed != USB_SPEED_HIGH) {
+			//FIXME printf("SPLIT bit not in VEGA\n");
+			//vega_dbg(hcd->self.controller,"SPLIT bit not in VEGA\n");
+			/* split transaction */
+			//if (usb_pipeint(qtd->urb->pipe))
+			//	pr_err("Split\n");
+			ptd->dw3 = 0;
+
+			ptd->dw3 |= DW3_TRANS_SPLIT;
+			
+			if (qtd->urb->dev->speed == USB_SPEED_LOW)
+				ptd->dw3 |= DW3_SE_USB_LOSPEED;
+
+			ptd->dw3 |= TO_DW3_PORT_NUM(qtd->urb->dev->ttport);
+			ptd->dw3 |= TO_DW3_HUB_NUM(qtd->urb->dev->tt->hub->devnum);
+			
+			/* SE bit for Split INT transfers */
+			if (usb_pipeint(qtd->urb->pipe) &&
+					(qtd->urb->dev->speed == USB_SPEED_LOW))
+				ptd->dw3 |= 2 << 2;
+
+		} else {
+			
+			//FIXME 
+			///pr_err("MULTI bit not in VEGA\n");
+			/*ptd->dw0 |= TO_DW0_MULTI(multi);*/
+			//pr_err("High speed device\n");
+
+			if (usb_pipecontrol(qtd->urb->pipe)){
+				ptd->dw0 &= ~TO_DW0_PING(1);
+				//pr_err("CTL PING=0\n");
+			}
+			else if (usb_pipebulk(qtd->urb->pipe))
+			{
+
+				if(qtd->packet_type == 0) //OUT Transfer
+				{
+					ptd->dw0 |= TO_DW0_PING(qh->ping);
+					//pr_err("BLK OUT PING=%x\n",qh->ping);
+				}
+				else
+				{
+					ptd->dw0 &= ~TO_DW0_PING(1);
+					//pr_err("BLK IN PING=0\n");
+				}
+				
+			}
+			ptd->dw3 = 0;
+			//pr_err("ping :%x\n",qh->ping);
+		}
+	}else{
+
+		//pr_err("Full speed hub\n");
+
+
+		ptd->dw3 = 0;
+		
+		if (qtd->urb->dev->speed == USB_SPEED_LOW)
+			ptd->dw3 |= DW3_SE_USB_LOSPEED;
+
+		//ptd->dw3 |= TO_DW3_PORT_NUM(qtd->urb->dev->ttport);
+		//ptd->dw3 |= TO_DW3_HUB_NUM(qtd->urb->dev->tt->hub->devnum);
+		
+	}
+
+	/* DW1 */
+	ptd->dw1 = TO_DW1_LENGTH(qtd->length);
+	
+	
+	if(qtd->length>8192)
+		pr_err("qtd->length : %d\n",qtd->length);
+	//pr_err("qtd->length : %d\n",qtd->length);
+	ptd->dw1 |= TO_DW1_MAXPACKET(maxpacket);
+	ptd->dw1 |= TO_DW1_ENDPOINT_0(usb_pipeendpoint(qtd->urb->pipe) & 1); // Bit[0] of endpoint number	
+
+	if  (!usb_pipeisoc(qtd->urb->pipe))
+		ptd->dw1 |= TO_DW1_CERR(ERR_COUNTER); 	/* Cerr */
+	//pr_err("ptd->dw1 : %lx\n",ptd->dw1);
+	/* DW2 */
+	ptd->dw2 = 0;
+	ptd->dw2 |= TO_DW2_DATA_START_ADDR(qtd->payload_addr);
+	
+	//ptd->dw2 &= ~TO_DW2_DATA_TOGGLE(1); //|= TO_DW2_DATA_TOGGLE(qh->toggle); FIXME
+	if  (!usb_pipeisoc(qtd->urb->pipe))
+		ptd->dw2 |= TO_DW2_DATA_TOGGLE(qh->toggle);// FIXME
+	
+
+	//pr_err("qh->toggle : %x,ptd->dw2 %x \n",qh->toggle, ptd->dw2);
+
+	if (usb_pipebulk(qtd->urb->pipe)){
+		ptd->dw2 |= DW2_TRANS_BULK;
+		//if((qtd->length == 13) && (qtd->packet_type == IN_PID))
+			//pr_err("bulk len==13\n");
+	}
+	else if  (usb_pipeint(qtd->urb->pipe)){
+		ptd->dw2 |= DW2_TRANS_INT;
+		//pr_err("usb_pipeint\n");
+	}
+	else if  (usb_pipeisoc(qtd->urb->pipe)){
+		ptd->dw2 |= DW2_TRANS_ISO;
+		//pr_err("usb_pipeisoc\n");
+	}
+
+	//vega_pr_err("qh->toggle : %x, qtd->urb->pipe : %x\n",qh->toggle,qtd->urb->pipe);
+	
+
+	if (usb_pipecontrol(qtd->urb->pipe)) {
+		if (qtd->data_buffer == qtd->urb->setup_packet){
+			ptd->dw2 &= ~TO_DW2_DATA_TOGGLE(1);
+			//vega_pr_err("TO_DW2_DATA_TOGGLE CLEAR\n");
+		}
+		else //if (last_qtd_of_urb(qtd, qh)) //FIXME
+		{
+			ptd->dw2 |= TO_DW2_DATA_TOGGLE(1);
+			//vega_pr_err("TO_DW2_DATA_TOGGLE \n");
+		}
+	}
+
+	//pr_err("qh->toggle : %x,ptd->dw2 %x \n",qh->toggle, ptd->dw2);
+
+	/* DW3 */
+	
+		
+	ptd->dw4 = 0;
+	ptd->dw5 = 0;
+	ptd->dw6 = 0;
+	ptd->dw7 = 0;
+	
+	//Reserved
+
+}
+
+static void transform_add_int(struct vega_qh *qh,
+			struct vega_qtd *qtd, struct ptd *ptd)
+{
+	u32 usof, frame_index;
+	u32 uFrame_7_3, uFrame, frame_interval;
+
+	/*
+	 * Most of this is guessing. ISP1761 datasheet is quite unclear, and
+	 * the algorithm from the original Philips driver code, which was
+	 * pretty much used in this driver before as well, is quite horrendous
+	 * and, i believe, incorrect. The code below follows the datasheet and
+	 * USB2.0 spec as far as I can tell, and plug/unplug seems to be much
+	 * more reliable this way (fingers crossed...).
+	 */
+
+
+	if(qtd->urb->dev->descriptor.bDeviceClass != 0x09){ //Device class is not a hub
+		
+		if  (usb_pipeint(qtd->urb->pipe)){
+		
+			if (qtd->urb->dev->speed == USB_SPEED_HIGH) { //vega_hub_speed //HUB_SPEED_HIGH
+			
+				/* urb->interval is in units of microframes (1/8 ms) */
+
+				if (qtd->urb->interval > 8) {//2^(bInterval-1)
+					usof = 0x01; /* One bit set*/
+					
+					if(qtd->urb->interval > 256)
+						qtd->urb->interval = 256; //Host controller supports only upto 32 ms
+					uFrame_7_3 = qtd->urb->interval / 16; /* uFrame[7:3] = 1, period = 2ms for interval = 16;  uFrame[7:3] = 2, period = 4ms for interval = 32 etc.*/
+				}
+				else if (qtd->urb->interval > 4) //bInterval
+				{
+					usof = 0x01;
+					if (qtd->urb->interval == 5)
+						uFrame_7_3 = 0x1; 
+					else if (qtd->urb->interval == 6)
+						uFrame_7_3 = 0x2;
+					else if (qtd->urb->interval == 7)
+						uFrame_7_3 = 0x4;
+					else if (qtd->urb->interval == 8)
+						uFrame_7_3 = 0x8;
+				
+				}
+				else //bInterval
+				{
+					if (qtd->urb->interval == 1)
+						usof = 0xff; /* All bits set => interval 125us */
+					else if (qtd->urb->interval == 2)
+						usof = 0xaa; /* 4 bits set => interval 250us */
+					else if (qtd->urb->interval == 3)
+						usof = 0x11; /* 2 bits set => interval 500us */
+					else if (qtd->urb->interval == 4)
+						usof = 0x01; /* 1 bit set => interval 1ms */
+					uFrame_7_3 = 0;
+				}
+				
+				
+				//if (qtd->urb->dev->speed != USB_SPEED_HIGH)
+				//	usof = 0x1d; //For Split transfer
+				//pr_err("HIGH p : %x u : %x interval :%x >>>>>\n", uFrame_7_3, usof, qtd->urb->interval);	
+				
+			} else {
+				/* urb->interval is in units of frames (1 ms) */
+				
+				usof = 0x1d; //For Split transfer
+				
+				if(qtd->urb->interval > 32)
+					qtd->urb->interval = 32; //Host controller supports only upto 32 ms
+				uFrame_7_3 = qtd->urb->interval / 2; //uFrame_7_3 = 0 for 1ms, 1 for 2ms, 2 for 4ms, 4 for 8ms etc..
+				//usof = 0x01; /* One bit set*/
+				
+				//pr_err("USB_SPEED_full period : %x usof : %x qtd->urb->interval :%x >>>>>\n", uFrame_7_3, usof, qtd->urb->interval);	
+				
+			}
+
+		}
+		else if  (usb_pipeisoc(qtd->urb->pipe)){
+			
+			if (vega_hub_speed == HUB_SPEED_HIGH) {
+			
+				if (qtd->urb->interval > 4) {
+					usof = 0x01; /* One bit set*/
+				}
+				else{
+					if (qtd->urb->interval == 1)
+						usof = 0xff; /* All bits set => interval 125us */
+					else if (qtd->urb->interval == 2)
+						usof = 0xaa; /* 4 bits set => interval 250us */
+					else if (qtd->urb->interval == 3)
+						usof = 0x11; /* 2 bits set => interval 500us */
+					else if (qtd->urb->interval == 4)
+						usof = 0x01; /* 1 bit set => interval 1ms */
+				}
+				
+				
+				frame_index = gframe_index >> 3; //Frame Number
+				uFrame_7_3 = frame_index; //Next Frame after 2 Frames (2ms)
+			
+			} else {
+			
+				frame_interval = 1 << (qtd->urb->interval - 1); //ms
+				
+				//frame_index = frame_index >> 3; //Frame Number
+				uFrame_7_3 = gframe_index + frame_interval; //Next Frame after (2 + frame_interval) Frames
+			}
+		}
+	} else { //Device class is a Hub
+	
+		//pr_err("Hub Class : %d\n",qtd->urb->dev->descriptor.bDeviceClass);
+	
+		if  (usb_pipeint(qtd->urb->pipe)){
+
+			/* urb->interval is in units of frames (1 ms) */
+			
+			usof = 0x1d; //For Split transfer
+			
+			if(qtd->urb->interval > 32)
+				qtd->urb->interval = 32; //Host controller supports only upto 32 ms
+			uFrame_7_3 = qtd->urb->interval / 2; //uFrame_7_3 = 0 for 1ms, 1 for 2ms, 2 for 4ms, 4 for 8ms etc..
+
+
+		}
+		else if  (usb_pipeisoc(qtd->urb->pipe)){
+			
+
+			frame_interval = 1 << (qtd->urb->interval - 1); //ms
+			
+			//frame_index = frame_index >> 3; //Frame Number
+			uFrame_7_3 = gframe_index + frame_interval; //Next Frame after (2 + frame_interval) Frames
+		}
+
+	}
+
+	uFrame = uFrame_7_3 << 3;
+
+	ptd->dw0 |= (uFrame<<12);
+	ptd->dw0 |= (usof<<20);
+	//pr_err(" dw0 : %x  \n", ptd->dw0);
+}
+
+static void create_ptd_int(struct vega_qh *qh,
+			struct vega_qtd *qtd, struct ptd *ptd)
+{
+	//vega_dbg(hcd->self.controller,"create_ptd_int>>>>\n");
+	create_ptd_atl(qh, qtd, ptd);
+	transform_add_int(qh, qtd, ptd);
+}
+
+
+static void create_ptd_iso(struct vega_qh *qh,
+			struct vega_qtd *qtd, struct ptd *ptd)
+{
+	//pr_err("create_ptd_iso : same as int>>>>\n");
+	create_ptd_atl(qh, qtd, ptd);
+	transform_add_int(qh, qtd, ptd);
+}
+
+
+
+static void vega_urb_done(struct usb_hcd *hcd, struct urb *urb)
+__releases(priv->lock)
+__acquires(priv->lock)
+{
+	struct vega_hcd *priv = hcd_to_priv(hcd);
+
+	if (!urb->unlinked) {
+		if (urb->status == -EINPROGRESS)
+			urb->status = 0;
+	}
+
+	if (usb_pipein(urb->pipe) && usb_pipetype(urb->pipe) != PIPE_CONTROL) {
+		void *ptr;
+		for (ptr = urb->transfer_buffer;
+		     ptr < urb->transfer_buffer + urb->transfer_buffer_length;
+		     ptr += PAGE_SIZE)
+			flush_dcache_page(virt_to_page(ptr)); 
+	}
+
+	/* complete() can reenter this HCD */
+	usb_hcd_unlink_urb_from_ep(hcd, urb);
+	spin_unlock(&priv->lock);
+	usb_hcd_giveback_urb(hcd, urb, urb->status);
+	spin_lock(&priv->lock);
+}
+
+static struct vega_qtd *qtd_alloc(gfp_t flags, struct urb *urb,
+								u8 packet_type)
+{
+	struct vega_qtd *qtd;
+
+	qtd = kmem_cache_zalloc(qtd_cachep, flags);
+	if (!qtd)
+		return NULL;
+
+	INIT_LIST_HEAD(&qtd->qtd_list);
+	qtd->urb = urb;
+	qtd->packet_type = packet_type;
+	qtd->status = QTD_ENQUEUED;
+	qtd->actual_length = 0;
+
+	return qtd;
+}
+
+static void qtd_free(struct vega_qtd *qtd)
+{
+	WARN_ON(qtd->payload_addr);
+	kmem_cache_free(qtd_cachep, qtd);
+}
+
+static void start_bus_transfer(struct usb_hcd *hcd, u32 ptd_offset, int slot,
+				struct vega_slotinfo *slots,
+				struct vega_qtd *qtd, struct vega_qh *qh,
+				struct ptd *ptd)
+{
+	struct vega_hcd *priv = hcd_to_priv(hcd);
+	int skip_map;
+	int temp;
+	
+	vega_dbg(hcd->self.controller,"start_bus_transfer>>>>\n");
+
+	WARN_ON((slot < 0) || (slot > 31));
+	WARN_ON(qtd->length && !qtd->payload_addr);
+	WARN_ON(slots[slot].qtd);
+	WARN_ON(slots[slot].qh);
+	WARN_ON(qtd->status != QTD_PAYLOAD_ALLOC);
+
+	/* Make sure done map has not triggered from some unlinked transfer */
+	if (ptd_offset == ATL_PTD_OFFSET) {
+		priv->atl_done_map |= vega_read32(hcd->regs,
+						HC_ATL_PTD_DONEMAP_REG);
+		priv->atl_done_map &= ~(1 << slot);
+	} else if (ptd_offset == ISO_PTD_OFFSET) {
+		priv->iso_done_map |= vega_read32(hcd->regs, HC_ISO_PTD_DONEMAP_REG);
+		priv->iso_done_map &= ~(1 << slot);
+	}	
+	 else {
+		priv->int_done_map |= vega_read32(hcd->regs,
+						HC_INT_PTD_DONEMAP_REG);
+		priv->int_done_map &= ~(1 << slot);
+	}
+
+	qh->slot = slot;
+	qtd->status = QTD_XFER_STARTED;
+	slots[slot].timestamp = jiffies;
+	slots[slot].qtd = qtd;
+	slots[slot].qh = qh;
+	ptd_write(hcd->regs, ptd_offset, slot, ptd);
+
+	vega_dbg1(hcd->self.controller,"start_bus_transfer \n");
+
+	if (ptd_offset == ATL_PTD_OFFSET) {
+		skip_map = atl_skipmap_global; //vega_read32(hcd->regs, HC_ATL_PTD_SKIPMAP_REG);
+		vega_dbg(hcd->self.controller,"skip_map wr %x >>>>>\n",skip_map);
+		skip_map &= ~(1 << qh->slot);
+		
+		//if(skip_map !=0xfffffffe)
+		//	pr_err("skip_map atl %x >>>>>\n",skip_map);
+			
+		atl_skipmap_global = skip_map;
+		vega_write32(hcd->regs, HC_ATL_PTD_SKIPMAP_REG, skip_map);
+		
+		/*if((qtd->length == 13) && (qtd->packet_type == IN_PID)){
+			//pr_err("bulk len==13 unskip\n");
+			unskip_check = 1;
+			if(stall_check){//cdac-test-pid
+				stall_check = 0;
+				temp =  stall_count | (stall_count << 8) | (stall_count << 16) | (stall_count << 24);
+				vega_write32(hcd->regs, HC_SCRATCH_REG, temp);
+				stall_count++;
+			}
+			
+							
+					pr_err("------------unskip---td wr val---------\n");
+					pr_err("Slot : %d\n",slot);
+					pr_err("dw0 : %x\n",ptd->dw0);
+					pr_err("dw1 : %x\n",ptd->dw1);
+					pr_err("dw2 : %x\n",ptd->dw2);		
+					pr_err("dw3 : %x\n",ptd->dw3);
+					pr_err("dw4 : %x\n",ptd->dw4);
+					pr_err("dw5 : %x\n",ptd->dw5);
+					pr_err("dw6 : %x\n",ptd->dw6);
+					pr_err("dw7 : %x\n",ptd->dw7);
+					pr_err("++++++++++++unskip++++++++++++\n");
+		
+		}*/
+		
+		
+		//pr_err("unskip\n");
+		
+	
+		vega_dbg1(hcd->self.controller,"skip_map wr %x >>>>>\n",skip_map);
+		skip_map = vega_read32(hcd->regs, HC_ATL_PTD_SKIPMAP_REG); //FIXME
+		
+		//pr_err("unskip_map \n");
+
+	/*	while(1){
+			if(vega_read32(hcd->regs, HC_ATL_PTD_DONEMAP_REG)==1)
+				break;
+		}*/
+		vega_dbg1(hcd->self.controller,"done_map set\n");
+	} else if(ptd_offset == ISO_PTD_OFFSET) {
+		skip_map = iso_skipmap_global; //vega_read32(hcd->regs, HC_INT_PTD_SKIPMAP_REG);
+		skip_map &= ~(1 << qh->slot);
+		
+		//if(skip_map !=0xfe)
+		//pr_err("skip_map iso %x >>>>>\n",skip_map);
+		iso_skipmap_global=skip_map;
+		vega_write32(hcd->regs, HC_ISO_PTD_SKIPMAP_REG, skip_map);
+		skip_map = vega_read32(hcd->regs, HC_ISO_PTD_SKIPMAP_REG); //FIXME
+	}
+	
+	
+	 else {
+		skip_map = int_skipmap_global; //vega_read32(hcd->regs, HC_INT_PTD_SKIPMAP_REG);
+		skip_map &= ~(1 << qh->slot);
+		
+		//if(skip_map !=0xfffffffe)
+		//	pr_err("skip_map int %x >>>>>\n",skip_map);
+
+		//if(skip_map !=0xfe)
+		//pr_err("skip_map int %x >>>>>\n",skip_map);
+		int_skipmap_global=skip_map;
+		vega_write32(hcd->regs, HC_INT_PTD_SKIPMAP_REG, skip_map);
+		skip_map = vega_read32(hcd->regs, HC_INT_PTD_SKIPMAP_REG); //FIXME
+	}
+}
+
+static int is_short_bulk(struct vega_qtd *qtd)
+{
+	return (usb_pipebulk(qtd->urb->pipe) &&
+					(qtd->actual_length < qtd->length));
+}
+
+static void collect_qtds(struct usb_hcd *hcd, struct vega_qh *qh,
+						struct list_head *urb_list)
+{
+	int last_qtd;
+	struct vega_qtd *qtd, *qtd_next;
+	struct urb_listitem *urb_listitem;
+
+	int k=0;
+	
+	
+	//if(done_check){
+		//pr_err("collect_qtds \n");
+	//}//cdac-test-pid
+	
+	
+
+	list_for_each_entry_safe(qtd, qtd_next, &qh->qtd_list, qtd_list) {
+		vega_dbg1(hcd->self.controller,"collect_qtds status %x, length %x, pkt typ %x\n",qtd->status,qtd->actual_length,qtd->packet_type);
+		if (qtd->status < QTD_XFER_COMPLETE)
+			break;
+			
+		//if(done_check){
+			//pr_err("collect_qtds 1 \n");
+		//}	
+
+		last_qtd = last_qtd_of_urb(qtd, qh);
+
+		if ((!last_qtd) && (qtd->status == QTD_RETIRE))
+			qtd_next->status = QTD_RETIRE;
+
+		if (qtd->status == QTD_XFER_COMPLETE) {
+		
+			/*if(done_check){//cdac-test-pid
+				//pr_err("collect_qtds 2 \n");
+				
+				if (qtd->actual_length == 0){
+
+					vega_write32(hcd->regs, HC_SCRATCH_REG, 0x12345678);
+					pr_err("td error \n"); 
+				}
+				
+			}*/
+		
+		
+			if (qtd->actual_length) {
+			
+				//if(done_check){ //cdac-test-pid
+					//pr_err("collect_qtds 3\n");
+				//}
+			
+			
+				switch (qtd->packet_type) {
+				case IN_PID:
+					//vega_pr_err("<<<<<IN payload : %d\n", qtd->actual_length);
+					mem_reads8(hcd->regs, qtd->payload_addr,
+							qtd->data_buffer,
+							qtd->actual_length);
+							
+							
+					//if(done_check){ //cdac-test-pid
+						//pr_err("bulk len==13 , data copied qtd->actual_length = %x\n", qtd->actual_length);
+						//done_check = 0;
+					//}
+					
+						
+							
+							
+					//unsigned char *	mem_data = (unsigned char  *)(qtd->data_buffer);
+						//vega_mem_io_dbg("------------IN payload %lx------------\n",qtd->payload_addr);
+						//for(k=0;k<qtd->actual_length;k++){
+							//vega_pr_err("%d: %x\n",k,mem_data[k]);
+							
+						//}
+						//vega_mem_io_dbg("------------IN payload-over------------\n");
+					/* Fall through (?) */
+				case OUT_PID:
+					qtd->urb->actual_length +=
+							qtd->actual_length;
+					/* Fall through ... */
+				case SETUP_PID:
+					break;
+				}
+			}
+
+			if (is_short_bulk(qtd)) {
+				if (qtd->urb->transfer_flags & URB_SHORT_NOT_OK)
+					qtd->urb->status = -EREMOTEIO;
+				if (!last_qtd)
+					qtd_next->status = QTD_RETIRE;
+			}
+		}
+
+		if (qtd->payload_addr)
+			free_mem(hcd, qtd);
+
+		if (last_qtd) {
+			if ((qtd->status == QTD_RETIRE) &&
+					(qtd->urb->status == -EINPROGRESS))
+				qtd->urb->status = -EPIPE;
+			/* Defer calling of urb_done() since it releases lock */
+			urb_listitem = kmem_cache_zalloc(urb_listitem_cachep,
+								GFP_ATOMIC);
+			if (unlikely(!urb_listitem))
+				break; /* Try again on next call */
+			urb_listitem->urb = qtd->urb;
+			list_add_tail(&urb_listitem->urb_list, urb_list);
+		}
+
+		list_del(&qtd->qtd_list);
+		qtd_free(qtd);
+	}
+}
+
+#define ENQUEUE_DEPTH	2
+static void enqueue_qtds(struct usb_hcd *hcd, struct vega_qh *qh)
+{
+	struct vega_hcd *priv = hcd_to_priv(hcd);
+	int ptd_offset;
+	struct vega_slotinfo *slots;
+	int curr_slot, free_slot;
+	int n;
+	struct ptd ptd;
+	struct vega_qtd *qtd;
+	int k=0;
+	//unsigned int  *mem_data;
+	
+	vega_dbg1(hcd->self.controller,"enqueue_qtds>>>>\n");
+
+	if (unlikely(list_empty(&qh->qtd_list))) {
+		WARN_ON(1);
+		return;
+	}
+
+	/* Make sure this endpoint's TT buffer is clean before queueing ptds */
+	if (qh->tt_buffer_dirty){
+		pr_err(">>>>>>Buffer dirty \n");
+		return;
+	}
+
+	if (usb_pipeint(list_entry(qh->qtd_list.next, struct vega_qtd,
+							qtd_list)->urb->pipe)) {
+		ptd_offset = INT_PTD_OFFSET;
+		slots = priv->int_slots;
+	} else if(usb_pipeisoc(list_entry(qh->qtd_list.next, struct vega_qtd,
+							qtd_list)->urb->pipe)) {
+		ptd_offset = ISO_PTD_OFFSET;
+		slots = priv->iso_slots;
+	}
+	   else{
+		ptd_offset = ATL_PTD_OFFSET;
+		slots = priv->atl_slots;
+	}
+
+	free_slot = -1;
+	for (curr_slot = 0; curr_slot < 32; curr_slot++) {
+		if ((free_slot == -1) && (slots[curr_slot].qtd == NULL))
+			free_slot = curr_slot;
+		if (slots[curr_slot].qh == qh)
+			break;
+	}
+
+	n = 0;
+	list_for_each_entry(qtd, &qh->qtd_list, qtd_list) {
+		if (qtd->status == QTD_ENQUEUED) {
+			WARN_ON(qtd->payload_addr);
+			alloc_mem(hcd, qtd);
+			if ((qtd->length) && (!qtd->payload_addr))
+				break;
+				vega_mem_io_dbg("qtd->length: %x, qtd->packet_type: %x \n",qtd->length, qtd->packet_type);
+
+			if ((qtd->length) &&
+			    ((qtd->packet_type == SETUP_PID) ||
+			     (qtd->packet_type == OUT_PID))) {
+
+				mem_writes8(hcd->regs, qtd->payload_addr,
+						qtd->data_buffer, qtd->length);
+						//mem_data = (unsigned int  *)(qtd->data_buffer);
+						//vega_pr_err(">>>>>OUT Payload :%d \n",qtd->length);
+						//vega_mem_io_dbg("------------payload------------\n");
+
+				//for(k=0;k<qtd->length;k++){
+					//vega_pr_err("%d: %x\n",k,mem_data[k]);
+					
+				//}
+				//vega_mem_io_dbg("------------payload-over------------\n");
+			}
+
+			qtd->status = QTD_PAYLOAD_ALLOC;
+		}
+
+		if (qtd->status == QTD_PAYLOAD_ALLOC) {
+/*
+			if ((curr_slot > 31) && (free_slot == -1))
+				vega_dbg(hcd->self.controller, "%s: No slot "
+					"available for transfer\n", __func__);
+*/
+			/* Start xfer for this endpoint if not already done */
+			
+			
+			if ((curr_slot > 31) && (free_slot > -1)) {
+				if (usb_pipeint(qtd->urb->pipe))
+					create_ptd_int(qh, qtd, &ptd);
+				else if (usb_pipeisoc(qtd->urb->pipe)){
+					gframe_index = vega_read32(hcd->regs, HC_FRINDEX); //uFrame Number
+					create_ptd_iso(qh, qtd, &ptd);
+				}
+				else
+					create_ptd_atl(qh, qtd, &ptd);
+				//pr_err("enqueue_qtds -> start_bus_transfer >>>>>\n");
+				start_bus_transfer(hcd, ptd_offset, free_slot,
+							slots, qtd, qh, &ptd);
+				curr_slot = free_slot;
+			}
+
+			n++;
+			if (n >= ENQUEUE_DEPTH)
+				break;
+		}
+	}
+}
+
+static void schedule_ptds(struct usb_hcd *hcd)
+{
+	struct vega_hcd *priv;
+	struct vega_qh *qh, *qh_next;
+	struct list_head *ep_queue;
+	LIST_HEAD(urb_list);
+	struct urb_listitem *urb_listitem, *urb_listitem_next;
+	int i;
+
+	//pr_err("schedule_ptds\n");
+
+	if (!hcd) {
+		WARN_ON(1);
+		return;
+	}
+
+	priv = hcd_to_priv(hcd);
+
+	/*
+	 * check finished/retired xfers, transfer payloads, call urb_done()
+	 */
+	for (i = 0; i < QH_END; i++) {
+		ep_queue = &priv->qh_list[i];
+		list_for_each_entry_safe(qh, qh_next, ep_queue, qh_list) {
+			collect_qtds(hcd, qh, &urb_list);
+			if (list_empty(&qh->qtd_list))
+				list_del(&qh->qh_list);
+		}
+	}
+
+	list_for_each_entry_safe(urb_listitem, urb_listitem_next, &urb_list,
+								urb_list) {
+		vega_urb_done(hcd, urb_listitem->urb);
+		kmem_cache_free(urb_listitem_cachep, urb_listitem);
+	}
+	
+	//unskip_check = 0; //cdac-test-pid
+
+	/*
+	 * Schedule packets for transfer.
+	 *
+	 * According to USB2.0 specification:
+	 *
+	 * 1st prio: interrupt xfers, up to 80 % of bandwidth
+	 * 2nd prio: control xfers
+	 * 3rd prio: bulk xfers
+	 *
+	 * ... but let's use a simpler scheme here (mostly because ISP1761 doc
+	 * is very unclear on how to prioritize traffic):
+	 *
+	 * 1) Enqueue any queued control transfers, as long as payload chip mem
+	 *    and PTD ATL slots are available.
+	 * 2) Enqueue any queued INT transfers, as long as payload chip mem
+	 *    and PTD INT slots are available.
+	 * 3) Enqueue any queued bulk transfers, as long as payload chip mem
+	 *    and PTD ATL slots are available.
+	 *
+	 * Use double buffering (ENQUEUE_DEPTH==2) as a compromise between
+	 * conservation of chip mem and performance.
+	 *
+	 * I'm sure this scheme could be improved upon!
+	 */
+	for (i = 0; i < QH_END; i++) {
+		ep_queue = &priv->qh_list[i];
+		list_for_each_entry_safe(qh, qh_next, ep_queue, qh_list)
+			enqueue_qtds(hcd, qh);
+	}
+	//pr_err("schedule_ptds over\n");
+}
+
+#define PTD_STATE_QTD_DONE	1
+#define PTD_STATE_QTD_RELOAD	2
+#define PTD_STATE_URB_RETIRE	3
+
+static int check_int_transfer(struct usb_hcd *hcd, struct ptd *ptd,
+								struct urb *urb)
+{
+	int mode_ctl, ep_num, ep_dir;
+	
+	if (ptd->dw0 & DW0_HALT_BIT) {
+
+		urb->status = -EPIPE; //stall
+		
+		
+		ep_num = (FROM_DW0_ENDPOINT_1_3(ptd->dw0) << 1) | FROM_DW1_ENDPOINT_0(ptd->dw1);
+		
+		ep_dir = FROM_DW0_PID_TOKEN(ptd->dw0);
+		
+		mode_ctl = vega_read32(hcd->regs, HC_HW_MODE_CTRL);
+		
+		mode_ctl = mode_ctl | (ep_dir << 12) | (ep_num << 7) | HW_PID_RESET;
+		vega_write32(hcd->regs, HC_HW_MODE_CTRL, mode_ctl ); // Do PID reset
+		mdelay(10);
+		mode_ctl &= ~HW_PID_RESET;
+		vega_write32(hcd->regs, HC_HW_MODE_CTRL, mode_ctl ); // Clear PID reset
+		
+
+		return PTD_STATE_URB_RETIRE;
+	}
+	
+	if ((ptd->dw0 & DW0_ERROR_BIT)) {
+		
+		pr_err("int ERROR BIT, CERR %x \n",FROM_DW1_CERR(ptd->dw1));
+		u32 temp = vega_read32(hcd->regs, HC_PORTSC1);
+	
+		return PTD_STATE_URB_RETIRE;
+		
+	}
+	
+	//if (!FROM_DW0_NAKCOUNT(ptd->dw0) ) {
+		/*
+		 * NAKs are handled in HW by the chip. Usually if the
+		 * device is not able to send data fast enough.
+		 * This happens mostly on slower hardware.
+		 */
+		//pr_err("NACK COUNT OVER\n");
+		//return PTD_STATE_QTD_RELOAD;
+
+		//}
+
+	//if (!FROM_DW0_NAKCOUNT(ptd->dw0) && (ptd->dw0 & DW0_ACTIVE_BIT)) {
+		/*
+		 * NAKs are handled in HW by the chip. Usually if the
+		 * device is not able to send data fast enough.
+		 * This happens mostly on slower hardware.
+		 */
+	//	pr_err("NACK COUNT OVER\n");
+	//	return PTD_STATE_QTD_RELOAD;
+//	}
+
+	return PTD_STATE_QTD_DONE;
+}
+
+
+static int check_iso_transfer(struct usb_hcd *hcd, struct ptd *ptd,
+								struct urb *urb)
+{
+	int mode_ctl, ep_num, ep_dir;
+	
+	if (ptd->dw0 & DW0_HALT_BIT) {
+
+		urb->status = -EPIPE; //stall
+		
+		
+		ep_num = (FROM_DW0_ENDPOINT_1_3(ptd->dw0) << 1) | FROM_DW1_ENDPOINT_0(ptd->dw1);
+		
+		ep_dir = FROM_DW0_PID_TOKEN(ptd->dw0);
+		
+		mode_ctl = vega_read32(hcd->regs, HC_HW_MODE_CTRL);
+		
+		mode_ctl = mode_ctl | (ep_dir << 12) | (ep_num << 7) | HW_PID_RESET;
+		vega_write32(hcd->regs, HC_HW_MODE_CTRL, mode_ctl ); // Do PID reset
+		mdelay(10);
+		mode_ctl &= ~HW_PID_RESET;
+		vega_write32(hcd->regs, HC_HW_MODE_CTRL, mode_ctl ); // Clear PID reset
+		
+
+		return PTD_STATE_URB_RETIRE;
+	}
+
+	return PTD_STATE_QTD_DONE;
+}
+
+static int check_atl_transfer(struct usb_hcd *hcd, struct ptd *ptd,
+								struct urb *urb)
+{
+	WARN_ON(!ptd);
+	vega_dbg1(hcd->self.controller,"check_atl_transfer function>>>> %x\n",ptd->dw0);
+	int mode_ctl, ep_num, ep_dir;
+	static int qtd_reload_count = 0;
+
+	if (ptd->dw0 & DW0_HALT_BIT) {
+		
+
+		urb->status = -EPIPE; //stall
+		
+		ep_num = (FROM_DW0_ENDPOINT_1_3(ptd->dw0) << 1) | FROM_DW1_ENDPOINT_0(ptd->dw1);
+		
+		ep_dir = FROM_DW0_PID_TOKEN(ptd->dw0);
+		
+		mode_ctl = vega_read32(hcd->regs, HC_HW_MODE_CTRL);
+		
+		mode_ctl = mode_ctl | (ep_dir << 12) | (ep_num << 7) | HW_PID_RESET;
+		vega_write32(hcd->regs, HC_HW_MODE_CTRL, mode_ctl ); // Do PID reset
+		mdelay(10);
+		mode_ctl &= ~HW_PID_RESET;
+		vega_write32(hcd->regs, HC_HW_MODE_CTRL, mode_ctl ); // Clear PID reset
+	
+		return PTD_STATE_URB_RETIRE;
+	}
+	
+	if ((ptd->dw0 & DW0_ERROR_BIT)) {
+		
+		pr_err("atl ERROR BIT, CERR %x \n",FROM_DW1_CERR(ptd->dw1));
+		u32 temp = vega_read32(hcd->regs, HC_PORTSC1);
+
+		urb->status = -EPROTO;
+				/*	pr_err("------------CERR---td RD val---------\n");
+					pr_err("dw0 : %x\n",ptd->dw0);
+					pr_err("dw1 : %x\n",ptd->dw1);
+					pr_err("dw2 : %x\n",ptd->dw2);		
+					pr_err("dw3 : %x\n",ptd->dw3);
+					pr_err("dw4 : %x\n",ptd->dw4);
+					pr_err("dw5 : %x\n",ptd->dw5);
+					pr_err("dw6 : %x\n",ptd->dw6);
+					pr_err("dw7 : %x\n",ptd->dw7);
+					pr_err("++++++++++++CERR++++++++++++\n");*/
+
+
+	
+		return PTD_STATE_URB_RETIRE;
+
+	}
+
+	if (vega_hub_speed != HUB_SPEED_HIGH){ //added as full speed hub was not working
+		
+		if (!FROM_DW0_NAKCOUNT(ptd->dw0) ) {
+			/*
+			 * NAKs are handled in HW by the chip. Usually if the
+			 * device is not able to send data fast enough.
+			 * This happens mostly on slower hardware.
+			 */
+			//pr_err("NACK COUNT OVER\n");
+
+			//if(FROM_DW2_EP_TYPE(ptd->dw2) == 0) //Control transfer -- infinite retry on NAK
+			//	return PTD_STATE_QTD_DONE;
+			//else{ //Bulk transfer -- 5000 retry on NAK
+				qtd_reload_count++;
+				if(qtd_reload_count > 5000) {
+					qtd_reload_count = 0;
+					urb->status = -EPROTO;
+					pr_err("NACK  retry\n");
+					return PTD_STATE_URB_RETIRE;
+				} else
+					return PTD_STATE_QTD_RELOAD;
+			//}
+
+		}
+	}
+
+	//if (!FROM_DW0_NAKCOUNT(ptd->dw0) && (ptd->dw0 & DW0_ACTIVE_BIT)) {
+		/*
+		 * NAKs are handled in HW by the chip. Usually if the
+		 * device is not able to send data fast enough.
+		 * This happens mostly on slower hardware.
+		 */
+		//pr_err("NACK COUNT OVER\n");
+		//return PTD_STATE_QTD_RELOAD;
+	//}
+
+	return PTD_STATE_QTD_DONE;
+}
+
+
+static void handle_done_ptds(struct usb_hcd *hcd)
+{
+	struct vega_hcd *priv = hcd_to_priv(hcd);
+	struct ptd ptd;
+	struct vega_qh *qh;
+	int slot;
+	int state;
+	struct vega_slotinfo *slots;
+	u32 ptd_offset;
+	struct vega_qtd *qtd;
+	int modified;
+	int skip_map;
+	
+	vega_dbg1(hcd->self.controller,"handle_done_ptds>>>>\n");
+	//pr_err("priv->int_done_map %x >>>>>\n",priv->int_done_map);
+	//pr_err("priv->atl_done_map %x >>>>>\n",priv->atl_done_map);
+
+	//skip_map = int_skipmap_global; //vega_read32(hcd->regs, HC_INT_PTD_SKIPMAP_REG);
+	
+	//pr_err("skip_map 1 %x >>>>>\n",skip_map);
+	//pr_err("priv->int_done_map 1 %x >>>>>\n",priv->int_done_map);
+	
+	//skip_map = vega_read32(hcd->regs, HC_ATL_Pvega_usb_remove(struct platform_device *op);
+TD_SKIPMAP_REG);
+	//pr_err("skip_map 2 %x >>>>>\n",skip_map);
+	//pr_err("priv->atl_done_map 2 %x >>>>>\n",priv->atl_done_map);
+	
+	skip_map = int_skipmap_global ; //vega_read32(hcd->regs, HC_ATL_PTD_SKIPMAP_REG); //FIXME
+	priv->int_done_map &= ~skip_map;
+	skip_map = atl_skipmap_global ; //vega_read32(hcd->regs, HC_ATL_PTD_SKIPMAP_REG);  //FIXME
+	priv->atl_done_map &= ~skip_map;
+
+	skip_map = iso_skipmap_global ; //vega_read32(hcd->regs, HC_ATL_PTD_SKIPMAP_REG);  //FIXME
+	priv->iso_done_map &= ~skip_map;
+
+	modified = priv->int_done_map || priv->atl_done_map ||priv->iso_done_map;
+	
+	//pr_err("priv->int_done_map %x >>>>>\n",priv->int_done_map);
+	//pr_err("priv->atl_done_map %x >>>>>\n",priv->atl_done_map);
+	
+
+
+	while (priv->int_done_map || priv->atl_done_map || priv->iso_done_map) {
+		//vega_pr_err(".");
+		if (priv->int_done_map) {
+			/* INT ptd */
+			slot = __ffs(priv->int_done_map);
+			priv->int_done_map &= ~(1 << slot);
+			slots = priv->int_slots;
+			/* This should not trigger, and could be removed if
+			   noone have any problems with it triggering: */
+			if (!slots[slot].qh) {
+				WARN_ON(1);
+				continue;
+			}
+			ptd_offset = INT_PTD_OFFSET;
+			ptd_read(hcd->regs, INT_PTD_OFFSET, slot, &ptd);
+			state = check_int_transfer(hcd, &ptd,
+							slots[slot].qtd->urb);
+		} else if(priv->iso_done_map)
+		{		
+			/* ISO ptd */
+			slot = __ffs(priv->iso_done_map);
+			priv->iso_done_map &= ~(1 << slot);
+			slots = priv->iso_slots;
+			/* This should not trigger, and could be removed if
+			   noone have any problems with it triggering: */
+			if (!slots[slot].qh) {
+				WARN_ON(1);
+				continue;
+			}
+			ptd_offset = ISO_PTD_OFFSET;
+			ptd_read(hcd->regs, ISO_PTD_OFFSET, slot, &ptd);
+			state = check_iso_transfer(hcd, &ptd,
+							slots[slot].qtd->urb);	
+
+		}		
+		 else {
+			 //pr_err("done\n");
+			/* ATL ptd */
+			//pr_err("ATL ptd>>>>\n");
+			//pr_err("priv->atl_done_map %x >>>>>\n",priv->atl_done_map);
+			slot = __ffs(priv->atl_done_map);
+			priv->atl_done_map &= ~(1 << slot);
+			slots = priv->atl_slots;
+			/* This should not trigger, and could be removed if
+			   noone have any problems with it triggering: */
+			if (!slots[slot].qh) {
+				WARN_ON(1);
+				continue;
+			}
+			ptd_offset = ATL_PTD_OFFSET;
+			ptd_read(hcd->regs, ATL_PTD_OFFSET, slot, &ptd);
+			//pr_err("done_map \n");
+			state = check_atl_transfer(hcd, &ptd,
+							slots[slot].qtd->urb);
+							
+							
+			//vega_dbg1(hcd->self.controller,"state: %x\n",state);				
+		}
+
+		vega_handle_ptd_dbg(hcd->self.controller,"ptd.dw0 :%x, ptd.dw1 :%x, ptd.dw2 :%x\n",ptd.dw0,ptd.dw1,ptd.dw2);
+
+		qtd = slots[slot].qtd;
+		slots[slot].qtd = NULL;
+		qh = slots[slot].qh;
+		slots[slot].qh = NULL;
+		qh->slot = -1;
+
+		WARN_ON(qtd->status != QTD_XFER_STARTED);
+
+		switch (state) {
+		case PTD_STATE_QTD_DONE:
+			if ((usb_pipeint(qtd->urb->pipe)) &&
+				       (qtd->urb->dev->speed != USB_SPEED_HIGH)) {
+				qtd->actual_length =
+				       FROM_DW2_SCS_NRBYTESTRANSFERRED(ptd.dw2);
+			//	pr_err("int qtd->actual_length:%x\n", qtd->actual_length);	   
+
+			}
+
+			else if ((usb_pipeisoc(qtd->urb->pipe)) &&
+				       (qtd->urb->dev->speed != USB_SPEED_HIGH)){
+				qtd->actual_length =
+				       FROM_DW2_SCS_NRBYTESTRANSFERRED(ptd.dw2);
+
+				//pr_err("iso qtd->actual_length:%x\n", qtd->actual_length);	   
+			}
+			else {
+				qtd->actual_length =
+					FROM_DW2_NRBYTESTRANSFERRED(ptd.dw2);
+							
+				/*if((qtd->actual_length == 0) || (qtd->actual_length == 13)){
+				
+					pr_err("bulk qtd->actual_length:%d\n", qtd->actual_length);	  
+				
+					pr_err("------------uc------------\n");
+					pr_err("Slot : %d\n",slot);
+					pr_err("dw0 : %x\n",ptd.dw0);
+					pr_err("dw1 : %x\n",ptd.dw1);
+					pr_err("dw2 : %x\n",ptd.dw2);		
+					pr_err("dw3 : %x\n",ptd.dw3);
+					pr_err("dw4 : %x\n",ptd.dw4);
+					pr_err("dw5 : %x\n",ptd.dw5);
+					pr_err("dw6 : %x\n",ptd.dw6);
+					pr_err("dw7 : %x\n",ptd.dw7);
+					pr_err("++++++++++++uc++++++++++++\n");
+				}*/
+				 
+			}
+					
+			/*if (usb_pipebulk(qtd->urb->pipe)){	//cdac-test-pid
+				if((qtd->length == 13) && (qtd->packet_type == IN_PID)){
+					//pr_err("bulk len==13 done, qtd->actual_length = %d\n", qtd->actual_length);
+					done_check=1;
+				}
+			}*/
+					
+					
+
+			vega_handle_ptd_dbg(hcd->self.controller,"qtd->actual_length:%x\n", qtd->actual_length);	
+			
+								
+
+			qtd->status = QTD_XFER_COMPLETE;
+			
+			if(qtd->packet_type == 0) {
+			
+				qh->ping = FROM_DW0_PING(ptd.dw0);
+				
+				//pr_err("aa qh->ping=%d\n", qh->ping);
+			}
+			
+			if (list_is_last(&qtd->qtd_list, &qh->qtd_list) ||
+							is_short_bulk(qtd))
+				qtd = NULL;
+			else
+				qtd = list_entry(qtd->qtd_list.next,
+							typeof(*qtd), qtd_list);
+
+			qh->toggle = FROM_DW2_DATA_TOGGLE(ptd.dw2);
+
+			break;
+
+		case PTD_STATE_QTD_RELOAD: /* QTD_RETRY, for atls only */
+			vega_pr_err("PTD_STATE_QTD_RELOAD\n");
+			qtd->status = QTD_PAYLOAD_ALLOC;
+			ptd.dw0 |= DW0_VALID_BIT;
+			/* RL counter = ERR counter */
+			ptd.dw0 &= ~TO_DW0_NAKCOUNT(0xf);
+			ptd.dw0 |= TO_DW0_NAKCOUNT(FROM_DW0_RL(ptd.dw0));
+			ptd.dw1 &= ~TO_DW1_CERR(3);
+			ptd.dw1 |= TO_DW1_CERR(ERR_COUNTER);
+			qh->toggle = FROM_DW2_DATA_TOGGLE(ptd.dw2);
+
+			if(qtd->packet_type == 0) {
+				qh->ping = FROM_DW0_PING(ptd.dw0);
+				//pr_err("bb qh->ping=%d\n", qh->ping);
+			}
+			break;
+
+		case PTD_STATE_URB_RETIRE:
+			qtd->status = QTD_RETIRE;
+			vega_pr_err("PTD_STATE_URB_RETIRE\n");
+			if(vega_hub_speed == HUB_SPEED_HIGH) {
+				if ((qtd->urb->dev->speed != USB_SPEED_HIGH) &&
+						(qtd->urb->status != -EPIPE) &&
+						(qtd->urb->status != -EREMOTEIO)) {
+					qh->tt_buffer_dirty = 1;
+					if (usb_hub_clear_tt_buffer(qtd->urb))
+						/* Clear failed; let's hope things work
+						anyway */
+						qh->tt_buffer_dirty = 0;
+				}
+			}
+			qtd = NULL;
+			qh->toggle = 0;
+			qh->ping = 0;		
+			break;
+
+		default:
+			WARN_ON(1);
+			continue;
+		}
+
+		if (qtd && (qtd->status == QTD_PAYLOAD_ALLOC)) {
+			if (slots == priv->int_slots) {
+				if (state == PTD_STATE_QTD_RELOAD)
+					vega_dbg(hcd->self.controller,
+						"%s: PTD_STATE_QTD_RELOAD on "
+						"interrupt packet\n", __func__);
+				if (state != PTD_STATE_QTD_RELOAD)
+					create_ptd_int(qh, qtd, &ptd);
+			}else if (slots == priv->iso_slots) {
+				if (state == PTD_STATE_QTD_RELOAD)
+					vega_dbg(hcd->self.controller,
+						"%s: PTD_STATE_QTD_RELOAD on "
+						"iso packet\n", __func__);
+				if (state != PTD_STATE_QTD_RELOAD)
+					create_ptd_iso(qh, qtd, &ptd);
+			} 
+			else {
+				if (state != PTD_STATE_QTD_RELOAD)
+					create_ptd_atl(qh, qtd, &ptd);
+			}
+			//pr_err("handle_done_ptds -> start_bus_transfer >>>>>\n");
+			start_bus_transfer(hcd, ptd_offset, slot, slots, qtd,
+				qh, &ptd);
+		}
+	}
+
+
+	if (modified) {
+
+		//if(done_check)
+			//pr_err("bulk len==13 schedule_ptds  \n");
+		schedule_ptds(hcd);
+		//pr_err("modified\n");
+	}
+
+	vega_dbg1(hcd->self.controller,"handle_done_ptds over>>>>\n");
+}
+
+
+
+static int handshake_hcd(struct usb_hcd *hcd, u32 reg,
+		      u32 mask, u32 done, int usec)
+{
+	u32 result;
+
+	do {
+		result = vega_read32(hcd->regs, reg);
+		
+		if (result == ~0)
+			return -ENODEV;
+		result &= mask;
+		if (result == done)
+			return 0;
+		udelay(1);
+		usec--;
+	} while (usec > 0);
+	return -ETIMEDOUT;
+}
+
+static int handshake(struct vega_device *hcd, u32 reg,
+		      u32 mask, u32 done, int usec)
+{
+	u32 result;
+
+	do {
+		result = vega_read32(hcd->regs, reg);
+		
+		if (result == ~0)
+			return -ENODEV;
+		result &= mask;
+		if (result == done)
+			return 0;
+		udelay(1);
+		usec--;
+	} while (usec > 0);
+	return -ETIMEDOUT;
+}
+
+/* one-time init, only for memory state */
+static int priv_init(struct usb_hcd *hcd)
+{
+	struct vega_hcd		*priv = hcd_to_priv(hcd);
+	u32			hcc_params;
+	int i;
+
+	spin_lock_init(&priv->lock);
+
+	vega_init_dbg("priv_init\n");
+
+	for (i = 0; i < QH_END; i++)
+		INIT_LIST_HEAD(&priv->qh_list[i]);
+
+	/*
+	 * hw default: 1K periodic list heads, one per frame.
+	 * periodic_size can shrink by USBCMD update if hcc_params allows.
+	 */
+	priv->periodic_size = DEFAULT_I_TDPS;
+
+	/* controllers may cache some of the periodic schedule ... */
+	hcc_params = vega_read32(hcd->regs, HC_HCCPARAMS);
+	/* full frame cache */
+	if (HCC_ISOC_CACHE(hcc_params))
+		priv->i_thresh = 8;
+	else /* N microframes cached */
+		priv->i_thresh = 2 + HCC_ISOC_THRES(hcc_params);
+
+
+	pr_err("priv_init priv->periodic_size %d, priv->i_thresh %d\n", priv->periodic_size, priv->i_thresh);
+	
+
+	return 0;
+}
+
+static struct vega_qh *qh_alloc(gfp_t flags)
+{
+	struct vega_qh *qh;
+
+	qh = kmem_cache_zalloc(qh_cachep, flags);
+	if (!qh)vega_init_core
+		return NULL;
+
+	INIT_LIST_HEAD(&qh->qh_list);
+	INIT_LIST_HEAD(&qh->qtd_list);
+	qh->slot = -1;
+
+	return qh;
+}
+
+static void qh_free(struct vega_qh *qh)
+{
+	WARN_ON(!list_empty(&qh->qtd_list));
+	WARN_ON(qh->slot > -1);
+	kmem_cache_free(qh_cachep, qh);
+}
+
+/* reset a non-running (STS_HALT == 1) controller */
+static int ehci_reset(struct usb_hcd *hcd)
+{
+	struct vega_hcd *priv = hcd_to_priv(hcd);
+	int ret =0;
+
+	u32 command = vega_read32(hcd->regs, HC_USBCMD);
+
+	//command |= CMD_RESET;
+	//vega_write32(hcd->regs, HC_USBCMD, command);
+	hcd->state = HC_STATE_HALT;
+	priv->next_statechange = jiffies;
+	
+	vega_write32(hcd->regs, HC_INTERRUPT_REG, 0xffffffff); //FIXME Clear interrupts	
+	vega_write32(hcd->regs, HC_INTERRUPT_ENABLE, 0); //FIXME Clear interrupt enable
+
+	
+	vega_dbg(hcd->self.controller, "HC_INTERRUPT_ENABLE : %x\n", vega_read32(hcd->regs, HC_INTERRUPT_ENABLE));
+
+	vega_init_dbg("ehci_reset over\n");
+
+
+	return 0;//FIXME
+	
+	ret = handshake_hcd(hcd, HC_USBCMD, CMD_RESET, 0, 250 * 1000);
+	vega_dbg(hcd->self.controller, "handshake : %d\n", ret);
+
+
+
+	return ret;
+}
+
+static void vega_init_core(struct vega_device *vega)
+{
+	u32 otgctrl = 0;
+	u32 hwmode;
+	u32 mode_ctl;
+
+	/* Low-level chip reset */
+	/*if (vega->rst_gpio) {
+		gpiod_set_value_cansleep(isp->rst_gpio, 1);
+		msleep(50);
+		gpiod_set_value_cansleep(isp->rst_gpio, 0);
+	}*/
+
+	/*
+	 * Reset the host controller, including the CPU interface
+	 * configuration.
+	 */
+	vega_dbg(vega->dev, "vega->regs : %lx \n",(long unsigned int)vega->regs);
+	
+	vega_write32(vega->regs, HC_PORT1_CTRL, 0);
+	 
+	vega_write32(vega->regs, HC_RESET_REG, SW_RESET_RESET_ALL); //FIXME
+	udelay(1000);
+	vega_write32(vega->regs, HC_RESET_REG, 0); //FIXME
+
+	vega_dbg(vega->dev,"SW Reset !! ");
+
+	vega_write32(vega->regs, DC_UNLOCKDEV, 0x00BC0064); //FIXME  75 mHz 
+	//vega_write32(vega->regs, DC_UNLOCKDEV, 0x003f0021); //FIXME  25 mHz
+
+
+	vega_dbg(vega->dev,"Time reg written !! ");
+	
+	//vega_write32(vega->regs, HC_SOF_COUNT, 0xcdb4); //SOF count for full speed hub
+	//vega_write32(vega->regs, HC_FULL_SPEED_SOF_COUNT, 0xcdb4); 
+
+	//vega_write32(vega->regs, HS_IPD_COUNT, 0x0096); //IPD Count for High Speed
+
+	//vega_write32(vega->regs, HC_FULL_SPEED_TR_IPD, 0x5dc); 
+
+	//vega_write32(vega->regs, HC_FULL_SPEED_HUB_IPD, 0x87); 
+	
+	//dev_err(vega->dev,"HC_SOF_COUNT reg written !! ");
+		    
+   	otgctrl =  (HW_OTG_SE0_EN); 
+   	vega_write32(vega->regs, HC_PORT1_CTRL, otgctrl);
+	otgctrl |=  (HW_OTG_DISABLE);
+	vega_write32(vega->regs, HC_PORT1_CTRL, otgctrl);
+
+	//dev_err(vega->dev,"HC_OTG_STATUS !! %0x",vega_read32(vega->regs,HC_OTG_STATUS) );
+
+	otgctrl |=HW_VBUS_DRV;	 //Set for RPDP board, clear for VU440 board
+	vega_write32(vega->regs, HC_PORT1_CTRL, otgctrl);
+
+	//Wail for VBUS VALID
+	handshake(vega,HC_OTG_STATUS, HW_VBUS_VLD, HW_VBUS_VLD , 250 * 1000 );
+
+	vega_dbg(vega->dev, "HC_OTG_STATUS : %x", vega_read32(vega->regs,HC_OTG_STATUS) );
+
+	otgctrl |=  (HW_DM_PULLDOWN | HW_DP_PULLDOWN);
+	
+	vega_write32(vega->regs, HC_PORT1_CTRL, otgctrl);
+
+	/* Setup HW Mode Control: This assumes a level active-low interrupt */
+	//hwmode = HW_DATA_BUS_32BIT;
+	hwmode = HW_INTR_HIGH_ACT;
+
+
+	/*
+	 * We have to set this first in case we're in 16-bit mode.
+	 * Write it twice to ensure correct upper bits if switching
+	 * to 16-bit mode.
+	 */
+	vega_write32(vega->regs, HC_HW_MODE_CTRL, hwmode);
+	//vega_write32(vega->regs, HC_HW_MODE_CTRL, hwmode);
+	
+	vega_dbg(vega->dev, "HC_HW_MODE_CTRL : %x", hwmode);
+	
+	mode_ctl = vega_read32(vega->regs, HC_HW_MODE_CTRL);
+	
+	vega_dbg(vega->dev, "mode_ctl : %x ",mode_ctl);
+
+	vega_init_dbg("vega_init_core over\n");
+
+
+
+	dev_info(vega->dev, "bus width: %u, oc: %s",
+		 vega->devflags & VEGA_FLAG_BUS_WIDTH_16 ? 16 : 32,
+		 vega->devflags & VEGA_FLAG_ANALOG_OC ? "analog" : "digital");
+}
+
+static irqreturn_t vega_irq(struct usb_hcd *hcd)
+{
+	struct vega_hcd *priv = hcd_to_priv(hcd);
+	u32 imask;
+	irqreturn_t irqret = IRQ_NONE;
+	unsigned long		flags;
+
+
+	//pr_err( "<***********************vega_irq***********************>\n");
+
+	spin_lock_irqsave(&priv->lock, flags);
+
+	vega_dbg1(hcd->self.controller, "HC_HW_MODE_CTRL : %x\n", vega_read32(hcd->regs, HC_HW_MODE_CTRL));
+	
+	imask = vega_read32(hcd->regs, HC_INTERRUPT_REG);
+	vega_dbg1(hcd->self.controller,"HC_INTERRUPT_REG >>>>> %x \n",imask);
+	
+	if (!(hcd->state & HC_STATE_RUNNING))
+		goto leave;
+
+	imask = vega_read32(hcd->regs, HC_INTERRUPT_REG);
+	
+	
+	//pr_err("isr INTR status: %0x\n",imask);
+	
+	vega_dbg1(hcd->self.controller,"HC_INTERRUPT_REG >>>>> %x \n",imask);
+	if (unlikely(imask==0))
+		goto leave;
+	vega_write32(hcd->regs, HC_INTERRUPT_REG, imask); /* Clear */
+	if(imask & (HC_INTL_INT | HC_ATL_INT | HC_ISO_INT))//Checking int/iso/atl interrupts
+	{
+		vega_dbg1(hcd->self.controller,"USB IRQ CLEAR>>>>>\n");
+		vega_dbg1(hcd->self.controller,"priv->int_done_map %x >>>>>\n",priv->int_done_map);
+		vega_dbg1(hcd->self.controller,"priv->atl_done_map %x >>>>>\n",priv->atl_done_map);
+		vega_dbg1(hcd->self.controller,"priv->iso_done_map %x >>>>>\n",priv->iso_done_map);
+		priv->int_done_map |= vega_read32(hcd->regs, HC_INT_PTD_DONEMAP_REG);
+		priv->atl_done_map |= vega_read32(hcd->regs, HC_ATL_PTD_DONEMAP_REG);
+		priv->iso_done_map |= vega_read32(hcd->regs, HC_ISO_PTD_DONEMAP_REG);
+		vega_dbg1(hcd->self.controller,"priv->int_done_map %x >>>>>\n",priv->int_done_map);
+		vega_dbg1(hcd->self.controller,"priv->atl_done_map %x >>>>>\n",priv->atl_done_map);
+		vega_dbg1(hcd->self.controller,"priv->iso_done_map %x >>>>>\n",priv->iso_done_map);
+		
+		//del_timer(&errata2_timer);
+
+		handle_done_ptds(hcd);
+	}
+	
+	if(imask &  HC_DISCONNECT_INT)
+	{
+		device_disconnected = 1;
+		//msleep(10); //Debounce time
+		handshake_hcd(hcd, HC_PORTSC1, 2, 1 , 50*1000); //Debounce time
+	} 
+
+	if(imask &  HC_CONNECT_INT)
+	{
+		device_connected = 1;
+		//msleep(10); //Debounce time
+		handshake_hcd(hcd, HC_PORTSC1, 2, 1 , 50*1000); //Debounce time
+	} 
+
+	irqret = IRQ_HANDLED;
+leave:
+
+	spin_unlock_irqrestore(&priv->lock, flags);
+
+	vega_probe_dbg(hcd->self.controller, "<***********************vega_irq over %x***********************>\n", irqret);
+	
+	
+
+	if(imask &  (HC_DISCONNECT_INT | HC_CONNECT_INT))
+	{
+		//pr_err("DISCONNECT/CONNECT INTR : %0x\n",imask);
+
+		port_change_flag = 1;
+		usb_hcd_poll_rh_status(hcd);
+	}
+
+
+	//pr_err("isr INTR return: \n");
+
+	return irqret;
+	
+}
+
+static int vega_setup(struct usb_hcd *hcd)
+{	
+	struct vega_hcd *priv = hcd_to_priv(hcd);
+	int result;
+	u32 scratch;
+
+	vega_probe_dbg(hcd->self.controller, "<***********************vega_setup***********************>\n");
+	/* Change bus pattern */
+	scratch = vega_read32(hcd->regs, HC_CHIP_ID_REG);
+	
+	vega_dbg(hcd->self.controller, "HC_CHIP_ID_REG %x\n",scratch);
+	
+		/*
+	 * The RESET_HC bit in the SW_RESET register is supposed to reset the
+	 * host controller without touching the CPU interface registers, but at
+	 * least on the ISP1761 it seems to behave as the RESET_ALL bit and
+	 * reset the whole device. We thus can't use it here, so let's reset
+	 * the host controller through the EHCI USB Command register. The device
+	 * has been reset in core code anyway, so this shouldn't matter.
+	 */
+	vega_write32(hcd->regs, HC_BUFFER_STATUS_REG, 0);
+	atl_skipmap_global=NO_TRANSFER_ACTIVE;
+	vega_write32(hcd->regs, HC_ATL_PTD_SKIPMAP_REG, NO_TRANSFER_ACTIVE);
+	int_skipmap_global=NO_TRANSFER_ACTIVE;
+	iso_skipmap_global=NO_TRANSFER_ACTIVE;
+	vega_write32(hcd->regs, HC_INT_PTD_SKIPMAP_REG, NO_TRANSFER_ACTIVE);
+	vega_write32(hcd->regs, HC_ISO_PTD_SKIPMAP_REG, NO_TRANSFER_ACTIVE);
+
+	vega_dbg(hcd->self.controller, "b4 ehci_reset\n");
+
+	result = ehci_reset(hcd);
+	
+	vega_dbg(hcd->self.controller, "after ehci_reset %d\n", result);
+	
+	if (result)
+		return result;
+		
+	vega_dbg(hcd->self.controller, "reset success%d\n", result);
+
+	vega_write32(hcd->regs, HC_INTERRUPT_ENABLE, INTERRUPT_ENABLE_MASK);
+	
+	//pr_err("INTERRUPT_ENABLE_MASK\n\r");
+
+	vega_dbg(hcd->self.controller, "HC_HW_MODE_CTRL : %x\n", vega_read32(hcd->regs, HC_HW_MODE_CTRL));
+	vega_dbg(hcd->self.controller, "HC_INTERRUPT_ENABLE : %x\n", vega_read32(hcd->regs, HC_INTERRUPT_ENABLE));
+	
+	priv->hcs_params = 0x0101; //vega_read32(hcd->regs, HC_HCSPARAMS); FIXME only one port
+
+	vega_probe_dbg(hcd->self.controller, "<***********************vega_setup over***********************>\n");
+
+						vega_init_dbg("vega_setup over\n");
+
+
+	return priv_init(hcd);
+}
+
+
+
+
+static int vega_run(struct usb_hcd *hcd)
+{
+	int retval;
+	u32 temp;
+	u32 command;
+	u32 chipid;
+	vega_probe_dbg(hcd->self.controller, "<***********************vega_run***********************>\n");
+	vega_dbg(hcd->self.controller, "HC_HW_MODE_CTRL : %x\n", vega_read32(hcd->regs, HC_HW_MODE_CTRL));
+	
+	hcd->uses_new_polling = 1;
+
+	hcd->state = HC_STATE_RUNNING;
+
+	//set_bit(HCD_FLAG_POLL_RH, &hcd->flags);
+
+	/* Set PTD interrupt AND & OR maps */
+	vega_write32(hcd->regs, HC_ATL_IRQ_MASK_AND_REG, 0);
+	vega_write32(hcd->regs, HC_ATL_IRQ_MASK_OR_REG, 0xffffffff);
+	vega_write32(hcd->regs, HC_INT_IRQ_MASK_AND_REG, 0);
+	vega_write32(hcd->regs, HC_INT_IRQ_MASK_OR_REG, 0xffffffff);
+	vega_write32(hcd->regs, HC_ISO_IRQ_MASK_AND_REG, 0);
+	vega_write32(hcd->regs, HC_ISO_IRQ_MASK_OR_REG, 0xffffffff);
+	/* step 23 passed */
+
+	temp = vega_read32(hcd->regs, HC_HW_MODE_CTRL);
+	vega_write32(hcd->regs, HC_HW_MODE_CTRL, temp | HW_GLOBAL_INTR_EN);
+	
+	vega_dbg(hcd->self.controller, "HC_HW_MODE_CTRL : %x\n", vega_read32(hcd->regs, HC_HW_MODE_CTRL));
+
+	//command = vega_read32(hcd->regs, HC_USBCMD);
+	//command &= ~(CMD_LRESET|CMD_RESET);
+	//command |= CMD_RUN;
+	//vega_write32(hcd->regs, HC_USBCMD, command);
+	//while(1);
+	//retval = handshake_hcd(hcd, HC_USBCMD, CMD_RUN, CMD_RUN, 250 * 1000);
+	vega_dbg(hcd->self.controller, "handshake : %x\n",retval);
+	//if (retval)
+	//	return retval;
+
+	/*
+	 * XXX
+	 * Spec says to write FLAG_CF as last config action, priv code grabs
+	 * the semaphore while doing so.
+	 */
+	//down_write(&ehci_cf_port_reset_rwsem);
+	/*vega_write32(hcd->regs, HC_CONFIGFLAG, FLAG_CF);
+
+	retval = handshake(hcd, HC_CONFIGFLAG, FLAG_CF, FLAG_CF, 250 * 1000);*/
+	//up_write(&ehci_cf_port_reset_rwsem);
+	/*vega_dbg(hcd->self.controller, "handshake : %x\n",retval);
+	if (retval)
+		return retval;*/
+
+	/*errata2_timer_hcd = hcd;
+	timer_setup(&errata2_timer, errata2_function, 0);
+	errata2_timer.expires = jiffies + msecs_to_jiffies(SLOT_CHECK_PERIOD);
+	add_timer(&errata2_timer);*/
+
+	chipid = vega_read32(hcd->regs, HC_CHIP_ID_REG);
+	dev_info(hcd->self.controller, "USB ISP %04x HW rev. %d started\n",
+					chipid & 0xffff, chipid >> 16);
+
+	/* PTD Register Init Part 2, Step 28 */
+
+	/* Setup registers controlling PTD checking */
+	vega_write32(hcd->regs, HC_ATL_PTD_LASTPTD_REG, 0x80000000);
+	vega_write32(hcd->regs, HC_INT_PTD_LASTPTD_REG, 0x80000000);
+	vega_write32(hcd->regs, HC_ISO_PTD_LASTPTD_REG, 0x80000000);
+	atl_skipmap_global=0xffffffff;
+	vega_write32(hcd->regs, HC_ATL_PTD_SKIPMAP_REG, 0xffffffff);
+	int_skipmap_global=0xffffffff;
+	iso_skipmap_global=0xffffffff;
+	vega_write32(hcd->regs, HC_INT_PTD_SKIPMAP_REG, 0xffffffff);
+	vega_write32(hcd->regs, HC_ISO_PTD_SKIPMAP_REG, 0xffffffff);
+	vega_write32(hcd->regs, HC_BUFFER_STATUS_REG,
+						ATL_BUF_FILL | INT_BUF_FILL | ISO_BUF_FILL);
+
+	/* GRR this is run-once init(), being done every time the HC starts.
+	 * So long as they're part of class devices, we can't do it init()
+	 * since the class device isn't created that early.
+	 */
+
+					vega_init_dbg("vega_run over\n");
+
+	vega_probe_dbg(hcd->self.controller, "<***********************vega_run over***********************>\n");
+
+	return 0;	
+}
+
+static int qtd_fill(struct vega_qtd *qtd, void *databuffer, size_t len)
+{
+	qtd->data_buffer = databuffer;
+
+	if (len > MAX_PAYLOAD_SIZE)
+		len = MAX_PAYLOAD_SIZE;
+	qtd->length = len;
+
+	return qtd->length;
+}
+
+static void qtd_list_free(struct list_head *qtd_list)
+{
+	struct vega_qtd *qtd, *qtd_next;
+
+	list_for_each_entry_safe(qtd, qtd_next, qtd_list, qtd_list) {
+		list_del(&qtd->qtd_list);
+		qtd_free(qtd);
+	}
+}
+
+/*
+ * Packetize urb->transfer_buffer into list of packets of size wMaxPacketSize.
+ * Also calculate the PID type (SETUP/IN/OUT) for each packet.
+ */
+#define max_packet(wMaxPacketSize) ((wMaxPacketSize) & 0x07ff)
+static void packetize_urb(struct usb_hcd *hcd,
+		struct urb *urb, struct list_head *head, gfp_t flags)
+{
+	struct vega_qtd *qtd;
+	void *buf;
+	int len, maxpacketsize;
+	u8 packet_type;
+
+	/*
+	 * URBs map to sequences of QTDs:  one logical transaction
+	 */
+
+	if (!urb->transfer_buffer && urb->transfer_buffer_length) {
+		/* XXX This looks like usb storage / SCSI bug */
+		vega_dbg1(hcd->self.controller,
+				"buf is null, dma is %08lx len is %d\n",
+				(long unsigned)urb->transfer_dma,
+				urb->transfer_buffer_length);
+		WARN_ON(1);
+	}
+
+	if (usb_pipein(urb->pipe))
+		packet_type = IN_PID;
+	else
+		packet_type = OUT_PID;
+
+	if (usb_pipecontrol(urb->pipe)) {
+		qtd = qtd_alloc(flags, urb, SETUP_PID);
+		if (!qtd)
+			goto cleanup;
+		qtd_fill(qtd, urb->setup_packet, sizeof(struct usb_ctrlrequest));
+		list_add_tail(&qtd->qtd_list, head);
+
+		/* for zero length DATA stages, STATUS is always IN */
+		if (urb->transfer_buffer_length == 0)
+			packet_type = IN_PID;
+	}
+
+	maxpacketsize = max_packet(usb_maxpacket(urb->dev, urb->pipe,
+						usb_pipeout(urb->pipe)));
+
+	/*
+	 * buffer gets wrapped in one or more qtds;
+	 * last one may be "short" (including zero len)
+	 * and may serve as a control status ack
+	 */
+	buf = urb->transfer_buffer;
+	len = urb->transfer_buffer_length;
+
+	for (;;) {
+		int this_qtd_len;
+
+		qtd = qtd_alloc(flags, urb, packet_type);
+		if (!qtd)
+			goto cleanup;
+		this_qtd_len = qtd_fill(qtd, buf, len);
+		list_add_tail(&qtd->qtd_list, head);
+
+		len -= this_qtd_len;
+		buf += this_qtd_len;
+
+		if (len <= 0)
+			break;
+	}
+
+	/*
+	 * control requests may need a terminating data "status" ack;
+	 * bulk ones may need a terminating short packet (zero length).
+	 */
+	if (urb->transfer_buffer_length != 0) {
+		int one_more = 0;
+
+		if (usb_pipecontrol(urb->pipe)) {
+			one_more = 1;
+			if (packet_type == IN_PID)
+				packet_type = OUT_PID;
+			else
+				packet_type = IN_PID;
+		} else if (usb_pipebulk(urb->pipe)
+				&& (urb->transfer_flags & URB_ZERO_PACKET)
+				&& !(urb->transfer_buffer_length %
+							maxpacketsize)) {
+			one_more = 1;
+		}
+		if (one_more) {
+			qtd = qtd_alloc(flags, urb, packet_type);
+			if (!qtd)
+				goto cleanup;
+
+			/* never any data in such packets */
+			qtd_fill(qtd, NULL, 0);
+			list_add_tail(&qtd->qtd_list, head);
+		}
+	}
+
+	return;
+
+cleanup:
+	qtd_list_free(head);
+}
+
+static void vega_stop(struct usb_hcd *hcd)
+{
+	dev_err(hcd->self.controller, "<***********************vega_stop***********************>\n");
+	
+	
+}
+
+static void vega_shutdown(struct usb_hcd *hcd)
+{
+	dev_err(hcd->self.controller, "<***********************vega_shutdown***********************>\n");
+	
+	
+}
+
+
+
+static int vega_urb_enqueue(struct usb_hcd *hcd, struct urb *urb,
+		gfp_t mem_flags)
+{
+	struct vega_hcd *priv = hcd_to_priv(hcd);
+	struct list_head *ep_queue;
+	struct vega_qh *qh, *qhit;
+	unsigned long spinflags;
+	LIST_HEAD(new_qtds);
+	int retval;
+	int qh_in_queue;
+	
+	//pr_err("vega_urb_enqueue\n");
+	
+	vega_probe_dbg(hcd->self.controller, "<***********************vega_urb_enqueue***********************>\n");
+
+	vega_dbg2(hcd->self.controller,"urb->pipe : %x\n",urb->pipe);
+
+	switch (usb_pipetype(urb->pipe)) {
+	case PIPE_CONTROL:
+		ep_queue = &priv->qh_list[QH_CONTROL];
+		vega_dbg2(hcd->self.controller,"PIPE_CONTROL\n");
+		break;
+	case PIPE_BULK:
+		ep_queue = &priv->qh_list[QH_BULK];
+		vega_dbg2(hcd->self.controller,"PIPE_BULK\n");
+		break;
+	case PIPE_INTERRUPT:
+		if (urb->interval < 0)
+			return -EINVAL;
+		/* FIXME: Check bandwidth  */
+		ep_queue = &priv->qh_list[QH_INTERRUPT];
+		vega_dbg1(hcd->self.controller,"PIPE_INTERRUPT\n");
+		break;
+	case PIPE_ISOCHRONOUS:		
+		vega_dbg1(hcd->self.controller,"PIPE_ISOCHRONOUS\n");		
+		if (urb->interval < 0)
+			return -EINVAL;
+		/* FIXME: Check bandwidth  */
+		ep_queue = &priv->qh_list[QH_ISOCHRONOUS];			
+		break;
+	default:
+		vega_dbg1(hcd->self.controller, "%s: unknown pipe type\n",
+							__func__);
+		vega_dbg1(hcd->self.controller,"unknown pipe type\n");						
+		return -EPIPE;
+	}
+
+	if (usb_pipein(urb->pipe))
+		urb->actual_length = 0;
+
+	packetize_urb(hcd, urb, &new_qtds, mem_flags);
+	if (list_empty(&new_qtds))
+		return -ENOMEM;
+
+	retval = 0;
+	spin_lock_irqsave(&priv->lock, spinflags);
+
+	if (!test_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags)) {
+		retval = -ESHUTDOWN;
+		qtd_list_free(&new_qtds);
+		goto out;
+	}
+	retval = usb_hcd_link_urb_to_ep(hcd, urb);
+	if (retval) {
+		qtd_list_free(&new_qtds);
+		goto out;
+	}
+
+	qh = urb->ep->hcpriv;
+	if (qh) {
+		qh_in_queue = 0;
+		list_for_each_entry(qhit, ep_queue, qh_list) {
+			if (qhit == qh) {
+				qh_in_queue = 1;
+				break;
+			}
+		}
+		if (!qh_in_queue)
+			list_add_tail(&qh->qh_list, ep_queue);
+	} else {
+		qh = qh_alloc(GFP_ATOMIC);
+		if (!qh) {
+			retval = -ENOMEM;
+			usb_hcd_unlink_urb_from_ep(hcd, urb);
+			qtd_list_free(&new_qtds);
+			goto out;
+		}
+		list_add_tail(&qh->qh_list, ep_queue);
+		urb->ep->hcpriv = qh;
+	}
+
+	list_splice_tail(&new_qtds, &qh->qtd_list);
+	schedule_ptds(hcd);
+
+	int imask = vega_read32(hcd->regs, HC_INTERRUPT_ENABLE);
+	//pr_err("HC_INTERRUPT_ENABLE >>>>> %x \n",imask);
+
+
+	//vega_dbg1(hcd->self.controller,"priv->int_done_map %x >>>>>\n",	vega_read32(hcd->regs, HC_ATL_PTD_DONEMAP_REG));
+
+	vega_dbg1(hcd->self.controller,"vega_urb_enqueue OVER %x\n",retval);
+	/*	errata2_timer_hcd = hcd;
+		timer_setup(&errata2_timer, errata2_function, 0);
+		errata2_timer.expires = jiffies + msecs_to_jiffies(SLOT_CHECK_PERIOD);
+		add_timer(&errata2_timer);*/
+
+out:
+	spin_unlock_irqrestore(&priv->lock, spinflags);
+	return retval;
+
+}
+
+
+static void kill_transfer(struct usb_hcd *hcd, struct urb *urb,
+		struct vega_qh *qh)
+{
+	struct vega_hcd *priv = hcd_to_priv(hcd);
+	int skip_map;
+
+		vega_init_dbg("kill_transfer \n");
+
+
+	WARN_ON(qh->slot == -1);
+
+	/* We need to forcefully reclaim the slot since some transfers never
+	   return, e.g. interrupt transfers and NAKed bulk transfers. */
+	if (usb_pipecontrol(urb->pipe) || usb_pipebulk(urb->pipe)) {
+		skip_map = atl_skipmap_global; //vega_read32(hcd->regs, HC_ATL_PTD_SKIPMAP_REG);
+		skip_map |= (1 << qh->slot);
+		atl_skipmap_global=skip_map;
+		vega_write32(hcd->regs, HC_ATL_PTD_SKIPMAP_REG, skip_map);
+		priv->atl_slots[qh->slot].qh = NULL;
+		priv->atl_slots[qh->slot].qtd = NULL;
+	} 
+	else if (usb_pipeisoc(urb->pipe))
+	{
+		skip_map = iso_skipmap_global; //vega_read32(hcd->regs, HC_INT_PTD_SKIPMAP_REG);
+		skip_map |= (1 << qh->slot);
+		iso_skipmap_global=skip_map;
+		vega_write32(hcd->regs, HC_ISO_PTD_SKIPMAP_REG, skip_map);
+		priv->iso_slots[qh->slot].qh = NULL;
+		priv->iso_slots[qh->slot].qtd = NULL;
+	}
+	else {
+		skip_map = int_skipmap_global; //vega_read32(hcd->regs, HC_INT_PTD_SKIPMAP_REG);
+		skip_map |= (1 << qh->slot);
+		int_skipmap_global=skip_map;
+		vega_write32(hcd->regs, HC_INT_PTD_SKIPMAP_REG, skip_map);
+		priv->int_slots[qh->slot].qh = NULL;
+		priv->int_slots[qh->slot].qtd = NULL;
+	}
+
+	qh->slot = -1;
+}
+
+/*
+ * Retire the qtds beginning at 'qtd' and belonging all to the same urb, killing
+ * any active transfer belonging to the urb in the process.
+ */
+static void dequeue_urb_from_qtd(struct usb_hcd *hcd, struct vega_qh *qh,
+						struct vega_qtd *qtd)
+{
+	struct urb *urb;
+	int urb_was_running;
+
+	urb = qtd->urb;
+	urb_was_running = 0;
+	list_for_each_entry_from(qtd, &qh->qtd_list, qtd_list) {
+		if (qtd->urb != urb)
+			break;
+
+		if (qtd->status >= QTD_XFER_STARTED)
+			urb_was_running = 1;
+		if (last_qtd_of_urb(qtd, qh) &&
+					(qtd->status >= QTD_XFER_COMPLETE))
+			urb_was_running = 0;
+
+		if (qtd->status == QTD_XFER_STARTED)
+			kill_transfer(hcd, urb, qh);
+		qtd->status = QTD_RETIRE;
+	}
+
+	if(vega_hub_speed == HUB_SPEED_HIGH) {
+		if ((urb->dev->speed != USB_SPEED_HIGH) && urb_was_running) {
+			qh->tt_buffer_dirty = 1;
+			
+				if (usb_hub_clear_tt_buffer(urb))
+					/* Clear failed; let's hope things work anyway */
+					qh->tt_buffer_dirty = 0;
+		}
+		
+	}
+
+	// if ((urb->dev->speed != USB_SPEED_HIGH) && urb_was_running) {
+	// 	qh->tt_buffer_dirty = 1;
+	// 	//pr_err("#####################clear tt\n");
+	// 	if(vega_hub_speed == HUB_SPEED_HIGH) {
+	// 		if (usb_hub_clear_tt_buffer(urb))
+	// 			/* Clear failed; let's hope things work anyway */
+	// 			qh->tt_buffer_dirty = 0;
+	// 	}
+	// }
+}
+
+static int vega_urb_dequeue(struct usb_hcd *hcd, struct urb *urb,
+		int status)
+{
+	struct vega_hcd *priv = hcd_to_priv(hcd);
+	unsigned long spinflags;
+	struct vega_qh *qh;
+	struct vega_qtd *qtd;
+	int retval = 0;
+
+	vega_probe_dbg(hcd->self.controller, "<***********************vega_urb_dequeue***********************>\n");
+	//pr_err("vega_urb_dequeue schedule_ptds\n");
+	
+	spin_lock_irqsave(&priv->lock, spinflags);
+	retval = usb_hcd_check_unlink_urb(hcd, urb, status);
+	if (retval)
+		goto out;
+
+	qh = urb->ep->hcpriv;
+	if (!qh) {
+		retval = -EINVAL;
+		goto out;
+	}
+
+	list_for_each_entry(qtd, &qh->qtd_list, qtd_list)
+		if (qtd->urb == urb) {
+			dequeue_urb_from_qtd(hcd, qh, qtd);
+			list_move(&qtd->qtd_list, &qh->qtd_list);
+			break;
+		}
+
+	urb->status = status;
+
+	
+	schedule_ptds(hcd);
+	
+	//pr_err("vega_urb_dequeue\n");
+	vega_dbg1(hcd->self.controller, "<***********************vega_urb_dequeue OVER %x***********************>\n",retval);
+
+
+out:
+	spin_unlock_irqrestore(&priv->lock, spinflags);
+	return retval;
+}
+
+static void vega_endpoint_disable(struct usb_hcd *hcd,
+		struct usb_host_endpoint *ep)
+{
+	
+	struct vega_hcd *priv = hcd_to_priv(hcd);
+	unsigned long spinflags;
+	struct vega_qh *qh, *qh_iter;
+	int i;
+	vega_probe_dbg(hcd->self.controller, "<***********************vega_endpoint_disable***********************>\n");
+	spin_lock_irqsave(&priv->lock, spinflags);
+
+	qh = ep->hcpriv;
+	if (!qh)
+		goto out;
+		
+	schedule_ptds(hcd);	
+
+	WARN_ON(!list_empty(&qh->qtd_list));
+
+	for (i = 0; i < QH_END; i++)
+		list_for_each_entry(qh_iter, &priv->qh_list[i], qh_list)
+			if (qh_iter == qh) {
+				list_del(&qh_iter->qh_list);
+				i = QH_END;
+				break;
+			}
+	qh_free(qh);
+	ep->hcpriv = NULL;
+	
+
+	//pr_err("vega_endpoint_disable schedule_ptds\n");
+
+
+out:
+
+	//pr_err("vega_endpoint_disable\n");
+	
+	
+	spin_unlock_irqrestore(&priv->lock, spinflags);
+	vega_dbg1(hcd->self.controller, "<***********************vega_endpoint_disable over***********************>\n");
+
+}
+
+static int vega_get_frame(struct usb_hcd *hcd)
+{
+	struct vega_hcd *priv = hcd_to_priv(hcd);
+	u32 fr;
+
+	dev_err(hcd->self.controller, "<***********************vega_get_frame***********************>\n");
+
+	fr = vega_read32(hcd->regs, HC_FRINDEX);
+	return (fr >> 3) % priv->periodic_size;
+}
+
+static void vega_endpoint_reset(struct usb_hcd *hcd, struct usb_host_endpoint *ep){
+
+	dev_err(hcd->self.controller, "<***********************vega_endpoint_reset***********************>\n");
+}
+
+
+
+static int vega_hub_status_data(struct usb_hcd *hcd, char *buf)
+{
+	struct vega_hcd *priv = hcd_to_priv(hcd);
+	u32 temp, status = 0;
+	u32 mask;
+	int retval = 1;
+	unsigned long flags;
+	
+	//pr_err("vega_hub_status_data\n");
+	/* if !PM, root hub timers won't get shut down ... */
+	/*if (!HC_IS_RUNNING(hcd->state))
+		return 0;*/
+	//mask = PORT_CSC;
+
+
+	/*temp = vega_read32(hcd->regs, HC_PORTSC1);
+
+	if (temp & PORT_OWNER) {
+		if (temp & PORT_CSC) {
+			temp &= ~PORT_CSC;
+			vega_write32(hcd->regs, HC_PORTSC1, temp);
+			vega_dbg4(hcd->self.controller, "<***********************HC_PORTSC1 write %x***********************>\n",temp);
+
+			goto done;
+		}
+	}*/
+
+	/*
+	 * Return status information even for ports with OWNER set.
+	 * Otherwise hub_wq wouldn't see the disconnect event when a
+	 * high-speed device is switched over to the companion
+	 * controller by the user.
+	 */
+
+	/*if ((temp & mask) != 0
+			|| ((temp & PORT_RESUME) != 0
+				&& time_after_eq(jiffies,
+					priv->reset_done))) {*/
+
+	spin_lock_irqsave(&priv->lock, flags);
+	/* init status to no-changes */
+	buf[0] = 0;
+	if(port_change_flag)	
+		buf [0] |= (1 << 1);
+		//status = STS_PCD;
+
+	spin_unlock_irqrestore(&priv->lock, flags);
+	//pr_err("<***********************vega_hub_status_data over status %x, retval %x***********************>\n",status,retval);
+	if(port_change_flag){
+		port_change_flag = 0;
+		return 1;
+	} else
+		return 0;
+}
+
+static void vega_hub_descriptor(struct vega_hcd *priv,
+		struct usb_hub_descriptor *desc)
+{
+	int ports = 1;// HCS_N_PORTS(priv->hcs_params);
+	u16 temp;
+
+	desc->bDescLength = 7 + 2 * (1 + (ports / 8));
+	desc->bDescriptorType = USB_DT_HUB;
+	desc->bNbrPorts = ports;
+
+	/* priv 1.0, 2.3.9 says 20ms max */
+	desc->bPwrOn2PwrGood = 10;
+	desc->bHubContrCurrent = 0;
+
+	/* no power switching */
+	temp = HUB_CHAR_NO_LPSM;
+	/* No Over-current Protection support */
+	temp = HUB_CHAR_NO_OCPM;
+	if(vega_hub_speed == HUB_SPEED_HIGH)
+		temp |= USB_HUB_PR_HS_MULTI_TT; //FIXME 
+	desc->wHubCharacteristics = cpu_to_le16(temp);
+	printk("desc->wHubCharacteristics=%x\n", desc->wHubCharacteristics);
+
+	/* ports removable, and usb 1.0 legacy PortPwrCtrlMask */
+	memset(&desc->u.hs.DeviceRemovable[0], 0, (1 + (ports / 8)));
+
+}
+
+#define	PORT_WAKE_BITS	(PORT_WKOC_E|PORT_WKDISC_E|PORT_WKCONN_E)
+
+static int check_reset_complete(struct usb_hcd *hcd, int index,
+		int port_status)
+{
+	//if (!(port_status & PORT_CONNECT))
+	///	return port_status;
+
+	int ret = handshake_hcd(hcd, HC_PORTSC1 , PORT_PE, PORT_PE , 100*1000);
+	if(ret != 0) {
+		pr_err("error!!!!!port not enabled\n");
+		/* if reset finished and it's still not enabled -- handoff */
+		return 0;
+	}
+
+	port_status = vega_read32(hcd->regs, HC_PORTSC1);
+
+	vega_write32(hcd->regs, HC_USBCMD, CMD_RUN); //Start to send SOF
+
+	vega_dbg4(hcd->self.controller, "check_reset_complete, HC_USBCMD %x +++++ \n",CMD_RUN);
+
+
+	if (!(port_status & PORT_HIGH_SPEED)) {
+	
+		dev_info(hcd->self.controller,
+					"port %d full speed --> companion\n",
+					index + 1);
+		vega_hub_speed = HUB_SPEED_FULL;
+		//port_status |= PORT_OWNER;
+		//port_status &= ~PORT_RWC_BITS;
+		//vega_write32(hcd->regs, HC_PORTSC1, port_status);
+		vega_dbg4(hcd->self.controller, "check_reset_complete, HC_PORTSC1 Wr %x +++++ \n",port_status);
+	} else {
+		dev_info(hcd->self.controller, "port %d high speed\n",
+								index + 1);
+		vega_hub_speed = HUB_SPEED_HIGH;
+	}
+
+	vega_init_dbg("check_reset_complete over\n");
+
+
+	return port_status;
+}
+
+int port_power_flag = 1;
+
+static int vega_hub_control(struct usb_hcd *hcd, u16 typeReq,
+		u16 wValue, u16 wIndex, char *buf, u16 wLength)
+{
+	
+	struct vega_hcd *priv = hcd_to_priv(hcd);
+	int ports = HCS_N_PORTS(priv->hcs_params);
+	u32 temp;
+	unsigned long flags;
+	int retval = 0;
+	int i=0;
+	unsigned selector;
+	u32 port_status;	
+	static u32 port_change = 0;	
+
+
+	////vega_hub_cotrol_dbg1(hcd->self.controller, "<***********************vega_hub_control wValue =%x, wIndex =%x, wLength =%x, typeReqn =%x\n", wValue, wIndex, wLength, typeReq);  /////cdac
+
+	/*
+	 * FIXME:  support SetPortFeatures USB_PORT_FEAT_INDICATOR.
+	 * HCS_INDICATOR may say we can change LEDs to off/amber/green.
+	 * (track current state ourselves) ... blink for diagnostics,
+	 * power, "this is the one", etc.  EHCI spec supports this.
+	 */
+
+	spin_lock_irqsave(&priv->lock, flags);
+	switch (typeReq) {
+	case ClearHubFeature:
+		dev_err(hcd->self.controller, "ClearHubFeature +++++ \n");
+		switch (wValue) {
+		case C_HUB_LOCAL_POWER:
+		case C_HUB_OVER_CURRENT:
+			/* no hub-wide feature/status flags */
+			break;
+		default:
+			goto error;
+		}
+		break;
+	case ClearPortFeature:
+		vega_hub_cotrol_dbg(hcd->self.controller, "ClearPortFeature +++++ \n");
+		if (!wIndex || wIndex > ports)
+			goto error;
+		wIndex--;
+		temp = vega_read32(hcd->regs, HC_PORTSC1);
+		vega_hub_cotrol_dbg(hcd->self.controller, "hub control HC_PORTSC1 read :%x, \n",temp);
+		/*
+		 * Even if OWNER is set, so the port is owned by the
+		 * companion controller, hub_wq needs to be able to clear
+		 * the port-change status bits (especially
+		 * USB_PORT_STAT_C_CONNECTION).
+		 */
+		vega_hub_cotrol_dbg(hcd->self.controller, "ClearPortFeature +++++, %d \n",wValue);
+		switch (wValue) {
+		case USB_PORT_FEAT_ENABLE:
+			temp = vega_read32(hcd->regs, HC_PORTSC1);
+			vega_hub_cotrol_dbg1(hcd->self.controller, "HC_PORTSC1 write :%x, \n",(temp & ~PORT_PE));
+			vega_write32(hcd->regs, HC_PORTSC1, (temp & ~PORT_PE));
+			break;
+		case USB_PORT_FEAT_C_ENABLE:
+			vega_hub_cotrol_dbg1(hcd->self.controller,"+++++++CL+++++++++USB_PORT_FEAT_C_ENABLE++++++++++++++++++++");
+			port_change &= (~USB_PORT_STAT_C_ENABLE);
+			/* XXX error? */
+			break;
+		case USB_PORT_FEAT_SUSPEND:
+			dev_err(hcd->self.controller,"++++++++++CL++++++USB_PORT_FEAT_SUSPEND++++++++++++++++++++");
+			if (temp & PORT_RESET)
+				goto error;
+
+			if (temp & PORT_SUSPEND) {
+				if ((temp & PORT_PE) == 0)
+					goto error;
+				/* resume signaling for 20 msec */
+				vega_write32(hcd->regs, HC_PORTSC1,
+							temp | PORT_RESUME);
+				vega_hub_cotrol_dbg(hcd->self.controller, "HC_PORTSC1 write :%x, \n",(temp | PORT_RESUME));
+			
+				priv->reset_done = jiffies +
+					msecs_to_jiffies(USB_RESUME_TIMEOUT);
+			}
+			break;
+		case USB_PORT_FEAT_C_SUSPEND:
+			dev_err(hcd->self.controller,"++++++++++CL++++++USB_PORT_FEAT_C_SUSPEND++++++++++++++++++++");
+			port_change &= (~USB_PORT_STAT_C_SUSPEND);
+			break;
+		case USB_PORT_FEAT_POWER:
+			vega_hub_cotrol_dbg1(hcd->self.controller,"++++++CL++++++++++USB_PORT_FEAT_POWER++++++++++++++++++++");
+			port_power_flag = 0;
+			// &= ~(USB_PORT_STAT_C_ENABLE | USB_PORT_STAT_C_SUSPEND | USB_PORT_STAT_C_CONNECTION | USB_PORT_STAT_C_RESET);
+			//if (HCS_PPC(priv->hcs_params))
+			//	vega_write32(hcd->regs, HC_PORTSC1,	temp & ~PORT_POWER);
+			break;
+		case USB_PORT_FEAT_C_CONNECTION:
+			vega_hub_cotrol_dbg1(hcd->self.controller,"+++++CL+++++++++++USB_PORT_FEAT_C_CONNECTION++++++++++++++++++++");
+			port_change &= (~USB_PORT_STAT_C_CONNECTION);
+			break;
+		case USB_PORT_FEAT_C_OVER_CURRENT:
+			dev_err(hcd->self.controller,"++++++CL++++++++++USB_PORT_FEAT_C_OVER_CURRENT++++++++++++++++++++");
+			/* XXX error ?*/
+			break;
+		case USB_PORT_FEAT_C_RESET:
+			vega_hub_cotrol_dbg1(hcd->self.controller,"++++++CL++++++++++USB_PORT_FEAT_C_RESET++++++++++++++++++++");
+			port_change &= (~USB_PORT_STAT_C_RESET);
+			/* GetPortStatus clears reset */
+			break;
+		default:
+			goto error;
+		}
+		//vega_read32(hcd->regs, HC_USBCMD);
+		break;
+	case GetHubDescriptor:
+		vega_hub_cotrol_dbg(hcd->self.controller, "GetHubDescriptor +++++ \n");
+		vega_hub_descriptor(priv, (struct usb_hub_descriptor *) buf);
+		break;
+	case GetHubStatus:
+		vega_hub_cotrol_dbg(hcd->self.controller, "GetHubStatus +++++ \n");
+		/* no hub-wide feature/status flags */
+		memset(buf, 0, 4);
+		break;
+	case GetPortStatus:			
+		if (!wIndex || wIndex > ports)
+			goto error;
+		wIndex--;
+		port_status = 0;
+		////vega_hub_cotrol_dbg(hcd->self.controller, "GetPortStatus %x +++++ \n",temp); ////cdac
+		/* wPortChange bits */
+		if (device_disconnected){
+			port_change |= USB_PORT_STAT_C_CONNECTION; //set connection change bit
+			device_disconnected = 0;	
+			vega_write32(hcd->regs, HC_USBCMD, 0);//Set Run/Stop bit zero
+			temp = vega_read32(hcd->regs, HC_PORTSC1);
+			temp &= ~PORT_PE;
+			vega_write32(hcd->regs, HC_PORTSC1, temp);
+		}
+		else if (device_connected){
+			port_change |= USB_PORT_STAT_C_CONNECTION; //set connection change bit
+			device_connected = 0;
+		} else {
+			temp = handshake_hcd(hcd, HC_PORTSC1, PORT_CONNECT, PORT_CONNECT , 50*1000); //polling
+		}
+
+		temp = vega_read32(hcd->regs, HC_PORTSC1);
+		/* whoever resumes must GetPortStatus to complete it!! */
+		if (temp & PORT_RESUME) {
+			dev_err(hcd->self.controller, "Port resume should be skipped.\n");
+
+			/* Remote Wakeup received? */
+			if (!priv->reset_done) {
+				/* resume signaling for 20 msec */
+				priv->reset_done = jiffies
+						+ msecs_to_jiffies(20);
+				/* check the port again */
+				mod_timer(&hcd->rh_timer, priv->reset_done);
+			}
+
+			/* resume completed? */
+			else if (time_after_eq(jiffies,
+					priv->reset_done)) {
+				port_change |= USB_PORT_STAT_C_SUSPEND;
+				priv->reset_done = 0;
+
+				/* stop resume signaling */
+				temp = vega_read32(hcd->regs, HC_PORTSC1);
+				vega_write32(hcd->regs, HC_PORTSC1,
+					temp & ~(PORT_RESUME));
+
+				retval = handshake_hcd(hcd, HC_PORTSC1,
+					   PORT_RESUME, 0, 2000 /* 2msec */);
+				vega_hub_cotrol_dbg(hcd->self.controller, "HC_PORTSC1 read :%x, \n",(vega_read32(hcd->regs, HC_PORTSC1)));
+
+				if (retval != 0) {
+					vega_hub_cotrol_dbg(hcd->self.controller,
+						"port %d resume error %d\n",
+						wIndex + 1, retval);
+					goto error;
+				}
+				temp &= ~(PORT_SUSPEND|PORT_RESUME|(3<<10));
+			}
+		}
+
+		/* whoever resets must GetPortStatus to complete it!! */
+		if ((temp & PORT_RESET)
+				&& time_after_eq(jiffies,
+					priv->reset_done)) {
+			vega_hub_cotrol_dbg(hcd->self.controller, "PORT_RESET\n");		
+			priv->reset_done = 0;
+
+			/* force reset to complete */
+			temp = vega_read32(hcd->regs, HC_PORTSC1);
+			vega_write32(hcd->regs, HC_PORTSC1, temp & ~PORT_RESET);
+			port_change |= USB_PORT_STAT_C_RESET;
+			vega_dbg4(hcd->self.controller, "HC_PORTSC1 wr :%x, \n",(temp & ~PORT_RESET));
+
+			/*retval=0;		
+			if (retval != 0) {
+				vega_hub_cotrol_dbg(hcd->self.controller, "port %d reset error %d\n",
+						wIndex + 1, retval);
+				goto error;
+			}*/
+
+			/* see what we found out */
+			temp = check_reset_complete(hcd, wIndex, vega_read32(hcd->regs, HC_PORTSC1));
+			
+		}
+		/*
+		 * Even if OWNER is set, there's no harm letting hub_wq
+		 * see the wPortStatus values (they should all be 0 except
+		 * for PORT_POWER anyway).
+		 */
+
+		/*if (temp & PORT_OWNER)
+			vega_hub_cotrol_dbg(hcd->self.controller, "PORT_OWNER is set\n");*/
+
+		temp = vega_read32(hcd->regs, HC_PORTSC1);
+		if (temp & PORT_CONNECT) {
+			/////vega_hub_cotrol_dbg(hcd->self.controller, "++++++++++++++++++++PORT_CONNECT \n"); /////cdac
+			port_status |= USB_PORT_STAT_CONNECTION;
+			/* status may be from integrated TT */
+		}
+		if (temp & PORT_PE)
+			port_status |= USB_PORT_STAT_ENABLE;
+		if (temp & (PORT_SUSPEND|PORT_RESUME))
+			port_status |= USB_PORT_STAT_SUSPEND;
+		if (temp & PORT_RESET)
+			port_status |= USB_PORT_STAT_RESET;
+		if (port_power_flag)
+			port_status |= USB_PORT_STAT_POWER;
+		if(temp & PORT_HIGH_SPEED)
+			port_status |= USB_PORT_STAT_HIGH_SPEED;
+		if(temp & PORT_LOW_SPEED)
+			port_status |= USB_PORT_STAT_LOW_SPEED;
+
+		////vega_hub_cotrol_dbg(hcd->self.controller, "**********************port status+change %x  \n", (port_status | (port_change << 16))); ////cdac
+
+		put_unaligned(cpu_to_le32((port_status | (port_change << 16))), (__le32 *) buf);
+		break;
+	case SetHubFeature:
+		dev_err(hcd->self.controller,"++++++++++++++++SetHubFeature++++++++++++++++++++");
+		switch (wValue) {
+		case C_HUB_LOCAL_POWER:
+		case C_HUB_OVER_CURRENT:
+			/* no hub-wide feature/status flags */
+			break;
+		default:
+			goto error;
+		}
+		break;
+	case SetPortFeature:
+		//dev_err(hcd->self.controller, "SetPortFeature +++++ \n");
+		selector = wIndex >> 8;
+		wIndex &= 0xff;
+		if (!wIndex || wIndex > ports)
+			goto error;
+		wIndex--;
+		temp = vega_read32(hcd->regs, HC_PORTSC1);
+		/*if (temp & PORT_OWNER)
+			break;*/
+
+/*		temp &= ~PORT_RWC_BITS; */
+		/////vega_hub_cotrol_dbg(hcd->self.controller, "SetPortFeature +++++ switch : %d \n",wValue);  ////cdac
+		switch (wValue) {
+		
+		case USB_PORT_FEAT_ENABLE:
+			dev_err(hcd->self.controller,"++++++++++set++++++++++++++++USB_PORT_FEAT_ENABLE \n");
+			break;
+
+		case USB_PORT_FEAT_SUSPEND:
+			dev_err(hcd->self.controller,"+++++++++++set+++++++++++++++USB_PORT_FEAT_SUSPEND \n");
+			if ((temp & PORT_PE) == 0
+					|| (temp & PORT_RESET) != 0)
+				goto error;
+			vega_write32(hcd->regs, HC_PORTSC1, temp | PORT_SUSPEND);
+			break;
+		case USB_PORT_FEAT_POWER:
+			vega_hub_cotrol_dbg1(hcd->self.controller,"+++++++++++set+++++++++++++++USB_PORT_FEAT_POWER \n");
+			port_power_flag = 1;
+			//if (HCS_PPC(priv->hcs_params))
+				//vega_write32(hcd->regs, HC_PORTSC1,	temp | PORT_POWER);
+			break;
+		case USB_PORT_FEAT_RESET:
+		
+		vega_hub_cotrol_dbg(hcd->self.controller,"+++++++++++set+++++++++++++++USB_PORT_FEAT_RESET \n");
+				if (temp & PORT_RESUME)
+				goto error;
+			/* line status bits may report this as low speed,
+			 * which can be fine if this root hub has a
+			 * transaction translator built in.
+			 */
+			/*if ((temp & (PORT_PE|PORT_CONNECT)) == PORT_CONNECT
+					&& PORT_USB11(temp)) {
+				temp |= PORT_OWNER;
+			} else {*/
+
+				vega_write32(hcd->regs, HC_USBCMD, 0);//Set Run/Stop bit zero
+				temp = vega_read32(hcd->regs, HC_PORTSC1);
+				temp |= PORT_RESET;
+				temp &= ~PORT_PE;
+				
+				//pr_err("PORT_RESET\n");
+
+				/*
+				 * caller must wait, then call GetPortStatus
+				 * usb 2.0 spec says 50 ms resets on root
+				 */
+				priv->reset_done = jiffies +
+					msecs_to_jiffies(100);
+			//}
+				vega_write32(hcd->regs, HC_PORTSC1, temp);
+			break;
+		default:
+			goto error;
+		}
+		break;
+
+	default:
+error:
+		/* "stall" on error */
+		vega_dbg(hcd->self.controller, "error \n");
+		retval = -EPIPE;
+	}
+
+	/////vega_hub_cotrol_dbg(hcd->self.controller, "vega_hub_control over %x\n",retval); ////cdac
+
+	spin_unlock_irqrestore(&priv->lock, flags);
+	return retval;
+	
+}
+
+static void vega_clear_tt_buffer_complete(struct usb_hcd *hcd,
+						struct usb_host_endpoint *ep)
+{
+	//dev_err(hcd->self.controller, "<***********************vega_clear_tt_buffer_complete***********************>\n");
+	
+	
+	struct vega_hcd *priv = hcd_to_priv(hcd);
+	struct vega_qh *qh = ep->hcpriv;
+	unsigned long spinflags;
+
+	if (!qh)
+		return;
+
+	spin_lock_irqsave(&priv->lock, spinflags);
+	qh->tt_buffer_dirty = 0;
+	
+	//pr_err("vega_clear_tt_buffer_complete schedule_ptds\n");
+	schedule_ptds(hcd);
+	spin_unlock_irqrestore(&priv->lock, spinflags);
+	
+}
+
+static const struct hc_driver vega_hc_driver = {
+	.description		= "VEGA HCD",
+	.product_desc		= "VEGA USB Host Cotroller Driver",
+	.hcd_priv_size		= sizeof(struct vega_hcd),
+
+	/*
+	 * generic hardware linkage
+	 */
+	.irq			= vega_irq,
+	.flags			= HCD_MEMORY | HCD_USB2 ,
+
+	/*
+	 * basic lifecycle operations
+	 */
+	.reset			= vega_setup,
+	.start			= vega_run,
+	.stop			= vega_stop,
+	.shutdown		= vega_shutdown,
+
+	/*
+	 * managing i/o requests and associated device resources
+	 */
+	.urb_enqueue		= vega_urb_enqueue,
+	.urb_dequeue		= vega_urb_dequeue,
+	.endpoint_disable	= vega_endpoint_disable,
+	//.endpoint_reset		= vega_endpoint_reset,
+
+	/*
+	 * scheduling support
+	 */
+	.get_frame_number	= vega_get_frame,
+
+	/*
+	 * root hub support
+	 */
+	.hub_status_data	= vega_hub_status_data,
+	.hub_control		= vega_hub_control,
+
+	.clear_tt_buffer_complete = vega_clear_tt_buffer_complete,
+};
+
+int vega_hcd_register(struct vega_hcd *priv, void __iomem *regs,
+			 struct resource *mem, int irq, unsigned long irqflags,
+			 struct device *dev)
+{
+	struct usb_hcd *hcd;
+	int ret;
+
+	hcd = usb_create_hcd(&vega_hc_driver, dev, dev_name(dev));
+	if (!hcd)
+		return -ENOMEM;
+
+	*(struct vega_hcd **)hcd->hcd_priv = priv;
+
+	priv->hcd = hcd;
+
+	init_memory(priv);
+
+	hcd->irq = irq;
+	hcd->regs = regs;
+	hcd->rsrc_start = mem->start;
+	hcd->rsrc_len = resource_size(mem);
+
+	hcd->has_tt = 1;
+	
+	/* This driver doesn't support wakeup requests */
+	hcd->cant_recv_wakeups = 1;
+
+	ret = usb_add_hcd(hcd, irq, irqflags);
+	if (ret)
+		goto error;
+
+	device_wakeup_enable(hcd->self.controller);
+
+	return 0;
+
+error:
+	usb_put_hcd(hcd);
+	return ret;
+}
+
+////
+
+
+int __init vega_init_kmem_once(void)
+{
+	urb_listitem_cachep = kmem_cache_create("vega_urb_listitem",
+			sizeof(struct urb_listitem), 0, SLAB_TEMPORARY |
+			SLAB_MEM_SPREAD, NULL);
+
+	if (!urb_listitem_cachep)
+		return -ENOMEM;
+
+	qtd_cachep = kmem_cache_create("vega_qtd",
+			sizeof(struct vega_qtd), 0, SLAB_TEMPORARY |
+			SLAB_MEM_SPREAD, NULL);
+
+	if (!qtd_cachep)
+		return -ENOMEM;
+
+	qh_cachep = kmem_cache_create("vega_qh", sizeof(struct vega_qh),
+			0, SLAB_TEMPORARY | SLAB_MEM_SPREAD, NULL);
+
+	if (!qh_cachep) {
+		kmem_cache_destroy(qtd_cachep);
+		return -ENOMEM;
+	}
+
+	return 0;
+}
+
+void vega_deinit_kmem_cache(void)
+{
+	kmem_cache_destroy(qtd_cachep);
+	kmem_cache_destroy(qh_cachep);
+	kmem_cache_destroy(urb_listitem_cachep);
+}
+
+/**
+ * vega_hcd_vega_of_probe - Probe method for the USB host controller
+ * @op:		pointer to the platform_device bound to the host controller
+ *
+ * This function requests resources and sets up appropriate properties for the
+ * host controller. Because the vega USB host controller can be configured
+ * as HS only or HS/FS only, it checks the configuration in the device tree
+ * entry, and sets an appropriate value for hcd->has_tt.
+ */
+
+////
+
+/**
+ * vega_hcd_vega_of_remove - shutdown hcd and release resources
+ * @op:		pointer to platform_device structure that is to be removed
+ *
+ * Remove the hcd structure, and release resources that has been requested
+ * during probe.
+ */
+
+////
+
+
+/*
+static const struct of_device_id vega_hcd_of_match[] = {
+		{.compatible = "cdac,vega-usb",},
+	{},
+};
+MODULE_DEVICE_TABLE(of, vega_hcd_of_match);
+
+static struct platform_driver vega_hcd_of_driver = {
+	.probe		= vega_hcd_probe,
+	.remove	= vega_hcd_remove,
+	.shutdown	= usb_hcd_platform_shutdown,
+	.driver = {
+		.name = "vega-usb",
+		.of_match_table = vega_hcd_of_match,
+	},
+};
+
+*/
+
+static int __init vega_init(void)
+{
+	int ret, any_ret = -ENODEV;
+
+	vega_init_kmem_once();
+
+	ret = platform_driver_register(&vega_hcd_of_driver);
+	if (!ret)
+		any_ret = 0;
+
+	if (any_ret)
+		vega_deinit_kmem_cache();
+	return any_ret;
+}
+module_init(vega_init);
+
+static void __exit vega_exit(void)
+{
+	platform_driver_unregister(&vega_hcd_of_driver);
+
+	vega_deinit_kmem_cache();
+}
+module_exit(vega_exit);
diff -Naur linux-5.4.1/drivers/usb/vega/vega-hcd.h linux-5.4.1_modified/drivers/usb/vega/vega-hcd.h
--- linux-5.4.1/drivers/usb/vega/vega-hcd.h	1970-01-01 05:30:00.000000000 +0530
+++ linux-5.4.1_modified/drivers/usb/vega/vega-hcd.h	2025-08-08 10:40:35.458765878 +0530
@@ -0,0 +1,114 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef _VEGA_HCD_H_
+#define _VEGA_HCD_H_
+
+#include <linux/spinlock.h>
+//#include "vega-core.h"
+#include "vega-udc.h"
+
+#define VEGA_FLAG_BUS_WIDTH_16 0x00000002 /* 16-bit data bus width */
+#define VEGA_FLAG_OTG_EN 0x00000004 /* Port 1 supports OTG */
+#define VEGA_FLAG_ANALOG_OC 0x00000008 /* Analog overcurrent */
+#define VEGA_FLAG_DACK_POL_HIGH 0x00000010 /* DACK active high */
+#define VEGA_FLAG_DREQ_POL_HIGH 0x00000020 /* DREQ active high */
+#define VEGA_FLAG_ISP1761 0x00000040 /* Chip is ISP1761 */
+#define VEGA_FLAG_INTR_POL_HIGH 0x00000080 /* Interrupt polarity active high */
+#define VEGA_FLAG_INTR_EDGE_TRIG 0x00000100 /* Interrupt edge triggered */
+
+/* urb state*/
+#define DELETE_URB (0x0008)
+#define NO_TRANSFER_ACTIVE (0xffffffff)
+
+struct vega_qh;
+struct vega_qtd;
+struct resource;
+struct vega_hcd;
+
+/*
+ * 15kb divided in:
+ * - 8 blocks @ 256  bytes
+ * - 5 blocks @ 1024 bytes
+ * -  1 blocks @ 8192 bytes
+ */
+
+#define BLOCK_1_NUM 8
+#define BLOCK_2_NUM 5
+#define BLOCK_3_NUM 1
+
+#define BLOCK_1_SIZE 256
+#define BLOCK_2_SIZE 1024
+#define BLOCK_3_SIZE 8192
+#define BLOCKS (BLOCK_1_NUM + BLOCK_2_NUM + BLOCK_3_NUM)
+#define MAX_PAYLOAD_SIZE BLOCK_3_SIZE
+#define PAYLOAD_AREA_SIZE 0x3C00
+
+#define HUB_SPEED_FULL 0
+#define HUB_SPEED_HIGH 1
+
+struct vega_slotinfo {
+	struct vega_qh *qh;
+	struct vega_qtd *qtd;
+	unsigned long timestamp;
+};
+
+/* chip memory management */
+struct vega_memory_chunk {
+	unsigned int start;
+	unsigned int size;
+	unsigned int free;
+};
+
+enum vega_queue_head_types {
+	QH_CONTROL,
+	QH_BULK,
+	QH_INTERRUPT,
+	QH_ISOCHRONOUS,
+	QH_END
+};
+
+struct vega_hcd {
+	struct usb_hcd *hcd;
+
+	u32 hcs_params;
+	spinlock_t lock;
+	struct vega_slotinfo atl_slots[32];
+	int atl_done_map;
+	struct vega_slotinfo int_slots[32];
+	int int_done_map;
+	struct vega_slotinfo iso_slots[32];
+	int iso_done_map;
+	struct vega_memory_chunk memory_pool[BLOCKS];
+	struct list_head qh_list[QH_END];
+
+	/* periodic schedule support */
+#define DEFAULT_I_TDPS 1024
+	unsigned periodic_size;
+	unsigned i_thresh;
+	unsigned long reset_done;
+	unsigned long next_statechange;
+};
+
+struct device;
+struct gpio_desc;
+
+static void vega_init_core(struct vega_device *vega);
+
+static inline u32 vega_read32(void __iomem *base, u32 reg)
+{
+	return readl(base + reg);
+}
+
+static inline void vega_write32(void __iomem *base, u32 reg, u32 val)
+{
+	writel(val, base + reg);
+}
+
+int vega_hcd_register(struct vega_hcd *priv, void __iomem *regs,
+		      struct resource *mem, int irq, unsigned long irqflags,
+		      struct device *dev);
+void vega_hcd_unregister(struct vega_hcd *priv);
+
+int vega_init_kmem_once(void);
+void vega_deinit_kmem_cache(void);
+
+#endif /* _VEGA_HCD_H_ */
diff -Naur linux-5.4.1/drivers/usb/vega/vega-regs.h linux-5.4.1_modified/drivers/usb/vega/vega-regs.h
--- linux-5.4.1/drivers/usb/vega/vega-regs.h	1970-01-01 05:30:00.000000000 +0530
+++ linux-5.4.1_modified/drivers/usb/vega/vega-regs.h	2025-08-08 10:40:35.458856298 +0530
@@ -0,0 +1,254 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Driver for the NXP ISP1760 chip
+ *
+ * Copyright 2014 Laurent Pinchart
+ * Copyright 2007 Sebastian Siewior
+ *
+ * Contacts:
+ *     Sebastian Siewior <bigeasy@linutronix.de>
+ *     Laurent Pinchart <laurent.pinchart@ideasonboard.com>
+ */
+
+#ifndef _VEGA_REGS_H_
+#define _VEGA_REGS_H_
+
+/* -----------------------------------------------------------------------------
+ * Host Controller
+ */
+
+/* EHCI capability registers */
+#define HC_CAPLENGTH		0x000
+#define HC_LENGTH(p)		(((p) >> 00) & 0x00ff)	/* bits 7:0 */
+#define HC_VERSION(p)		(((p) >> 16) & 0xffff)	/* bits 31:16 */
+
+#define HC_HCSPARAMS		0x004
+#define HCS_INDICATOR(p)	((p) & (1 << 16))	/* true: has port indicators */
+#define HCS_PPC(p)		((p) & (1 << 4))	/* true: port power control */
+#define HCS_N_PORTS(p)		(((p) >> 0) & 0xf)	/* bits 3:0, ports on HC */
+
+#define HC_HCCPARAMS		0x008
+#define HCC_ISOC_CACHE(p)       ((p) & (1 << 7))	/* true: can cache isoc frame */
+#define HCC_ISOC_THRES(p)       (((p) >> 4) & 0x7)	/* bits 6:4, uframes cached */
+
+/* EHCI operational registers */
+#define HC_USBCMD		0x020
+#define CMD_LRESET		(1 << 7)		/* partial reset (no ports, etc) */
+#define CMD_RESET		(1 << 1)		/* reset HC not bus */
+#define CMD_RUN			(1 << 0)		/* start/stop HC */
+
+#define HC_USBSTS		0x024
+#define STS_PCD			(1 << 2)		/* port change detect */
+
+#define HC_FRINDEX		0x02c
+
+#define HC_CONFIGFLAG		0x060
+#define FLAG_CF			(1 << 0)		/* true: we'll support "high speed" */
+
+#define HC_PORTSC1		0x064
+//#define PORT_OWNER		(1 << 13)		/* true: companion hc owns this port */
+#define PORT_POWER		(1 << 12)		/* true: has power (see PPC) */
+//#define PORT_USB11(x)		(((x) & (3 << 10)) == (1 << 10))	/* USB 1.1 device */
+#define PORT_RESET		(1 << 8)		/* reset port */
+#define PORT_SUSPEND		(1 << 7)		/* suspend port */
+#define PORT_RESUME		(1 << 6)		/* resume it */
+#define PORT_PE		(1 << 2)		/* port enable */
+//#define PORT_CSC		(1 << 1)		/* connect status change */
+#define PORT_CONNECT		(1 << 0)		/* device connected */
+//#define PORT_RWC_BITS		(PORT_CSC)
+#define PORT_HIGH_SPEED  	(1 << 3)
+#define PORT_LOW_SPEED  	(1 << 4)
+
+
+#define HC_ISO_PTD_DONEMAP_REG	0x130
+#define HC_ISO_PTD_SKIPMAP_REG	0x134
+#define HC_ISO_PTD_LASTPTD_REG	0x138
+#define HC_INT_PTD_DONEMAP_REG	0x140
+#define HC_INT_PTD_SKIPMAP_REG	0x144
+#define HC_INT_PTD_LASTPTD_REG	0x148
+#define HC_ATL_PTD_DONEMAP_REG	0x150
+#define HC_ATL_PTD_SKIPMAP_REG	0x154
+#define HC_ATL_PTD_LASTPTD_REG	0x158
+
+/* Configuration Register */
+#define HC_HW_MODE_CTRL		0x300
+//#define ALL_ATX_RESET		(1 << 31)
+//#define HW_ANA_DIGI_OC		(1 << 15)
+#define HW_PID_RESET		(1 << 11)
+//#define HW_COMN_IRQ		(1 << 10)
+//#define HW_COMN_DMA		(1 << 9)
+//#define HW_DATA_BUS_32BIT	(1 << 8)
+#define HW_DACK_POL_HIGH	(1 << 6)
+#define HW_DREQ_POL_HIGH	(1 << 5)
+#define HW_INTR_HIGH_ACT	(1 << 2)
+#define HW_INTR_EDGE_TRIG	(1 << 1)
+#define HW_GLOBAL_INTR_EN	(1 << 0)
+
+#define HC_CHIP_ID_REG		0x304
+#define HC_SCRATCH_REG		0x308
+
+#define HC_RESET_REG		0x30c
+#define SW_RESET_RESET_HC	(1 << 1)
+#define SW_RESET_RESET_ALL	(1 << 0)
+
+#define HC_BUFFER_STATUS_REG	0x334
+#define ISO_BUF_FILL		(1 << 2)
+#define INT_BUF_FILL		(1 << 1)
+#define ATL_BUF_FILL		(1 << 0)
+
+#define HC_MEMORY_REG		0x33c
+#define ISP_BANK(x)		((x) << 16)
+
+#define HC_PORT1_CTRL		0x374
+
+#define HC_SOF_COUNT		0x004
+
+//#define HS_IPD_COUNT		0x010
+
+#define HC_FULL_SPEED_SOF_COUNT		0x018
+
+#define HC_FULL_SPEED_TR_IPD		0x014
+
+#define HC_FULL_SPEED_HUB_IPD	0x08
+
+
+#define PORT1_POWER		(3 << 3)
+#define PORT1_INIT1		(1 << 7)
+#define PORT1_INIT2		(1 << 23)
+#define HW_OTG_CTRL_SET		0x374
+#define HW_OTG_CTRL_CLR		0x376
+#define HW_OTG_DISABLE		(1 << 10)
+#define HW_OTG_SE0_EN		(1 << 9)
+#define HW_BDIS_ACON_EN		(1 << 8)
+#define HW_SW_SEL_HC_DC		(1 << 7)
+#define HW_VBUS_CHRG		(1 << 6)
+#define HW_VBUS_DISCHRG		(1 << 5)
+#define HW_VBUS_DRV		(1 << 4)
+#define HW_SEL_CP_EXT		(1 << 3)
+#define HW_DM_PULLDOWN		(1 << 2)
+#define HW_DP_PULLDOWN		(1 << 1)
+#define HW_DP_PULLUP		(1 << 0)
+
+#define HC_OTG_STATUS		0x378
+#define HW_VBUS_VLD		(1 << 0)
+
+
+/* Interrupt Register */
+#define HC_INTERRUPT_REG	0x310
+
+#define HC_INTERRUPT_ENABLE	0x314
+#define HC_ISO_INT		(1 << 9)
+#define HC_ATL_INT		(1 << 8)
+#define HC_INTL_INT		(1 << 7)
+#define HC_EOT_INT		(1 << 3)
+#define HC_SOT_INT		(1 << 1)
+
+#define HC_DISCONNECT_INT	(1 << 2)
+#define HC_CONNECT_INT		(1 << 0)
+
+
+#define INTERRUPT_ENABLE_MASK	(HC_INTL_INT | HC_ATL_INT | HC_ISO_INT | HC_DISCONNECT_INT | HC_CONNECT_INT)
+
+
+
+
+#define HC_ISO_IRQ_MASK_OR_REG	0x318
+#define HC_INT_IRQ_MASK_OR_REG	0x31c
+#define HC_ATL_IRQ_MASK_OR_REG	0x320
+#define HC_ISO_IRQ_MASK_AND_REG	0x324
+#define HC_INT_IRQ_MASK_AND_REG	0x328
+#define HC_ATL_IRQ_MASK_AND_REG	0x32c
+
+/* -----------------------------------------------------------------------------
+ * Peripheral Controller
+ */
+
+/* Initialization Registers */
+#define DC_ADDRESS			0x0200
+#define DC_DEVEN			(1 << 7)
+
+#define DC_MODE				0x020c
+#define DC_DMACLKON			(1 << 9)
+#define DC_VBUSSTAT			(1 << 8)
+#define DC_CLKAON			(1 << 7)
+#define DC_SNDRSU			(1 << 6)
+#define DC_GOSUSP			(1 << 5)
+#define DC_SFRESET			(1 << 4)
+#define DC_GLINTENA			(1 << 3)
+#define DC_WKUPCS			(1 << 2)
+
+#define DC_INTCONF			0x0210
+#define DC_CDBGMOD_ACK_NAK		(0 << 6)
+#define DC_CDBGMOD_ACK			(1 << 6)
+#define DC_CDBGMOD_ACK_1NAK		(2 << 6)
+#define DC_DDBGMODIN_ACK_NAK		(0 << 4)
+#define DC_DDBGMODIN_ACK		(1 << 4)
+#define DC_DDBGMODIN_ACK_1NAK		(2 << 4)
+#define DC_DDBGMODOUT_ACK_NYET_NAK	(0 << 2)
+#define DC_DDBGMODOUT_ACK_NYET		(1 << 2)
+#define DC_DDBGMODOUT_ACK_NYET_1NAK	(2 << 2)
+#define DC_INTLVL			(1 << 1)
+#define DC_INTPOL			(1 << 0)
+
+#define DC_DEBUG			0x0212
+#define DC_INTENABLE			0x0214
+#define DC_IEPTX(n)			(1 << (11 + 2 * (n)))
+#define DC_IEPRX(n)			(1 << (10 + 2 * (n)))
+#define DC_IEPRXTX(n)			(3 << (10 + 2 * (n)))
+#define DC_IEP0SETUP			(1 << 8)
+#define DC_IEVBUS			(1 << 7)
+#define DC_IEDMA			(1 << 6)
+#define DC_IEHS_STA			(1 << 5)
+#define DC_IERESM			(1 << 4)
+#define DC_IESUSP			(1 << 3)
+#define DC_IEPSOF			(1 << 2)
+#define DC_IESOF			(1 << 1)
+#define DC_IEBRST			(1 << 0)
+
+/* Data Flow Registers */
+#define DC_EPINDEX			0x022c
+#define DC_EP0SETUP			(1 << 5)
+#define DC_ENDPIDX(n)			((n) << 1)
+#define DC_EPDIR			(1 << 0)
+
+#define DC_CTRLFUNC			0x0228
+#define DC_CLBUF			(1 << 4)
+#define DC_VENDP			(1 << 3)
+#define DC_DSEN				(1 << 2)
+#define DC_STATUS			(1 << 1)
+#define DC_STALL			(1 << 0)
+
+#define DC_DATAPORT			0x0220
+#define DC_BUFLEN			0x021c
+#define DC_DATACOUNT_MASK		0xffff
+#define DC_BUFSTAT			0x021e
+#define DC_EPMAXPKTSZ			0x0204
+
+#define DC_EPTYPE			0x0208
+#define DC_NOEMPKT			(1 << 4)
+#define DC_EPENABLE			(1 << 3)
+#define DC_DBLBUF			(1 << 2)
+#define DC_ENDPTYP_ISOC			(1 << 0)
+#define DC_ENDPTYP_BULK			(2 << 0)
+#define DC_ENDPTYP_INTERRUPT		(3 << 0)
+
+/* DMA Registers */
+#define DC_DMACMD			0x0230
+#define DC_DMATXCOUNT			0x0234
+#define DC_DMACONF			0x0238
+#define DC_DMAHW			0x023c
+#define DC_DMAINTREASON			0x0250
+#define DC_DMAINTEN			0x0254
+#define DC_DMAEP			0x0258
+#define DC_DMABURSTCOUNT		0x0264
+
+/* General Registers */
+#define DC_INTERRUPT			0x0218
+#define DC_CHIPID			0x0270
+#define DC_FRAMENUM			0x0274
+#define DC_SCRATCH			0x0278
+#define DC_UNLOCKDEV			0x027c
+#define DC_INTPULSEWIDTH		0x0280
+#define DC_TESTMODE			0x0284
+
+#endif
diff -Naur linux-5.4.1/drivers/usb/vega/vega-udc.c linux-5.4.1_modified/drivers/usb/vega/vega-udc.c
--- linux-5.4.1/drivers/usb/vega/vega-udc.c	1970-01-01 05:30:00.000000000 +0530
+++ linux-5.4.1_modified/drivers/usb/vega/vega-udc.c	2025-08-08 10:40:35.458968709 +0530
@@ -0,0 +1,1513 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Driver for the NXP ISP1761 device controller
+ *
+ * Copyright 2014 Ideas on Board Oy
+ *
+ * Contacts:
+ *	Laurent Pinchart <laurent.pinchart@ideasonboard.com>
+ */
+
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/list.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/timer.h>
+#include <linux/usb.h>
+
+//#include "isp1760-core.h"
+#include "vega-regs.h"
+#include "vega-udc.h"
+#include "vega-core.h"
+
+
+#define vega_dbg(...)		//dev_err(__VA_ARGS__)
+
+#define VEGA_VBUS_POLL_INTERVAL	msecs_to_jiffies(500)
+
+struct vega_request {
+	struct usb_request req;
+	struct list_head queue;
+	struct vega_ep *ep;
+	unsigned int packet_size;
+};
+
+static inline struct vega_udc *gadget_to_udc(struct usb_gadget *gadget)
+{
+	return container_of(gadget, struct vega_udc, gadget);
+}
+
+static inline struct vega_ep *ep_to_udc_ep(struct usb_ep *ep)
+{
+	return container_of(ep, struct vega_ep, ep);
+}
+
+static inline struct vega_request *req_to_udc_req(struct usb_request *req)
+{
+	return container_of(req, struct vega_request, req);
+}
+
+static inline u32 vega_udc_read(struct vega_udc *udc, u16 reg)
+{
+	return vega_read32(udc->regs, reg);
+}
+
+static inline void vega_udc_write(struct vega_udc *udc, u16 reg, u32 val)
+{
+	vega_write32(udc->regs, reg, val);
+}
+
+/* -----------------------------------------------------------------------------
+ * Endpoint Management
+ */
+
+static struct vega_ep *vega_udc_find_ep(struct vega_udc *udc,
+					      u16 index)
+{
+	unsigned int i;
+
+	if (index == 0)
+		return &udc->ep[0];
+
+	for (i = 1; i < ARRAY_SIZE(udc->ep); ++i) {
+		if (udc->ep[i].addr == index)
+			return udc->ep[i].desc ? &udc->ep[i] : NULL;
+	}
+
+	return NULL;
+}
+
+static void __vega_udc_select_ep(struct vega_ep *ep, int dir)
+{
+	vega_udc_write(ep->udc, DC_EPINDEX,
+			  DC_ENDPIDX(ep->addr & USB_ENDPOINT_NUMBER_MASK) |
+			  (dir == USB_DIR_IN ? DC_EPDIR : 0));
+}
+
+/**
+ * vega_udc_select_ep - Select an endpoint for register access
+ * @ep: The endpoint
+ *
+ * The ISP1761 endpoint registers are banked. This function selects the target
+ * endpoint for banked register access. The selection remains valid until the
+ * next call to this function, the next direct access to the EPINDEX register
+ * or the next reset, whichever comes first.
+ *
+ * Called with the UDC spinlock held.
+ */
+static void vega_udc_select_ep(struct vega_ep *ep)
+{
+	__vega_udc_select_ep(ep, ep->addr & USB_ENDPOINT_DIR_MASK);
+}
+
+/* Called with the UDC spinlock held. */
+static void vega_udc_ctrl_send_status(struct vega_ep *ep, int dir)
+{
+	struct vega_udc *udc = ep->udc;
+
+	/*
+	 * Proceed to the status stage. The status stage data packet flows in
+	 * the direction opposite to the data stage data packets, we thus need
+	 * to select the OUT/IN endpoint for IN/OUT transfers.
+	 */
+	vega_udc_write(udc, DC_EPINDEX, DC_ENDPIDX(0) |
+			  (dir == USB_DIR_IN ? 0 : DC_EPDIR));
+	vega_udc_write(udc, DC_CTRLFUNC, DC_STATUS);
+
+	/*
+	 * The hardware will terminate the request automatically and go back to
+	 * the setup stage without notifying us.
+	 */
+	udc->ep0_state = VEGA_CTRL_SETUP;
+}
+
+/* Called without the UDC spinlock held. */
+static void vega_udc_request_complete(struct vega_ep *ep,
+					 struct vega_request *req,
+					 int status)
+{
+	struct vega_udc *udc = ep->udc;
+	unsigned long flags;
+
+	vega_dbg(ep->udc->isp->dev, "completing request %p with status %d\n",req, status);
+
+	req->ep = NULL;
+	req->req.status = status;
+	req->req.complete(&ep->ep, &req->req);
+
+	spin_lock_irqsave(&udc->lock, flags);
+
+	/*
+	 * When completing control OUT requests, move to the status stage after
+	 * calling the request complete callback. This gives the gadget an
+	 * opportunity to stall the control transfer if needed.
+	 */
+	if (status == 0 && ep->addr == 0 && udc->ep0_dir == USB_DIR_OUT)
+		vega_udc_ctrl_send_status(ep, USB_DIR_OUT);
+
+	spin_unlock_irqrestore(&udc->lock, flags);
+}
+
+static void vega_udc_ctrl_send_stall(struct vega_ep *ep)
+{
+	struct vega_udc *udc = ep->udc;
+	unsigned long flags;
+
+	vega_dbg(ep->udc->isp->dev, "%s(ep%02x)\n", __func__, ep->addr);
+
+	spin_lock_irqsave(&udc->lock, flags);
+
+	/* Stall both the IN and OUT endpoints. */
+	__vega_udc_select_ep(ep, USB_DIR_OUT);
+	vega_udc_write(udc, DC_CTRLFUNC, DC_STALL);
+	__vega_udc_select_ep(ep, USB_DIR_IN);
+	vega_udc_write(udc, DC_CTRLFUNC, DC_STALL);
+
+	/* A protocol stall completes the control transaction. */
+	udc->ep0_state = VEGA_CTRL_SETUP;
+
+	spin_unlock_irqrestore(&udc->lock, flags);
+}
+
+/* -----------------------------------------------------------------------------
+ * Data Endpoints
+ */
+
+/* Called with the UDC spinlock held. */
+static bool vega_udc_receive(struct vega_ep *ep,
+				struct vega_request *req)
+{
+	struct vega_udc *udc = ep->udc;
+	unsigned int len;
+	u32 *buf;
+	int i;
+
+	vega_udc_select_ep(ep);
+	len = vega_udc_read(udc, DC_BUFLEN) & DC_DATACOUNT_MASK;
+
+	vega_dbg(udc->isp->dev, "%s: received %u bytes (%u/%u done)\n",
+		__func__, len, req->req.actual, req->req.length);
+
+	len = min(len, req->req.length - req->req.actual);
+
+	if (!len) {
+		/*
+		 * There's no data to be read from the FIFO, acknowledge the RX
+		 * interrupt by clearing the buffer.
+		 *
+		 * TODO: What if another packet arrives in the meantime ? The
+		 * datasheet doesn't clearly document how this should be
+		 * handled.
+		 */
+		vega_udc_write(udc, DC_CTRLFUNC, DC_CLBUF);
+		return false;
+	}
+
+	buf = req->req.buf + req->req.actual;
+
+	/*
+	 * Make sure not to read more than one extra byte, otherwise data from
+	 * the next packet might be removed from the FIFO.
+	 */
+	for (i = len; i > 2; i -= 4, ++buf)
+		*buf = le32_to_cpu(vega_udc_read(udc, DC_DATAPORT));
+	if (i > 0)
+		*(u16 *)buf = le16_to_cpu(readw(udc->regs + DC_DATAPORT));
+
+	req->req.actual += len;
+
+	/*
+	 * TODO: The short_not_ok flag isn't supported yet, but isn't used by
+	 * any gadget driver either.
+	 */
+
+	vega_dbg(udc->isp->dev,
+		"%s: req %p actual/length %u/%u maxpacket %u packet size %u\n",
+		__func__, req, req->req.actual, req->req.length, ep->maxpacket,
+		len);
+
+	ep->rx_pending = false;
+
+	/*
+	 * Complete the request if all data has been received or if a short
+	 * packet has been received.
+	 */
+	if (req->req.actual == req->req.length || len < ep->maxpacket) {
+		list_del(&req->queue);
+		return true;
+	}
+
+	return false;
+}
+
+static void vega_udc_transmit(struct vega_ep *ep,
+				 struct vega_request *req)
+{
+	struct vega_udc *udc = ep->udc;
+	u32 *buf = req->req.buf + req->req.actual;
+	int i;
+
+	req->packet_size = min(req->req.length - req->req.actual,
+			       ep->maxpacket);
+
+	vega_dbg(udc->isp->dev, "%s: transferring %u bytes (%u/%u done)\n",
+		__func__, req->packet_size, req->req.actual,
+		req->req.length);
+
+	__vega_udc_select_ep(ep, USB_DIR_IN);
+
+	if (req->packet_size)
+		vega_udc_write(udc, DC_BUFLEN, req->packet_size);
+
+	/*
+	 * Make sure not to write more than one extra byte, otherwise extra data
+	 * will stay in the FIFO and will be transmitted during the next control
+	 * request. The endpoint control CLBUF bit is supposed to allow flushing
+	 * the FIFO for this kind of conditions, but doesn't seem to work.
+	 */
+	for (i = req->packet_size; i > 2; i -= 4, ++buf)
+		vega_udc_write(udc, DC_DATAPORT, cpu_to_le32(*buf));
+	if (i > 0)
+		writew(cpu_to_le16(*(u16 *)buf), udc->regs + DC_DATAPORT);
+
+	if (ep->addr == 0)
+		vega_udc_write(udc, DC_CTRLFUNC, DC_DSEN);
+	if (!req->packet_size)
+		vega_udc_write(udc, DC_CTRLFUNC, DC_VENDP);
+}
+
+static void vega_ep_rx_ready(struct vega_ep *ep)
+{
+	struct vega_udc *udc = ep->udc;
+	struct vega_request *req;
+	bool complete;
+
+	spin_lock(&udc->lock);
+
+	if (ep->addr == 0 && udc->ep0_state != VEGA_CTRL_DATA_OUT) {
+		spin_unlock(&udc->lock);
+		vega_dbg(udc->isp->dev, "%s: invalid ep0 state %u\n", __func__,
+			udc->ep0_state);
+		return;
+	}
+
+	if (ep->addr != 0 && !ep->desc) {
+		spin_unlock(&udc->lock);
+		vega_dbg(udc->isp->dev, "%s: ep%02x is disabled\n", __func__,
+			ep->addr);
+		return;
+	}
+
+	if (list_empty(&ep->queue)) {
+		ep->rx_pending = true;
+		spin_unlock(&udc->lock);
+		vega_dbg(udc->isp->dev, "%s: ep%02x (%p) has no request queued\n",
+			__func__, ep->addr, ep);
+		return;
+	}
+
+	req = list_first_entry(&ep->queue, struct vega_request,
+			       queue);
+	complete = vega_udc_receive(ep, req);
+
+	spin_unlock(&udc->lock);
+
+	if (complete)
+		vega_udc_request_complete(ep, req, 0);
+}
+
+static void vega_ep_tx_complete(struct vega_ep *ep)
+{
+	struct vega_udc *udc = ep->udc;
+	struct vega_request *complete = NULL;
+	struct vega_request *req;
+	bool need_zlp;
+
+	spin_lock(&udc->lock);
+
+	if (ep->addr == 0 && udc->ep0_state != VEGA_CTRL_DATA_IN) {
+		spin_unlock(&udc->lock);
+		vega_dbg(udc->isp->dev, "TX IRQ: invalid endpoint state %u\n",
+			udc->ep0_state);
+		return;
+	}
+
+	if (list_empty(&ep->queue)) {
+		/*
+		 * This can happen for the control endpoint when the reply to
+		 * the GET_STATUS IN control request is sent directly by the
+		 * setup IRQ handler. Just proceed to the status stage.
+		 */
+		if (ep->addr == 0) {
+			vega_udc_ctrl_send_status(ep, USB_DIR_IN);
+			spin_unlock(&udc->lock);
+			return;
+		}
+
+		spin_unlock(&udc->lock);
+		vega_dbg(udc->isp->dev, "%s: ep%02x has no request queued\n",
+			__func__, ep->addr);
+		return;
+	}
+
+	req = list_first_entry(&ep->queue, struct vega_request,
+			       queue);
+	req->req.actual += req->packet_size;
+
+	need_zlp = req->req.actual == req->req.length &&
+		   !(req->req.length % ep->maxpacket) &&
+		   req->packet_size && req->req.zero;
+
+	vega_dbg(udc->isp->dev,
+		"TX IRQ: req %p actual/length %u/%u maxpacket %u packet size %u zero %u need zlp %u\n",
+		 req, req->req.actual, req->req.length, ep->maxpacket,
+		 req->packet_size, req->req.zero, need_zlp);
+
+	/*
+	 * Complete the request if all data has been sent and we don't need to
+	 * transmit a zero length packet.
+	 */
+	if (req->req.actual == req->req.length && !need_zlp) {
+		complete = req;
+		list_del(&req->queue);
+
+		if (ep->addr == 0)
+			vega_udc_ctrl_send_status(ep, USB_DIR_IN);
+
+		if (!list_empty(&ep->queue))
+			req = list_first_entry(&ep->queue,
+					       struct vega_request, queue);
+		else
+			req = NULL;
+	}
+
+	/*
+	 * Transmit the next packet or start the next request, if any.
+	 *
+	 * TODO: If the endpoint is stalled the next request shouldn't be
+	 * started, but what about the next packet ?
+	 */
+	if (req)
+		vega_udc_transmit(ep, req);
+
+	spin_unlock(&udc->lock);
+
+	if (complete)
+		vega_udc_request_complete(ep, complete, 0);
+}
+
+static int __vega_udc_set_halt(struct vega_ep *ep, bool halt)
+{
+	struct vega_udc *udc = ep->udc;
+
+	vega_dbg(udc->isp->dev, "%s: %s halt on ep%02x\n", __func__,
+		halt ? "set" : "clear", ep->addr);
+
+	if (ep->desc && usb_endpoint_xfer_isoc(ep->desc)) {
+		vega_dbg(udc->isp->dev, "%s: ep%02x is isochronous\n", __func__,
+			ep->addr);
+		return -EINVAL;
+	}
+
+	vega_udc_select_ep(ep);
+	vega_udc_write(udc, DC_CTRLFUNC, halt ? DC_STALL : 0);
+
+	if (ep->addr == 0) {
+		/* When halting the control endpoint, stall both IN and OUT. */
+		__vega_udc_select_ep(ep, USB_DIR_IN);
+		vega_udc_write(udc, DC_CTRLFUNC, halt ? DC_STALL : 0);
+	} else if (!halt) {
+		/* Reset the data PID by cycling the endpoint enable bit. */
+		u16 eptype = vega_udc_read(udc, DC_EPTYPE);
+
+		vega_udc_write(udc, DC_EPTYPE, eptype & ~DC_EPENABLE);
+		vega_udc_write(udc, DC_EPTYPE, eptype);
+
+		/*
+		 * Disabling the endpoint emptied the transmit FIFO, fill it
+		 * again if a request is pending.
+		 *
+		 * TODO: Does the gadget framework require synchronizatino with
+		 * the TX IRQ handler ?
+		 */
+		if ((ep->addr & USB_DIR_IN) && !list_empty(&ep->queue)) {
+			struct vega_request *req;
+
+			req = list_first_entry(&ep->queue,
+					       struct vega_request, queue);
+			vega_udc_transmit(ep, req);
+		}
+	}
+
+	ep->halted = halt;
+
+	return 0;
+}
+
+/* -----------------------------------------------------------------------------
+ * Control Endpoint
+ */
+
+static int vega_udc_get_status(struct vega_udc *udc,
+				  const struct usb_ctrlrequest *req)
+{
+	struct vega_ep *ep;
+	u16 status;
+
+	if (req->wLength != cpu_to_le16(2) || req->wValue != cpu_to_le16(0))
+		return -EINVAL;
+
+	switch (req->bRequestType) {
+	case USB_DIR_IN | USB_RECIP_DEVICE:
+		status = udc->devstatus;
+		break;
+
+	case USB_DIR_IN | USB_RECIP_INTERFACE:
+		status = 0;
+		break;
+
+	case USB_DIR_IN | USB_RECIP_ENDPOINT:
+		ep = vega_udc_find_ep(udc, le16_to_cpu(req->wIndex));
+		if (!ep)
+			return -EINVAL;
+
+		status = 0;
+		if (ep->halted)
+			status |= 1 << USB_ENDPOINT_HALT;
+		break;
+
+	default:
+		return -EINVAL;
+	}
+
+	vega_udc_write(udc, DC_EPINDEX, DC_ENDPIDX(0) | DC_EPDIR);
+	vega_udc_write(udc, DC_BUFLEN, 2);
+
+	writew(cpu_to_le16(status), udc->regs + DC_DATAPORT);
+
+	vega_udc_write(udc, DC_CTRLFUNC, DC_DSEN);
+
+	vega_dbg(udc->isp->dev, "%s: status 0x%04x\n", __func__, status);
+
+	return 0;
+}
+
+static int vega_udc_set_address(struct vega_udc *udc, u16 addr)
+{
+	if (addr > 127) {
+		vega_dbg(udc->isp->dev, "invalid device address %u\n", addr);
+		return -EINVAL;
+	}
+
+	if (udc->gadget.state != USB_STATE_DEFAULT &&
+	    udc->gadget.state != USB_STATE_ADDRESS) {
+		vega_dbg(udc->isp->dev, "can't set address in state %u\n",
+			udc->gadget.state);
+		return -EINVAL;
+	}
+
+	usb_gadget_set_state(&udc->gadget, addr ? USB_STATE_ADDRESS :
+			     USB_STATE_DEFAULT);
+
+	vega_udc_write(udc, DC_ADDRESS, DC_DEVEN | addr);
+
+	spin_lock(&udc->lock);
+	vega_udc_ctrl_send_status(&udc->ep[0], USB_DIR_OUT);
+	spin_unlock(&udc->lock);
+
+	return 0;
+}
+
+static bool vega_ep0_setup_standard(struct vega_udc *udc,
+				       struct usb_ctrlrequest *req)
+{
+	bool stall;
+
+	switch (req->bRequest) {
+	case USB_REQ_GET_STATUS:
+		return vega_udc_get_status(udc, req);
+
+	case USB_REQ_CLEAR_FEATURE:
+		switch (req->bRequestType) {
+		case USB_DIR_OUT | USB_RECIP_DEVICE: {
+			/* TODO: Handle remote wakeup feature. */
+			return true;
+		}
+
+		case USB_DIR_OUT | USB_RECIP_ENDPOINT: {
+			u16 index = le16_to_cpu(req->wIndex);
+			struct vega_ep *ep;
+
+			if (req->wLength != cpu_to_le16(0) ||
+			    req->wValue != cpu_to_le16(USB_ENDPOINT_HALT))
+				return true;
+
+			ep = vega_udc_find_ep(udc, index);
+			if (!ep)
+				return true;
+
+			spin_lock(&udc->lock);
+
+			/*
+			 * If the endpoint is wedged only the gadget can clear
+			 * the halt feature. Pretend success in that case, but
+			 * keep the endpoint halted.
+			 */
+			if (!ep->wedged)
+				stall = __vega_udc_set_halt(ep, false);
+			else
+				stall = false;
+
+			if (!stall)
+				vega_udc_ctrl_send_status(&udc->ep[0],
+							     USB_DIR_OUT);
+
+			spin_unlock(&udc->lock);
+			return stall;
+		}
+
+		default:
+			return true;
+		}
+		break;
+
+	case USB_REQ_SET_FEATURE:
+		switch (req->bRequestType) {
+		case USB_DIR_OUT | USB_RECIP_DEVICE: {
+			/* TODO: Handle remote wakeup and test mode features */
+			return true;
+		}
+
+		case USB_DIR_OUT | USB_RECIP_ENDPOINT: {
+			u16 index = le16_to_cpu(req->wIndex);
+			struct vega_ep *ep;
+
+			if (req->wLength != cpu_to_le16(0) ||
+			    req->wValue != cpu_to_le16(USB_ENDPOINT_HALT))
+				return true;
+
+			ep = vega_udc_find_ep(udc, index);
+			if (!ep)
+				return true;
+
+			spin_lock(&udc->lock);
+
+			stall = __vega_udc_set_halt(ep, true);
+			if (!stall)
+				vega_udc_ctrl_send_status(&udc->ep[0],
+							     USB_DIR_OUT);
+
+			spin_unlock(&udc->lock);
+			return stall;
+		}
+
+		default:
+			return true;
+		}
+		break;
+
+	case USB_REQ_SET_ADDRESS:
+		if (req->bRequestType != (USB_DIR_OUT | USB_RECIP_DEVICE))
+			return true;
+
+		return vega_udc_set_address(udc, le16_to_cpu(req->wValue));
+
+	case USB_REQ_SET_CONFIGURATION:
+		if (req->bRequestType != (USB_DIR_OUT | USB_RECIP_DEVICE))
+			return true;
+
+		if (udc->gadget.state != USB_STATE_ADDRESS &&
+		    udc->gadget.state != USB_STATE_CONFIGURED)
+			return true;
+
+		stall = udc->driver->setup(&udc->gadget, req) < 0;
+		if (stall)
+			return true;
+
+		usb_gadget_set_state(&udc->gadget, req->wValue ?
+				     USB_STATE_CONFIGURED : USB_STATE_ADDRESS);
+
+		/*
+		 * SET_CONFIGURATION (and SET_INTERFACE) must reset the halt
+		 * feature on all endpoints. There is however no need to do so
+		 * explicitly here as the gadget driver will disable and
+		 * reenable endpoints, clearing the halt feature.
+		 */
+		return false;
+
+	default:
+		return udc->driver->setup(&udc->gadget, req) < 0;
+	}
+}
+
+static void vega_ep0_setup(struct vega_udc *udc)
+{
+	union {
+		struct usb_ctrlrequest r;
+		u32 data[2];
+	} req;
+	unsigned int count;
+	bool stall = false;
+
+	spin_lock(&udc->lock);
+
+	vega_udc_write(udc, DC_EPINDEX, DC_EP0SETUP);
+
+	count = vega_udc_read(udc, DC_BUFLEN) & DC_DATACOUNT_MASK;
+	if (count != sizeof(req)) {
+		spin_unlock(&udc->lock);
+
+		dev_err(udc->isp->dev, "invalid length %u for setup packet\n",	count);
+
+		vega_udc_ctrl_send_stall(&udc->ep[0]);
+		return;
+	}
+
+	req.data[0] = vega_udc_read(udc, DC_DATAPORT);
+	req.data[1] = vega_udc_read(udc, DC_DATAPORT);
+
+	if (udc->ep0_state != VEGA_CTRL_SETUP) {
+		spin_unlock(&udc->lock);
+		vega_dbg(udc->isp->dev, "unexpected SETUP packet\n");
+		return;
+	}
+
+	/* Move to the data stage. */
+	if (!req.r.wLength)
+		udc->ep0_state = VEGA_CTRL_STATUS;
+	else if (req.r.bRequestType & USB_DIR_IN)
+		udc->ep0_state = VEGA_CTRL_DATA_IN;
+	else
+		udc->ep0_state = VEGA_CTRL_DATA_OUT;
+
+	udc->ep0_dir = req.r.bRequestType & USB_DIR_IN;
+	udc->ep0_length = le16_to_cpu(req.r.wLength);
+
+	spin_unlock(&udc->lock);
+
+	vega_dbg(udc->isp->dev,
+		"%s: bRequestType 0x%02x bRequest 0x%02x wValue 0x%04x wIndex 0x%04x wLength 0x%04x\n",
+		__func__, req.r.bRequestType, req.r.bRequest,
+		le16_to_cpu(req.r.wValue), le16_to_cpu(req.r.wIndex),
+		le16_to_cpu(req.r.wLength));
+
+	if ((req.r.bRequestType & USB_TYPE_MASK) == USB_TYPE_STANDARD)
+		stall = vega_ep0_setup_standard(udc, &req.r);
+	else
+		stall = udc->driver->setup(&udc->gadget, &req.r) < 0;
+
+	if (stall)
+		vega_udc_ctrl_send_stall(&udc->ep[0]);
+}
+
+/* -----------------------------------------------------------------------------
+ * Gadget Endpoint Operations
+ */
+
+static int vega_ep_enable(struct usb_ep *ep,
+			     const struct usb_endpoint_descriptor *desc)
+{
+	struct vega_ep *uep = ep_to_udc_ep(ep);
+	struct vega_udc *udc = uep->udc;
+	unsigned long flags;
+	unsigned int type;
+
+	vega_dbg(uep->udc->isp->dev, "%s\n", __func__);
+
+	/*
+	 * Validate the descriptor. The control endpoint can't be enabled
+	 * manually.
+	 */
+	if (desc->bDescriptorType != USB_DT_ENDPOINT ||
+	    desc->bEndpointAddress == 0 ||
+	    desc->bEndpointAddress != uep->addr ||
+	    le16_to_cpu(desc->wMaxPacketSize) > ep->maxpacket) {
+		vega_dbg(udc->isp->dev,
+			"%s: invalid descriptor type %u addr %02x ep addr %02x max packet size %u/%u\n",
+			__func__, desc->bDescriptorType,
+			desc->bEndpointAddress, uep->addr,
+			le16_to_cpu(desc->wMaxPacketSize), ep->maxpacket);
+		return -EINVAL;
+	}
+
+	switch (usb_endpoint_type(desc)) {
+	case USB_ENDPOINT_XFER_ISOC:
+		type = DC_ENDPTYP_ISOC;
+		break;
+	case USB_ENDPOINT_XFER_BULK:
+		type = DC_ENDPTYP_BULK;
+		break;
+	case USB_ENDPOINT_XFER_INT:
+		type = DC_ENDPTYP_INTERRUPT;
+		break;
+	case USB_ENDPOINT_XFER_CONTROL:
+	default:
+		vega_dbg(udc->isp->dev, "%s: control endpoints unsupported\n",
+			__func__);
+		return -EINVAL;
+	}
+
+	spin_lock_irqsave(&udc->lock, flags);
+
+	uep->desc = desc;
+	uep->maxpacket = le16_to_cpu(desc->wMaxPacketSize);
+	uep->rx_pending = false;
+	uep->halted = false;
+	uep->wedged = false;
+
+	vega_udc_select_ep(uep);
+	vega_udc_write(udc, DC_EPMAXPKTSZ, uep->maxpacket);
+	vega_udc_write(udc, DC_BUFLEN, uep->maxpacket);
+	vega_udc_write(udc, DC_EPTYPE, DC_EPENABLE | type);
+
+	spin_unlock_irqrestore(&udc->lock, flags);
+
+	return 0;
+}
+
+static int vega_ep_disable(struct usb_ep *ep)
+{
+	struct vega_ep *uep = ep_to_udc_ep(ep);
+	struct vega_udc *udc = uep->udc;
+	struct vega_request *req, *nreq;
+	LIST_HEAD(req_list);
+	unsigned long flags;
+
+	vega_dbg(udc->isp->dev, "%s\n", __func__);
+
+	spin_lock_irqsave(&udc->lock, flags);
+
+	if (!uep->desc) {
+		vega_dbg(udc->isp->dev, "%s: endpoint not enabled\n", __func__);
+		spin_unlock_irqrestore(&udc->lock, flags);
+		return -EINVAL;
+	}
+
+	uep->desc = NULL;
+	uep->maxpacket = 0;
+
+	vega_udc_select_ep(uep);
+	vega_udc_write(udc, DC_EPTYPE, 0);
+
+	/* TODO Synchronize with the IRQ handler */
+
+	list_splice_init(&uep->queue, &req_list);
+
+	spin_unlock_irqrestore(&udc->lock, flags);
+
+	list_for_each_entry_safe(req, nreq, &req_list, queue) {
+		list_del(&req->queue);
+		vega_udc_request_complete(uep, req, -ESHUTDOWN);
+	}
+
+	return 0;
+}
+
+static struct usb_request *vega_ep_alloc_request(struct usb_ep *ep,
+						    gfp_t gfp_flags)
+{
+	struct vega_request *req;
+
+	req = kzalloc(sizeof(*req), gfp_flags);
+	if (!req)
+		return NULL;
+
+	return &req->req;
+}
+
+static void vega_ep_free_request(struct usb_ep *ep, struct usb_request *_req)
+{
+	struct vega_request *req = req_to_udc_req(_req);
+
+	kfree(req);
+}
+
+static int vega_ep_queue(struct usb_ep *ep, struct usb_request *_req,
+			    gfp_t gfp_flags)
+{
+	struct vega_request *req = req_to_udc_req(_req);
+	struct vega_ep *uep = ep_to_udc_ep(ep);
+	struct vega_udc *udc = uep->udc;
+	bool complete = false;
+	unsigned long flags;
+	int ret = 0;
+
+	_req->status = -EINPROGRESS;
+	_req->actual = 0;
+
+	spin_lock_irqsave(&udc->lock, flags);
+
+	vega_dbg(udc->isp->dev,
+		"%s: req %p (%u bytes%s) ep %p(0x%02x)\n", __func__, _req,
+		_req->length, _req->zero ? " (zlp)" : "", uep, uep->addr);
+
+	req->ep = uep;
+
+	if (uep->addr == 0) {
+		if (_req->length != udc->ep0_length &&
+		    udc->ep0_state != VEGA_CTRL_DATA_IN) {
+			vega_dbg(udc->isp->dev,
+				"%s: invalid length %u for req %p\n",
+				__func__, _req->length, req);
+			ret = -EINVAL;
+			goto done;
+		}
+
+		switch (udc->ep0_state) {
+		case VEGA_CTRL_DATA_IN:
+			vega_dbg(udc->isp->dev, "%s: transmitting req %p\n",
+				__func__, req);
+
+			list_add_tail(&req->queue, &uep->queue);
+			vega_udc_transmit(uep, req);
+			break;
+
+		case VEGA_CTRL_DATA_OUT:
+			list_add_tail(&req->queue, &uep->queue);
+			__vega_udc_select_ep(uep, USB_DIR_OUT);
+			vega_udc_write(udc, DC_CTRLFUNC, DC_DSEN);
+			break;
+
+		case VEGA_CTRL_STATUS:
+			complete = true;
+			break;
+
+		default:
+			vega_dbg(udc->isp->dev, "%s: invalid ep0 state\n",
+				__func__);
+			ret = -EINVAL;
+			break;
+		}
+	} else if (uep->desc) {
+		bool empty = list_empty(&uep->queue);
+
+		list_add_tail(&req->queue, &uep->queue);
+		if ((uep->addr & USB_DIR_IN) && !uep->halted && empty)
+			vega_udc_transmit(uep, req);
+		else if (!(uep->addr & USB_DIR_IN) && uep->rx_pending)
+			complete = vega_udc_receive(uep, req);
+	} else {
+		vega_dbg(udc->isp->dev,
+			"%s: can't queue request to disabled ep%02x\n",
+			__func__, uep->addr);
+		ret = -ESHUTDOWN;
+	}
+
+done:
+	if (ret < 0)
+		req->ep = NULL;
+
+	spin_unlock_irqrestore(&udc->lock, flags);
+
+	if (complete)
+		vega_udc_request_complete(uep, req, 0);
+
+	return ret;
+}
+
+static int vega_ep_dequeue(struct usb_ep *ep, struct usb_request *_req)
+{
+	struct vega_request *req = req_to_udc_req(_req);
+	struct vega_ep *uep = ep_to_udc_ep(ep);
+	struct vega_udc *udc = uep->udc;
+	unsigned long flags;
+
+	vega_dbg(uep->udc->isp->dev, "%s(ep%02x)\n", __func__, uep->addr);
+
+	spin_lock_irqsave(&udc->lock, flags);
+
+	if (req->ep != uep)
+		req = NULL;
+	else
+		list_del(&req->queue);
+
+	spin_unlock_irqrestore(&udc->lock, flags);
+
+	if (!req)
+		return -EINVAL;
+
+	vega_udc_request_complete(uep, req, -ECONNRESET);
+	return 0;
+}
+
+static int __vega_ep_set_halt(struct vega_ep *uep, bool stall, bool wedge)
+{
+	struct vega_udc *udc = uep->udc;
+	int ret;
+
+	if (!uep->addr) {
+		/*
+		 * Halting the control endpoint is only valid as a delayed error
+		 * response to a SETUP packet. Make sure EP0 is in the right
+		 * stage and that the gadget isn't trying to clear the halt
+		 * condition.
+		 */
+		if (WARN_ON(udc->ep0_state == VEGA_CTRL_SETUP || !stall ||
+			     wedge)) {
+			return -EINVAL;
+		}
+	}
+
+	if (uep->addr && !uep->desc) {
+		vega_dbg(udc->isp->dev, "%s: ep%02x is disabled\n", __func__,
+			uep->addr);
+		return -EINVAL;
+	}
+
+	if (uep->addr & USB_DIR_IN) {
+		/* Refuse to halt IN endpoints with active transfers. */
+		if (!list_empty(&uep->queue)) {
+			vega_dbg(udc->isp->dev,
+				"%s: ep%02x has request pending\n", __func__,
+				uep->addr);
+			return -EAGAIN;
+		}
+	}
+
+	ret = __vega_udc_set_halt(uep, stall);
+	if (ret < 0)
+		return ret;
+
+	if (!uep->addr) {
+		/*
+		 * Stalling EP0 completes the control transaction, move back to
+		 * the SETUP state.
+		 */
+		udc->ep0_state = VEGA_CTRL_SETUP;
+		return 0;
+	}
+
+	if (wedge)
+		uep->wedged = true;
+	else if (!stall)
+		uep->wedged = false;
+
+	return 0;
+}
+
+static int vega_ep_set_halt(struct usb_ep *ep, int value)
+{
+	struct vega_ep *uep = ep_to_udc_ep(ep);
+	unsigned long flags;
+	int ret;
+
+	vega_dbg(uep->udc->isp->dev, "%s: %s halt on ep%02x\n", __func__,
+		value ? "set" : "clear", uep->addr);
+
+	spin_lock_irqsave(&uep->udc->lock, flags);
+	ret = __vega_ep_set_halt(uep, value, false);
+	spin_unlock_irqrestore(&uep->udc->lock, flags);
+
+	return ret;
+}
+
+static int vega_ep_set_wedge(struct usb_ep *ep)
+{
+	struct vega_ep *uep = ep_to_udc_ep(ep);
+	unsigned long flags;
+	int ret;
+
+	vega_dbg(uep->udc->isp->dev, "%s: set wedge on ep%02x)\n", __func__,
+		uep->addr);
+
+	spin_lock_irqsave(&uep->udc->lock, flags);
+	ret = __vega_ep_set_halt(uep, true, true);
+	spin_unlock_irqrestore(&uep->udc->lock, flags);
+
+	return ret;
+}
+
+static void vega_ep_fifo_flush(struct usb_ep *ep)
+{
+	struct vega_ep *uep = ep_to_udc_ep(ep);
+	struct vega_udc *udc = uep->udc;
+	unsigned long flags;
+
+	spin_lock_irqsave(&udc->lock, flags);  //compatible
+
+	vega_udc_select_ep(uep);
+
+	/*
+	 * Set the CLBUF bit twice to flush both buffers in case double
+	 * buffering is enabled.
+	 */
+	vega_udc_write(udc, DC_CTRLFUNC, DC_CLBUF);
+	vega_udc_write(udc, DC_CTRLFUNC, DC_CLBUF);
+
+	spin_unlock_irqrestore(&udc->lock, flags);
+}
+
+static const struct usb_ep_ops vega_ep_ops = {
+	.enable = vega_ep_enable,
+	.disable = vega_ep_disable,
+	.alloc_request = vega_ep_alloc_request,
+	.free_request = vega_ep_free_request,
+	.queue = vega_ep_queue,
+	.dequeue = vega_ep_dequeue,
+	.set_halt = vega_ep_set_halt,
+	.set_wedge = vega_ep_set_wedge,
+	.fifo_flush = vega_ep_fifo_flush,
+};
+
+/* -----------------------------------------------------------------------------
+ * Device States
+ */
+
+/* Called with the UDC spinlock held. */
+static void vega_udc_connect(struct vega_udc *udc)
+{
+	usb_gadget_set_state(&udc->gadget, USB_STATE_POWERED);
+	mod_timer(&udc->vbus_timer, jiffies + VEGA_VBUS_POLL_INTERVAL);
+}
+
+void vega_set_pullup(struct vega_device *isp, bool enable)
+{
+	vega_udc_write(isp->regs, HW_OTG_CTRL_SET,
+			enable ? HW_DP_PULLUP : HW_DP_PULLUP << 16);
+}
+
+/* Called with the UDC spinlock held. */
+static void vega_udc_disconnect(struct vega_udc *udc)
+{
+	if (udc->gadget.state < USB_STATE_POWERED)
+		return;
+
+	vega_dbg(udc->isp->dev, "Device disconnected in state %u\n",
+		 udc->gadget.state);
+
+	udc->gadget.speed = USB_SPEED_UNKNOWN;
+	usb_gadget_set_state(&udc->gadget, USB_STATE_ATTACHED);
+
+	if (udc->driver->disconnect)
+		udc->driver->disconnect(&udc->gadget);
+
+	del_timer(&udc->vbus_timer);
+
+	/* TODO Reset all endpoints ? */
+}
+
+static void vega_udc_init_hw(struct vega_udc *udc)
+{
+	/*
+	 * The device controller currently shares its interrupt with the host
+	 * controller, the DC_IRQ polarity and signaling mode are ignored. Set
+	 * the to active-low level-triggered.
+	 *
+	 * Configure the control, in and out pipes to generate interrupts on
+	 * ACK tokens only (and NYET for the out pipe). The default
+	 * configuration also generates an interrupt on the first NACK token.
+	 */
+	vega_udc_write(udc, DC_INTCONF, DC_CDBGMOD_ACK | DC_DDBGMODIN_ACK |
+			  DC_DDBGMODOUT_ACK_NYET);
+
+	vega_udc_write(udc, DC_INTENABLE, DC_IEPRXTX(7) | DC_IEPRXTX(6) |
+			  DC_IEPRXTX(5) | DC_IEPRXTX(4) | DC_IEPRXTX(3) |
+			  DC_IEPRXTX(2) | DC_IEPRXTX(1) | DC_IEPRXTX(0) |
+			  DC_IEP0SETUP | DC_IEVBUS | DC_IERESM | DC_IESUSP |
+			  DC_IEHS_STA | DC_IEBRST);
+
+	if (udc->connected)
+		vega_set_pullup(udc->isp, true);
+
+	vega_udc_write(udc, DC_ADDRESS, DC_DEVEN);
+}
+
+static void vega_udc_reset(struct vega_udc *udc)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&udc->lock, flags);
+
+	/*
+	 * The bus reset has reset most registers to their default value,
+	 * reinitialize the UDC hardware.
+	 */
+	vega_udc_init_hw(udc);
+
+	udc->ep0_state = VEGA_CTRL_SETUP;
+	udc->gadget.speed = USB_SPEED_FULL;
+
+	usb_gadget_udc_reset(&udc->gadget, udc->driver);
+
+	spin_unlock_irqrestore(&udc->lock, flags);
+}
+
+static void vega_udc_suspend(struct vega_udc *udc)
+{
+	if (udc->gadget.state < USB_STATE_DEFAULT)
+		return;
+
+	if (udc->driver->suspend)
+		udc->driver->suspend(&udc->gadget);
+}
+
+static void vega_udc_resume(struct vega_udc *udc)
+{
+	if (udc->gadget.state < USB_STATE_DEFAULT)
+		return;
+
+	if (udc->driver->resume)
+		udc->driver->resume(&udc->gadget);
+}
+
+/* -----------------------------------------------------------------------------
+ * Gadget Operations
+ */
+
+static int vega_udc_get_frame(struct usb_gadget *gadget)
+{
+	struct vega_udc *udc = gadget_to_udc(gadget);
+
+	return vega_udc_read(udc, DC_FRAMENUM) & ((1 << 11) - 1);
+}
+
+static int vega_udc_wakeup(struct usb_gadget *gadget)
+{
+	struct vega_udc *udc = gadget_to_udc(gadget);
+
+	vega_dbg(udc->isp->dev, "%s\n", __func__);
+	return -ENOTSUPP;
+}
+
+static int vega_udc_set_selfpowered(struct usb_gadget *gadget,
+				       int is_selfpowered)
+{
+	struct vega_udc *udc = gadget_to_udc(gadget);
+
+	if (is_selfpowered)
+		udc->devstatus |= 1 << USB_DEVICE_SELF_POWERED;
+	else
+		udc->devstatus &= ~(1 << USB_DEVICE_SELF_POWERED);
+
+	return 0;
+}
+
+static int vega_udc_pullup(struct usb_gadget *gadget, int is_on)
+{
+	struct vega_udc *udc = gadget_to_udc(gadget);
+
+	vega_set_pullup(udc->isp, is_on);
+	udc->connected = is_on;
+
+	return 0;
+}
+
+static int vega_udc_start(struct usb_gadget *gadget,
+			     struct usb_gadget_driver *driver)
+{
+	struct vega_udc *udc = gadget_to_udc(gadget);
+	unsigned long flags;
+
+	/* The hardware doesn't support low speed. */
+	if (driver->max_speed < USB_SPEED_FULL) {
+		dev_err(udc->isp->dev, "Invalid gadget driver\n");
+		return -EINVAL;
+	}
+
+	spin_lock_irqsave(&udc->lock, flags);
+
+	if (udc->driver) {
+		dev_err(udc->isp->dev, "UDC already has a gadget driver\n");
+		spin_unlock_irqrestore(&udc->lock, flags);
+		return -EBUSY;
+	}
+
+	udc->driver = driver;
+
+	spin_unlock_irqrestore(&udc->lock, flags);
+
+	vega_dbg(udc->isp->dev, "starting UDC with driver %s\n",
+		driver->function);
+
+	udc->devstatus = 0;
+	udc->connected = true;
+
+	usb_gadget_set_state(&udc->gadget, USB_STATE_ATTACHED);
+
+	/* DMA isn't supported yet, don't enable the DMA clock. */
+	vega_udc_write(udc, DC_MODE, DC_GLINTENA);
+
+	vega_udc_init_hw(udc);
+
+	vega_dbg(udc->isp->dev, "UDC started with driver %s\n",
+		driver->function);
+
+	return 0;
+}
+
+static int vega_udc_stop(struct usb_gadget *gadget)
+{
+	struct vega_udc *udc = gadget_to_udc(gadget);
+	unsigned long flags;
+
+	vega_dbg(udc->isp->dev, "%s\n", __func__);
+
+	del_timer_sync(&udc->vbus_timer);
+
+	vega_udc_write(udc, DC_MODE, 0);
+
+	spin_lock_irqsave(&udc->lock, flags);
+	udc->driver = NULL;
+	spin_unlock_irqrestore(&udc->lock, flags);
+
+	return 0;
+}
+
+static const struct usb_gadget_ops vega_udc_ops = {
+	.get_frame = vega_udc_get_frame,
+	.wakeup = vega_udc_wakeup,
+	.set_selfpowered = vega_udc_set_selfpowered,
+	.pullup = vega_udc_pullup,
+	.udc_start = vega_udc_start,
+	.udc_stop = vega_udc_stop,
+};
+
+/* -----------------------------------------------------------------------------
+ * Interrupt Handling
+ */
+
+static irqreturn_t vega_udc_irq(int irq, void *dev)
+{
+	struct vega_udc *udc = dev;
+	unsigned int i;
+	u32 status;
+
+	status = vega_udc_read(udc, DC_INTERRUPT)
+	       & vega_udc_read(udc, DC_INTENABLE);
+	vega_udc_write(udc, DC_INTERRUPT, status);
+
+	if (status & DC_IEVBUS) {
+		vega_dbg(udc->isp->dev, "%s(VBUS)\n", __func__);
+		/* The VBUS interrupt is only triggered when VBUS appears. */
+		spin_lock(&udc->lock);
+		vega_udc_connect(udc);
+		spin_unlock(&udc->lock);
+	}
+
+	if (status & DC_IEBRST) {
+		vega_dbg(udc->isp->dev, "%s(BRST)\n", __func__);
+
+		vega_udc_reset(udc);
+	}
+
+	for (i = 0; i <= 7; ++i) {
+		struct vega_ep *ep = &udc->ep[i*2];
+
+		if (status & DC_IEPTX(i)) {
+			vega_dbg(udc->isp->dev, "%s(EPTX%u)\n", __func__, i);
+			vega_ep_tx_complete(ep);
+		}
+
+		if (status & DC_IEPRX(i)) {
+			vega_dbg(udc->isp->dev, "%s(EPRX%u)\n", __func__, i);
+			vega_ep_rx_ready(i ? ep - 1 : ep);
+		}
+	}
+
+	if (status & DC_IEP0SETUP) {
+		vega_dbg(udc->isp->dev, "%s(EP0SETUP)\n", __func__);
+
+		vega_ep0_setup(udc);
+	}
+
+	if (status & DC_IERESM) {
+		vega_dbg(udc->isp->dev, "%s(RESM)\n", __func__);
+		vega_udc_resume(udc);
+	}
+
+	if (status & DC_IESUSP) {
+		vega_dbg(udc->isp->dev, "%s(SUSP)\n", __func__);
+
+		spin_lock(&udc->lock);
+		if (!(vega_udc_read(udc, DC_MODE) & DC_VBUSSTAT))
+			vega_udc_disconnect(udc);
+		else
+			vega_udc_suspend(udc);
+		spin_unlock(&udc->lock);
+	}
+
+	if (status & DC_IEHS_STA) {
+		vega_dbg(udc->isp->dev, "%s(HS_STA)\n", __func__);
+		udc->gadget.speed = USB_SPEED_HIGH;
+	}
+
+	return status ? IRQ_HANDLED : IRQ_NONE;
+}
+
+static void vega_udc_vbus_poll(struct timer_list *t)
+{
+	struct vega_udc *udc = from_timer(udc, t, vbus_timer);
+	unsigned long flags;
+
+	spin_lock_irqsave(&udc->lock, flags);
+
+	if (!(vega_udc_read(udc, DC_MODE) & DC_VBUSSTAT))
+		vega_udc_disconnect(udc);
+	else if (udc->gadget.state >= USB_STATE_POWERED)
+		mod_timer(&udc->vbus_timer,
+			  jiffies + VEGA_VBUS_POLL_INTERVAL);
+
+	spin_unlock_irqrestore(&udc->lock, flags);
+}
+
+/* -----------------------------------------------------------------------------
+ * Registration
+ */
+
+static void vega_udc_init_eps(struct vega_udc *udc)
+{
+	unsigned int i;
+
+	INIT_LIST_HEAD(&udc->gadget.ep_list);
+
+	for (i = 0; i < ARRAY_SIZE(udc->ep); ++i) {
+		struct vega_ep *ep = &udc->ep[i];
+		unsigned int ep_num = (i + 1) / 2;
+		bool is_in = !(i & 1);
+
+		ep->udc = udc;
+
+		INIT_LIST_HEAD(&ep->queue);
+
+		ep->addr = (ep_num && is_in ? USB_DIR_IN : USB_DIR_OUT)
+			 | ep_num;
+		ep->desc = NULL;
+
+		sprintf(ep->name, "ep%u%s", ep_num,
+			ep_num ? (is_in ? "in" : "out") : "");
+
+		ep->ep.ops = &vega_ep_ops;
+		ep->ep.name = ep->name;
+
+		/*
+		 * Hardcode the maximum packet sizes for now, to 64 bytes for
+		 * the control endpoint and 512 bytes for all other endpoints.
+		 * This fits in the 8kB FIFO without double-buffering.
+		 */
+		if (ep_num == 0) {
+			usb_ep_set_maxpacket_limit(&ep->ep, 64);
+			ep->ep.caps.type_control = true;
+			ep->ep.caps.dir_in = true;
+			ep->ep.caps.dir_out = true;
+			ep->maxpacket = 64;
+			udc->gadget.ep0 = &ep->ep;
+		} else {
+			usb_ep_set_maxpacket_limit(&ep->ep, 512);
+			ep->ep.caps.type_iso = true;
+			ep->ep.caps.type_bulk = true;
+			ep->ep.caps.type_int = true;
+			ep->maxpacket = 0;
+			list_add_tail(&ep->ep.ep_list, &udc->gadget.ep_list);
+		}
+
+		if (is_in)
+			ep->ep.caps.dir_in = true;
+		else
+			ep->ep.caps.dir_out = true;
+	}
+}
+
+static int vega_udc_init(struct vega_udc *udc)
+{
+	u16 scratch;
+	u32 chipid;
+
+	/*
+	 * Check that the controller is present by writing to the scratch
+	 * register, modifying the bus pattern by reading from the chip ID
+	 * register, and reading the scratch register value back. The chip ID
+	 * and scratch register contents must match the expected values.
+	 */
+	vega_udc_write(udc, DC_SCRATCH, 0xbabe);
+	chipid = vega_udc_read(udc, DC_CHIPID);
+	scratch = vega_udc_read(udc, DC_SCRATCH);
+
+	if (scratch != 0xbabe) {
+		dev_err(udc->isp->dev,
+			"udc: scratch test failed (0x%04x/0x%08x)\n",
+			scratch, chipid);
+		return -ENODEV;
+	}
+
+	if (chipid != 0x00011582 && chipid != 0x00158210) {
+		dev_err(udc->isp->dev, "udc: invalid chip ID 0x%08x\n", chipid);
+		return -ENODEV;
+	}
+
+	/* Reset the device controller. */
+	vega_udc_write(udc, DC_MODE, DC_SFRESET);
+	usleep_range(10000, 11000);
+	vega_udc_write(udc, DC_MODE, 0);
+	usleep_range(10000, 11000);
+
+	return 0;
+}
+
+int vega_udc_register(struct vega_device *isp, int irq,
+			 unsigned long irqflags)
+{
+	struct vega_udc *udc = &isp->udc;
+	int ret;
+
+	udc->irq = -1;
+	udc->isp = isp;
+	udc->regs = isp->regs;
+
+	spin_lock_init(&udc->lock);
+	timer_setup(&udc->vbus_timer, vega_udc_vbus_poll, 0);
+
+	ret = vega_udc_init(udc);
+	if (ret < 0)
+		return ret;
+
+	udc->irqname = kasprintf(GFP_KERNEL, "%s (udc)", dev_name(isp->dev));
+	if (!udc->irqname)
+		return -ENOMEM;
+
+	ret = request_irq(irq, vega_udc_irq, IRQF_SHARED | irqflags,
+			  udc->irqname, udc);
+	if (ret < 0)
+		goto error;
+
+	udc->irq = irq;
+
+	/*
+	 * Initialize the gadget static fields and register its device. Gadget
+	 * fields that vary during the life time of the gadget are initialized
+	 * by the UDC core.
+	 */
+	udc->gadget.ops = &vega_udc_ops;
+	udc->gadget.speed = USB_SPEED_UNKNOWN;
+	udc->gadget.max_speed = USB_SPEED_HIGH;
+	udc->gadget.name = "vega-udc";      // previously isp1761_udc
+
+	vega_udc_init_eps(udc);
+
+	ret = usb_add_gadget_udc(isp->dev, &udc->gadget);
+	if (ret < 0)
+		goto error;
+
+	return 0;
+
+error:
+	if (udc->irq >= 0)
+		free_irq(udc->irq, udc);
+	kfree(udc->irqname);
+
+	return ret;
+}
+
+void vega_udc_unregister(struct vega_device *isp)
+{
+	struct vega_udc *udc = &isp->udc;
+
+	if (!udc->isp)
+		return;
+
+	usb_del_gadget_udc(&udc->gadget);
+
+	free_irq(udc->irq, udc);
+	kfree(udc->irqname);
+}
diff -Naur linux-5.4.1/drivers/usb/vega/vega-udc.h linux-5.4.1_modified/drivers/usb/vega/vega-udc.h
--- linux-5.4.1/drivers/usb/vega/vega-udc.h	1970-01-01 05:30:00.000000000 +0530
+++ linux-5.4.1_modified/drivers/usb/vega/vega-udc.h	2025-08-08 10:40:35.459275073 +0530
@@ -0,0 +1,109 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Driver for the NXP ISP1761 device controller
+ *
+ * Copyright 2014 Ideas on Board Oy
+ *
+ * Contacts:
+ *	Laurent Pinchart <laurent.pinchart@ideasonboard.com>
+ */
+
+#ifndef _VEGA_UDC_H_
+#define _VEGA_UDC_H_
+
+#include <linux/ioport.h>
+#include <linux/list.h>
+#include <linux/spinlock.h>
+#include <linux/timer.h>
+#include <linux/usb/gadget.h>
+
+struct vega_device;
+struct vega_udc;
+
+struct vega_ep {
+	struct vega_udc *udc;
+	struct usb_ep ep;
+
+	struct list_head queue;
+
+	unsigned int addr;
+	unsigned int maxpacket;
+	char name[7];
+
+	const struct usb_endpoint_descriptor *desc;
+
+	bool rx_pending;
+	bool halted;
+	bool wedged;
+};
+
+/**
+ * struct vega_udc - UDC state information
+ * irq: IRQ number
+ * irqname: IRQ name (as passed to request_irq)
+ * regs: Base address of the UDC registers
+ * driver: Gadget driver
+ * gadget: Gadget device
+ * lock: Protects driver, vbus_timer, ep, ep0_*, DC_EPINDEX register
+ * ep: Array of endpoints
+ * ep0_state: Control request state for endpoint 0
+ * ep0_dir: Direction of the current control request
+ * ep0_length: Length of the current control request
+ * connected: Tracks gadget driver bus connection state
+ */
+
+enum vega_ctrl_state {
+	VEGA_CTRL_SETUP, /* Waiting for a SETUP transaction */
+	VEGA_CTRL_DATA_IN, /* Setup received, data IN stage */
+	VEGA_CTRL_DATA_OUT, /* Setup received, data OUT stage */
+	VEGA_CTRL_STATUS, /* 0-length request in status stage */
+};
+
+struct vega_udc {
+	struct vega_device *isp;
+
+	int irq;
+	char *irqname;
+	void __iomem *regs;
+
+	struct usb_gadget_driver *driver;
+	struct usb_gadget gadget;
+
+	spinlock_t lock;
+	struct timer_list vbus_timer;
+
+	struct vega_ep ep[15];
+
+	enum vega_ctrl_state ep0_state;
+	u8 ep0_dir;
+	u16 ep0_length;
+
+	bool connected;
+
+	unsigned int devstatus;
+};
+
+//struct vega_device;
+//struct vega_udc;
+
+
+
+/*
+int vega_udc_register(struct vega_device *isp, int irq, unsigned long irqflags);
+void vega_udc_unregister(struct vega_device *isp);
+
+static inline u32 vega_read32(void __iomem *base, u32 reg)
+{
+	return readl(base + reg);
+}
+
+static inline void vega_write32(void __iomem *base, u32 reg, u32 val)
+{
+	writel(val, base + reg);
+}
+
+*/
+
+
+
+#endif
diff -Naur linux-5.4.1/drivers/watchdog/cdac_wdt.c linux-5.4.1_modified/drivers/watchdog/cdac_wdt.c
--- linux-5.4.1/drivers/watchdog/cdac_wdt.c	1970-01-01 05:30:00.000000000 +0530
+++ linux-5.4.1_modified/drivers/watchdog/cdac_wdt.c	2025-08-08 10:40:35.459432038 +0530
@@ -0,0 +1,187 @@
+/*
+ * cdac_wdt.c
+ *
+ *Copyright (C) 2020 C-DAC Thiruvananthapuram.
+ *
+ */
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/watchdog.h>
+#include <linux/interrupt.h>
+#include <linux/pm.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+#include <linux/bitops.h>
+#include <linux/of.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/err.h>
+#include <linux/jiffies.h>
+#include <linux/timer.h>
+
+#define DRV_NAME "C-DAC Watchdog"
+
+/*
+ * C-DAC Watchdog register definitions
+ */
+#define CDAC_WDT_KEY 				0x5a5a5a5a
+#define CDAC_WDT_CONTROL_REG 		0x00
+#define CDAC_WDT_SERVICE_REG 		0x04
+#define CDAC_WDT_RESET_STAT_REG 	0x08
+#define CDAC_WDT_INTERRUPT_CTRL_REG 0x0C
+#define WDT_ENABLE 					0x1
+#define WDT_INTERRUPT_ENABLE 		0x1 << 1
+#define WDT_PROC_RESET_ENABLE 		0x1 << 2
+#define WDT_SYS_RESET_ENABLE 		0x1 << 3
+#define WDT_COUNTER_VAL 			GENMASK(23, 4) 		/* User configurable counter value */
+#define WDT_INTERRUPT_COUNTER 		GENMASK(19, 0)
+#define CDAC_WDT_TIMER_INTERVAL 	20
+#define CDAC_WDT_CLK_DIVIDER     	3051
+
+static unsigned int margin;
+static int irq;
+static void __iomem *virtbase;
+static struct device *parent;
+unsigned int clk, one_sec_timeout;
+
+/* Watchdog Functions.*/
+static int cdac_start(struct watchdog_device *wdt_dev)
+{
+	unsigned int reg, wdt_timeout;
+
+	one_sec_timeout = (clk/CDAC_WDT_CLK_DIVIDER); // Interrupt comes 1s before reset.
+	wdt_timeout = one_sec_timeout * (wdt_dev->timeout + 1);
+	//printk("C-DAC Watchdod start %x  :  %x \n",wdt_timeout,(one_sec_timeout & WDT_INTERRUPT_COUNTER));
+	writel((one_sec_timeout & WDT_INTERRUPT_COUNTER), (virtbase + CDAC_WDT_INTERRUPT_CTRL_REG));
+	reg = (WDT_ENABLE | WDT_INTERRUPT_ENABLE| WDT_PROC_RESET_ENABLE |
+	       WDT_SYS_RESET_ENABLE | (WDT_COUNTER_VAL & (wdt_timeout << 4)));
+	writel(reg, (virtbase + CDAC_WDT_CONTROL_REG));
+	return 0;
+}
+
+static int cdac_stop(struct watchdog_device *wdt_dev)
+{
+	unsigned int reg;
+
+	//printk("C-DAC Watchdod stop \n");
+	reg = 0; // Disabling everything.
+	writel(reg, (virtbase + CDAC_WDT_CONTROL_REG));
+	return 0;
+}
+
+static int cdac_wdt_ping(struct watchdog_device *wdd)
+{
+	//printk("C-DAC Watchdog ping \n");
+	/* Feed the watchdog */
+	writel(CDAC_WDT_KEY, (virtbase + CDAC_WDT_SERVICE_REG));
+	return 0;
+}
+
+static int cdac_settimeout(struct watchdog_device *wdt_dev, unsigned int time)
+{
+	wdt_dev->timeout = time;
+	cdac_stop(wdt_dev);
+	cdac_start(wdt_dev);
+	return 0;
+}
+/* TODO */
+/*
+static unsigned int cdac_gettimeleft(struct watchdog_device *wdt_dev)
+{
+	unsigned int timeleft;
+
+	timeleft = 1;
+	printk("C-DAC Watchdod get_timeleft : %d\n", timeleft);
+
+	return timeleft;
+}
+*/
+/*
+ * This interrupt occurs 10 ms before the watchdog WILL bark.
+ */
+static irqreturn_t cdac_wdt_interrupt(int irq, void *data)
+{
+	readl(virtbase + CDAC_WDT_RESET_STAT_REG); // clearing interrupt.
+	panic("C-DAC Watchdog");
+	/* This code should not be reached */
+	return IRQ_HANDLED;
+}
+
+static const struct watchdog_info cdac_ident = {
+	.options = WDIOF_CARDRESET | WDIOF_SETTIMEOUT | WDIOF_KEEPALIVEPING,
+	.identity = DRV_NAME,
+};
+
+static const struct watchdog_ops cdac_ops = {
+	.owner = THIS_MODULE,
+	.start = cdac_start,
+	.stop = cdac_stop,
+	.ping = cdac_wdt_ping,
+	.set_timeout = cdac_settimeout,
+	//.get_timeleft = cdac_gettimeleft,
+};
+
+static struct watchdog_device cdac_wdt = {
+	.info = &cdac_ident,
+	.ops = &cdac_ops,
+	.min_timeout = 1,
+	.max_timeout = 30,
+	.timeout = 20,
+};
+
+static int __init cdac_wdog_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	int ret = 0;
+	struct resource *res;
+
+	parent = dev;
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	virtbase = devm_ioremap_resource(dev, res);
+	if (IS_ERR(virtbase)) {
+		return PTR_ERR(virtbase);
+	}
+
+	ret = of_property_read_u32(dev->of_node, "clock-frequency",
+					   &clk);
+	if (ret < 0) {
+		dev_err(dev, "Couldn't determine clock-frequency.\n");
+		goto error;
+	}
+	irq = platform_get_irq(pdev, 0);
+	if (request_irq(irq, cdac_wdt_interrupt, 0, DRV_NAME, pdev)) {
+		ret = -EIO;
+		goto error;
+	}
+
+	watchdog_init_timeout(&cdac_wdt, margin, dev);
+	cdac_wdt.parent = dev;
+	ret = watchdog_register_device(&cdac_wdt);
+	if (ret)
+		goto error;
+	dev_info(dev, "initialized. (timeout=%d sec)\n", cdac_wdt.timeout);
+	return 0;
+
+error:
+	return ret;
+}
+
+static const struct of_device_id cdac_dt_match[] = {
+	{ .compatible = "cdac,cdac_wdog" },
+	{},
+};
+
+static struct platform_driver cdac_driver = {
+	.driver = {
+		.name	= "cdac_wdog",
+		.of_match_table = cdac_dt_match,
+	},
+};
+
+module_platform_driver_probe(cdac_driver, cdac_wdog_probe);
+module_param(margin, uint, 0);
+MODULE_PARM_DESC(margin, "Watchdog margin in seconds (default 20s)");
+MODULE_ALIAS("platform:cdac-watchdog");
+MODULE_DESCRIPTION("C-DAC Thiruvananthapuram Watchdog Driver");
+MODULE_AUTHOR("Anoop Varghese <vanoop@cdac.in>");
+MODULE_LICENSE("GPL v2");
\ No newline at end of file
diff -Naur linux-5.4.1/drivers/watchdog/Kconfig linux-5.4.1_modified/drivers/watchdog/Kconfig
--- linux-5.4.1/drivers/watchdog/Kconfig	2019-11-29 14:40:32.000000000 +0530
+++ linux-5.4.1_modified/drivers/watchdog/Kconfig	2025-08-08 10:40:35.459614830 +0530
@@ -424,6 +424,14 @@
 	  Say Y here if you want to include support for the watchdog
 	  timer in the Xilinx Zynq.
 
+config CDAC_WATCHDOG
+	tristate "C-DAC Watchdog Timer"
+	depends on HAS_IOMEM
+	select WATCHDOG_CORE
+	help
+	  Say Y here if you want to include support for the watchdog
+	  timer in the Danush64.
+
 config 21285_WATCHDOG
 	tristate "DC21285 watchdog"
 	depends on FOOTBRIDGE
diff -Naur linux-5.4.1/drivers/watchdog/Makefile linux-5.4.1_modified/drivers/watchdog/Makefile
--- linux-5.4.1/drivers/watchdog/Makefile	2019-11-29 14:40:32.000000000 +0530
+++ linux-5.4.1_modified/drivers/watchdog/Makefile	2025-08-08 10:40:35.461273882 +0530
@@ -35,6 +35,8 @@
 
 # ALPHA Architecture
 
+obj-$(CONFIG_CDAC_WATCHDOG) += cdac_wdt.o
+
 # ARM Architecture
 obj-$(CONFIG_ARM_SP805_WATCHDOG) += sp805_wdt.o
 obj-$(CONFIG_ARM_SBSA_WATCHDOG) += sbsa_gwdt.o
diff -Naur linux-5.4.1/scripts/dtc/dtc-lexer.l linux-5.4.1_modified/scripts/dtc/dtc-lexer.l
--- linux-5.4.1/scripts/dtc/dtc-lexer.l	2019-11-29 14:40:32.000000000 +0530
+++ linux-5.4.1_modified/scripts/dtc/dtc-lexer.l	2025-08-08 10:40:35.461438561 +0530
@@ -23,7 +23,6 @@
 #include "srcpos.h"
 #include "dtc-parser.tab.h"
 
-YYLTYPE yylloc;
 extern bool treesource_error;
 
 /* CAUTION: this will stop working if we ever use yyless() or yyunput() */
diff -Naur linux-5.4.1/scripts/dtc/dtc-parser.y linux-5.4.1_modified/scripts/dtc/dtc-parser.y
--- linux-5.4.1/scripts/dtc/dtc-parser.y	2019-11-29 14:40:32.000000000 +0530
+++ linux-5.4.1_modified/scripts/dtc/dtc-parser.y	2025-08-08 10:40:35.461590506 +0530
@@ -2,6 +2,7 @@
 /*
  * (C) Copyright David Gibson <dwg@au1.ibm.com>, IBM Corporation.  2005.
  */
+%locations
 %{
 #include <stdio.h>
 #include <inttypes.h>
diff -Naur linux-5.4.1/tools/perf/Documentation/GNUmakefile linux-5.4.1_modified/tools/perf/Documentation/GNUmakefile
--- linux-5.4.1/tools/perf/Documentation/GNUmakefile	1970-01-01 05:30:00.000000000 +0530
+++ linux-5.4.1_modified/tools/perf/Documentation/GNUmakefile	2025-08-08 10:40:35.461757389 +0530
@@ -0,0 +1,2 @@
+%:
+	@:
